var W5=function(Q,H){if(!Q)throw new Error(typeof H=="string"?H:H())},N6=function(Q){return(new TextDecoder()).decode(Q)},$H=function(Q){switch(Q){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${Q}`)}},f7=function(Q){switch(Q){case o.onnx.TensorProto.DataType.UINT8:case o.onnx.TensorProto.DataType.INT8:case o.onnx.TensorProto.DataType.BOOL:return 1;case o.onnx.TensorProto.DataType.UINT16:case o.onnx.TensorProto.DataType.INT16:return 2;case o.onnx.TensorProto.DataType.FLOAT:case o.onnx.TensorProto.DataType.INT32:case o.onnx.TensorProto.DataType.UINT32:return 4;case o.onnx.TensorProto.DataType.INT64:case o.onnx.TensorProto.DataType.DOUBLE:case o.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${o.onnx.TensorProto.DataType[Q]}`)}},LH=function(Q,H){return new(A2(H))(Q)},A2=function(Q){switch(Q){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}},M6=function(Q,H){if(H===o.onnx.TensorProto.DataType.INT64||H===q5.TensorDataType.INT64){if(Q.greaterThanOrEqual(2147483648)||Q.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else if(H===o.onnx.TensorProto.DataType.UINT32||H===q5.TensorDataType.UINT32||H===o.onnx.TensorProto.DataType.UINT64||H===q5.TensorDataType.UINT64){if(Q.greaterThanOrEqual(4294967296)||Q.lessThan(0))throw new TypeError("uint64 is not supported")}else throw new TypeError(`not a LONG type: ${o.onnx.TensorProto.DataType[H]}`);return Q.toNumber()},l7=function(Q,H,j){switch(H){case o.onnx.TensorProto.DataType.BOOL:case o.onnx.TensorProto.DataType.UINT8:return Q.getUint8(j);case o.onnx.TensorProto.DataType.INT8:return Q.getInt8(j);case o.onnx.TensorProto.DataType.UINT16:return Q.getUint16(j,!0);case o.onnx.TensorProto.DataType.INT16:return Q.getInt16(j,!0);case o.onnx.TensorProto.DataType.FLOAT:return Q.getFloat32(j,!0);case o.onnx.TensorProto.DataType.INT32:return Q.getInt32(j,!0);case o.onnx.TensorProto.DataType.UINT32:return Q.getUint32(j,!0);case o.onnx.TensorProto.DataType.INT64:return M6(_3.fromBits(Q.getUint32(j,!0),Q.getUint32(j+4,!0),!1),H);case o.onnx.TensorProto.DataType.DOUBLE:return Q.getFloat64(j,!0);case o.onnx.TensorProto.DataType.UINT64:return M6(_3.fromBits(Q.getUint32(j,!0),Q.getUint32(j+4,!0),!0),H);default:throw new Error(`cannot read from DataView for type ${o.onnx.TensorProto.DataType[H]}`)}},r=function(Q){return Q===1?e2:Q0},vH=function(Q){let H=r(Q);return`${H.version}
      precision highp float;
      ${H.attribute} vec3 position;
      ${H.attribute} vec2 textureCoord;

      ${H.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`},wH=function(Q){let H=r(Q);return`${H.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${H.varyingFrag} vec2 TexCoords;
    ${H.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `},TH=function(Q,H){let j=r(Q);return`
  void main() {
    int indices[${H}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${j.output} = result;
  }
  `};async function u7(Q,H=(K)=>0,j){return new Promise((K,W)=>{let U=0,Z=()=>{if(Q()){K();return}U++;let q=H(U);if(j!=null&&U>=j){W();return}setTimeout(Z,q)};Z()})}var P5=function(Q){return W5(typeof Q<"u"&&Q.length!==0,()=>"empty string found for sampler name"),"get"+Q.charAt(0).toUpperCase()+Q.slice(1)},DH=function(Q){return W5(typeof Q<"u"&&Q.length!==0,()=>"empty string found for sampler name"),"get"+Q.charAt(0).toUpperCase()+Q.slice(1)+"AtOutCoords"},F4=function(Q,H){let j=JSON.parse(JSON.stringify(Q));return j=H,j},k4=function(Q,H){return H.map((j)=>Q[j]).join(", ")},P3=function(Q){if(Q<=1)return"int";if(Q===2)return"ivec2";if(Q===3)return"ivec3";if(Q===4)return"ivec4";if(Q===5)return"ivec5";if(Q===6)return"ivec6";throw Error(`GPU for rank ${Q} is not yet supported`)},H4=function(Q=6){return["x","y","z","w","u","v"].slice(0,Q)},_H=function(Q,H){return H4(H).map((j)=>`${Q}.${j}`)},n6=function(Q,H){return H===1?[Q]:_H(Q,H)},c4=function(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `},PH=function(Q,H,j){if(Q===0)return"false";if(Q===1)return`rc > ${H[0]}`;let K="";for(let W=Q-2;W<Q;W++)K+=`${j[W]} >= ${H[W-Q+2]}`,W<Q-1&&(K+="||");return K},EH=function(Q,H){let j=Q.length;if(j===0)return"getA(), 0, 0, 0";if(j===1)return`getA(rc),
            rc + 1 >= ${Q[0]} ? 0. : getA(rc + 1),
            0, 0`;let K="r, c",W="r, cp1",U="rp1, c",Z="rp1, cp1",q="";if(j>2)for(let G=0;G<j-2;++G)q=q+`${H[G]},`;return`getA(${q}${K}),
          rEdge ? 0. : getA(${q}${U}),
          cEdge ? 0. : getA(${q}${W}),
          rEdge || cEdge ? 0. : getA(${q}${Z})`},IH=function(Q,H,j,K){return Q===0||Q===1?"":`
    int r = ${H[Q-2]};
    int c = ${H[Q-1]};
    int rp1 = ${H[Q-2]} + 1;
    int cp1 = ${H[Q-1]} + 1;
    bool rEdge = rp1 >= ${K};
    bool cEdge = cp1 >= ${j};
    `},s7=function(Q){if(Q.length===0)return[1,1,1];let H=1;for(let j=0;j<Q.length-2;++j)H*=Q[j];return[H,Q.length>1?Q[Q.length-2]:1,Q[Q.length-1]]},xH=function(Q,H){let j=!1;return Q.length===0||H.length===0?j=!0:Q.length<2||H.length<2?j=Q[Q.length-1]===H[H.length-1]:j=Q[Q.length-1]===H[H.length-1]&&Q[Q.length-2]===H[H.length-2],j},OH=function(Q){let H=u.computeStrides(Q),j=["b","r","c"],K="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${H.map((W,U)=>{let Z=`int ${j[U]} = ${K} / ${W}`,q=U===H.length-1?`int ${j[U+1]} = ${K} - ${j[U]} * ${W}`:`index -= ${j[U]} * ${W}`;return`${Z}; ${q};`}).join("")}
      return ivec3(b, r, c);
    }
  `},gH=function(Q){let H=u.computeStrides(Q);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${H[0]} + coords.z * ${H[1]} + coords.y;
  }
`},yH=function(Q,H){if(Q===1)return"rc";let j="";for(let K=0;K<Q;K++)j+=H[K],K<Q-1&&(j+=",");return j},dH=function(){let Q="add_";return{body:`
  float ${Q}(float a, float b) {
    return a + b;
  }
  vec4 ${Q}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:Q,type:0}},pH=function(){let Q="div_";return{body:`
  float ${Q}(float a, float b) {
    return a / b;
  }
  vec4 ${Q}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:Q,type:0}},hH=function(){let Q="mul_";return{body:`
  float ${Q}(float a, float b) {
    return a * b;
  }
  vec4 ${Q}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:Q,type:0}},bH=function(){let Q="sub_";return{body:`
  float ${Q}(float a, float b) {
    return a - b;
  }
  vec4 ${Q}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:Q,type:0}},mH=function(){let Q="equal_";return{body:`
  float ${Q}(float a, float b) {
    return float(a == b);
  }
  vec4 ${Q}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:Q,type:0}},cH=function(){let Q="greater_";return{body:`
  float ${Q}(float a, float b) {
    return float(a > b);
  }
  vec4 ${Q}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:Q,type:0}},fH=function(){let Q="less_";return{body:`
  float ${Q}(float a, float b) {
    return float(a < b);
  }
  vec4 ${Q}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:Q,type:0}},lH=function(){let Q="and_";return{body:`
  float ${Q}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${Q}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:Q,type:0}},uH=function(){let Q="or_";return{body:`
  float ${Q}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${Q}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:Q,type:0}},sH=function(){let Q="xor_";return{body:`
  float ${Q}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${Q}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:Q,type:0}},iH=function(){return aH("pow")},oH=function(){let Q="prelu_";return{body:`
  float ${Q}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${Q}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:Q,type:0}},aH=function(Q){let H=`${Q}_`;return{body:`
  float ${H}(float a, float b) {
    return ${Q}(a, b);
  }
  vec4 ${H}(vec4 v1, vec4 v2) {
    return ${Q}(v1, v2);
  }
  `,name:H,type:0}},nH=function(){return Q3("abs")},rH=function(){return Q3("acos")},tH=function(){return Q3("asin")},eH=function(){return Q3("atan")},QZ=function(){return Q3("ceil")},JZ=function(){return Q3("cos")},HZ=function(Q){let H="elu";return{body:`
  const float alpha = float(${Q});

  float ${H}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${H}_(vec4 v) {
    return vec4(${H}_(v.x), ${H}_(v.y), ${H}_(v.z), ${H}_(v.w));
  }
  `,name:H,type:0}},ZZ=function(){return Q3("exp")},jZ=function(){return Q3("floor")},S2=function(Q,H){let j="clip";return{body:`
  const float min = float(${Q});
  const float max = float(${H});

  float ${j}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${j}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:j,type:0}},VZ=function(){let Q="indentity";return{body:`
  float ${Q}_(float a) {
    return a;
  }
  vec4 ${Q}_(vec4 v) {
    return v;
  }
  `,name:Q,type:0}},XZ=function(Q){let H="leakyRelu";return{body:`
  const float alpha = float(${Q});

  float ${H}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${H}_(vec4 v) {
    return vec4(${H}_(v.x), ${H}_(v.y), ${H}_(v.z), ${H}_(v.w));
  }
  `,name:H,type:0}},KZ=function(){return Q3("log")},UZ=function(){let Q="neg";return{body:`
  float ${Q}_(float a) {
    return -a;
  }
  vec4 ${Q}_(vec4 v) {
    return -v;
  }
  `,name:Q,type:0}},qZ=function(){let Q="not";return{body:`
  float ${Q}_(float a) {
    return float( ! bool(a) );
  }
  bool ${Q}_(bool a) {
    return !a;
  }
  vec4 ${Q}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${Q}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:Q,type:0}},WZ=function(){return Q3("sin")},$2=function(){let Q="relu";return{body:`
  float ${Q}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${Q}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:Q,type:0}},L2=function(){let Q="sigmoid";return{body:`
  float ${Q}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${Q}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:Q,type:0}},GZ=function(){return Q3("sqrt")},RZ=function(){return Q3("tan")},zZ=function(){let Q="tanh";return{body:`
  float ${Q}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${Q}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:Q,type:0}},Q3=function(Q){return{body:`
  float ${Q}_(float a) {
    return ${Q}(a);
  }
  vec4 ${Q}_(vec4 v) {
    return ${Q}(v);
  }
  `,name:Q,type:0}},f4=function(Q){let H;switch(Q.activation){case"Relu":H=$2();break;case"Sigmoid":H=L2();break;case"Clip":H=S2(Q.clipMin,Q.clipMax);break;default:return{activationFunction:"",applyActivation:""}}let{name:j,body:K}=H,W=`value = ${j}_(value);`;return{activationFunction:K,applyActivation:W}},NZ=function(Q,H,j){let K=H[0].dims,W=H[1].dims,U=R3.calcShape(K,W,!0);if(!U)throw new Error("Can't use matmul on the given tensors");let Z=P3(U.length),q=H4(),{activationFunction:G,applyActivation:J}=f4(j),X=H.length>2,V=X?"value += getBiasForMatmul();":"",R=X?`${w2(Z,q,H[2].dims,U,!1)}`:"",z=U.length,Y=K.length,B=W.length,k=K[K.length-1],w=`
    ${G}
    ${R}
    float process(int indices[${z}]) {
        int a[${Y}];
        int b[${B}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${k}; ++k) {
            a[${Y-1}] = k;
            b[${B-2}] = k;
            value += _A(a) * _B(b);
        }
        ${V}
        ${J}
        return value;
    }`;return{...Q,output:{dims:U,type:H[0].type,textureType:0},shaderSource:w}},v2=function(Q,H){let j=ZQ(Q.length>2,H.activationCacheKey);return{...j,get:()=>NZ(j,Q,H)}},w2=function(Q,H,j,K,W){let U="",Z=j.length,q=K.length,G=q-Z;q<2&&Z>0?U="coords":U=j.map((R,z)=>`coords.${H[z+G]}`).join(", ");let J=R3.getBroadcastDims(j,K).map((R)=>`coords.${H[R+G]} = 0;`).join(`
`),X=u.size(j)===1,V="vec4(outputValue.xx, outputValue.yy)";return X&&(V="vec4(outputValue.x)"),W?`
vec4 getBiasForMatmul() {
  ${Q} coords = getOutputCoords();
  ${J}
  vec4 outputValue = getBias(${U});
  return ${V};
}`:`
float getBiasForMatmul() {
  ${Q} coords = getOutputCoords();
  ${J}
  return getBias(coords.x);
}`},MZ=function(Q,H,j,K){let W=[],U=[],Z=j[0].dims,q=j[1].dims,G=Z.length,J=q.length,X=K.length,V=X-G,R=X-J;W=Z.map((A,D)=>`coords.${H[D+V]}`),W[G-1]="i*2",W.join(", "),U=q.map((A,D)=>`coords.${H[D+R]}`),U[J-2]="i*2",U.join(", ");let z=R3.getBroadcastDims(Z,K),Y=R3.getBroadcastDims(q,K),B=z.map((A)=>`coords.${H[A+V]} = 0;`).join(`
`),k=Y.map((A)=>`coords.${H[A+R]} = 0;`).join(`
`),w=`int lastDim = coords.${H[X-1]};
  coords.${H[X-1]} = coords.${H[X-2]};
  coords.${H[X-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${Q} coords = getOutputCoords();
  ${w}
  ${B}
  vec4 outputValue = getA(${W});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${Q} coords = getOutputCoords();
  ${w}
  ${k}
  vec4 outputValue = getB(${U});
  return outputValue;
}`},YZ=function(Q,H){let j="";for(let K=0;K<H-2;K++)j+=`rc.${Q[K]}, `;return j+=`rc.${Q[H-2]}, i*2`,j},CZ=function(Q,H){let j="";for(let K=0;K<H-2;K++)j+=`rc.${Q[K]}, `;return j+=`i*2, rc.${Q[H-1]}`,j},BZ=function(Q,H){let j=Q[0].dims[1],K=Q[0].dims.length,W=-Math.floor((H.size-1)/2),U=Math.ceil((H.size-1)/2),Z=`float(${H.alpha}) / float(${H.size})`,q=`float(${H.bias})`,G=`float(${H.beta})`,J=`
    float process(int indices[${K}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${W}; i <= ${U}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${j}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(${q} + ${Z} * square_sum, ${G});
    }`;return{...K7,cacheHint:H.cacheKey,output:{dims:Q[0].dims,type:Q[0].type,textureType:0},shaderSource:J}},FZ=function(Q,H){return{...K7,cacheHint:H.cacheKey,get:()=>BZ(Q,H)}},kZ=function(Q){let H={},j;for(;(j=m6.exec(Q))!==null;){let K=j[3].split(",").map((W)=>{let U=W.trim().split(" ");return U&&U.length===2?{type:U[0],name:U[1]}:null}).filter((W)=>W!==null);H[j[2]]={params:K,body:j[4]}}for(let K in H){let W=RJ.replace("__FUNC__",K),U=new RegExp(W,"gm");for(;(j=U.exec(Q))!==null;){let Z=j[1],q=j[2],G=j[3].split(","),J=Z?`${Z} ${q};`:"",X=H[K].body,V="";H[K].params.forEach((z,Y)=>{z&&(V+=`${z.type} ${z.name} = ${G[Y]};
`)}),X=`${V}
 ${X}`,X=X.replace("return",`${q} = `);let R=`
      ${J}
      {
        ${X}
      }
      `;Q=Q.replace(j[0],R)}}return Q=Q.replace(m6,""),Q},E4=function(Q,H){let j=[],K=[],W=H!=null&&Array.isArray(H)&&H.length===0,U=H==null||W?null:AZ(H,Q).sort(),Z=0;for(let q=0;q<Q.length;++q){if(U!=null){if(U[Z]===q&&Q[q]!==1)throw new Error(`Can't squeeze axis ${q} since its dim '${Q[q]}' is not 1`);(U[Z]==null||U[Z]>q)&&Q[q]===1&&(j.push(Q[q]),K.push(q)),U[Z]<=q&&Z++}Q[q]!==1&&(j.push(Q[q]),K.push(q))}return{newShape:j,keptDims:K}},AZ=function(Q,H){let j=H.length;return Q=Q==null?H.map((K,W)=>W):[].concat(Q),W5(Q.every((K)=>K>=-j&&K<j),()=>`All values in axis param must be in range [-${j}, ${j}) but got axis ${Q}`),W5(Q.every(SZ),()=>`All values in axis param must be integers but got axis ${Q}`),Q.map((K)=>K<0?j+K:K)},SZ=function(Q){return Q%1===0},$Z=function(Q){if(Q.length===0)return 1;let H=Q[0];for(let j=1;j<Q.length;j++)H*=Q[j];return H},i7=function(Q){let H=Math.ceil(Math.sqrt(Q));return[H,Math.ceil(Q/H)]},LZ=function(Q){let H=0;for(;H<Q.length&&Q[H]();++H);return H-1},T2=function(Q){let H;if((!Q||Q==="webgl2")&&"webgl2"in u3?H=u3.webgl2:(!Q||Q==="webgl")&&("webgl"in u3)&&(H=u3.webgl),!H)try{let K=wZ();H=o7(K,Q)}catch{let K=vZ();H=o7(K,Q)}Q=Q||H.version===1?"webgl":"webgl2";let j=H.gl;return u3[Q]=H,j.isContextLost()?(delete u3[Q],T2(Q)):(j.disable(j.DEPTH_TEST),j.disable(j.STENCIL_TEST),j.disable(j.BLEND),j.disable(j.DITHER),j.disable(j.POLYGON_OFFSET_FILL),j.disable(j.SAMPLE_COVERAGE),j.enable(j.SCISSOR_TEST),j.enable(j.CULL_FACE),j.cullFace(j.BACK),H)},o7=function(Q,H){let j={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1},K,W=j;if((!H||H==="webgl2")&&(K=Q.getContext("webgl2",W),K))try{return new f6(K,2)}catch(U){C1.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${U}`)}if((!H||H==="webgl")&&(K=Q.getContext("webgl",W)||Q.getContext("experimental-webgl",W),K))try{return new f6(K,1)}catch(U){C1.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${U}`)}throw new Error("WebGL is not supported")},vZ=function(){if(typeof document>"u")throw new TypeError("failed to create canvas: document is not supported");let Q=document.createElement("canvas");return Q.width=1,Q.height=1,Q},wZ=function(){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)};async function D2(Q){if(Q){let H=typeof Q=="string"?[Q]:Q;for(let j of H){let K=U7.get(j);if(K)return K;let W=await TZ(j);if(W)return W}}else return D2(["webgl"]);throw new Error("no available backend to use")}async function TZ(Q){let H=vJ;if(typeof H[Q]<"u"&&DZ(H[Q])){let j=H[Q],K=j.initialize();if(typeof K=="object"&&"then"in K&&(K=await K),K)return U7.set(Q,j),j}}var DZ=function(Q){let H=Q;return"initialize"in H&&typeof H.initialize=="function"&&"createSessionHandler"in H&&typeof H.createSessionHandler=="function"&&"dispose"in H&&typeof H.dispose=="function"},s3=function(Q,H,j,K){if(H===void 0)return kH(Q);if(j===void 0)H5(Q,H,1);else if(typeof j=="number"&&K===void 0)H5(Q,H,j);else if(typeof j=="string"&&K===void 0)H5(Q,j,1,H);else if(typeof j=="string"&&typeof K=="number")H5(Q,j,K,H);else throw new TypeError("input is valid")},kH=function(Q){return{verbose:s3.verbose.bind(null,Q),info:s3.info.bind(null,Q),warning:s3.warning.bind(null,Q),error:s3.error.bind(null,Q),fatal:s3.fatal.bind(null,Q)}},H5=function(Q,H,j,K){let W=J4[K||""]||J4[""];C6[Q]<C6[W.minimalSeverity]||(W.logDateTime&&(H=`${(new Date()).toISOString()}|${H}`),W.logSourceLocation,i2[W.provider].log(Q,H,K))},AH=function(Q,H,j){for(let K of j){let W=K[0],U=K[1],Z=K[2],q=K[3],G=K[4];if(Q.opType===W){for(let J of H)if((J.domain===U||J.domain==="ai.onnx"&&U==="")&&SH(J.version,Z))return{opImpl:q,opInit:G}}}throw new TypeError(`cannot resolve operator '${Q.opType}' with opsets: ${H.map((K)=>`${K.domain||"ai.onnx"} v${K.version}`).join(", ")}`)},SH=function(Q,H){if(H.endsWith("+")){let j=Number.parseInt(H.substring(0,H.length-1),10);return!isNaN(j)&&j<=Q}else if(H.split("-").length===2){let j=H.split("-"),K=Number.parseInt(j[0],10),W=Number.parseInt(j[1],10);return!isNaN(K)&&!isNaN(W)&&K<=Q&&Q<=W}else return Number.parseInt(H,10)===Q},X1=function(Q,H,j){this.low=Q|0,this.high=H|0,this.unsigned=!!j},I1=function(Q){return(Q&&Q.__isLong__)===!0},c7=function(Q){var H=Math.clz32(Q&-Q);return Q?31-H:H},b3=function(Q,H){var j,K,W;return H?(Q>>>=0,(W=0<=Q&&Q<256)&&(K=F6[Q],K)?K:(j=e(Q,0,!0),W&&(F6[Q]=j),j)):(Q|=0,(W=-128<=Q&&Q<128)&&(K=B6[Q],K)?K:(j=e(Q,Q<0?-1:0,!1),W&&(B6[Q]=j),j))},e1=function(Q,H){if(isNaN(Q))return H?W3:t1;if(H){if(Q<0)return W3;if(Q>=k6)return $6}else{if(Q<=-A6)return y1;if(Q+1>=A6)return S6}return Q<0?e1(-Q,H).neg():e(Q%o3|0,Q/o3|0,H)},e=function(Q,H,j){return new X1(Q,H,j)},a6=function(Q,H,j){if(Q.length===0)throw Error("empty string");if(typeof H=="number"?(j=H,H=!1):H=!!H,Q==="NaN"||Q==="Infinity"||Q==="+Infinity"||Q==="-Infinity")return H?W3:t1;if(j=j||10,j<2||36<j)throw RangeError("radix");var K;if((K=Q.indexOf("-"))>0)throw Error("interior hyphen");if(K===0)return a6(Q.substring(1),H,j).neg();for(var W=e1(O4(j,8)),U=t1,Z=0;Z<Q.length;Z+=8){var q=Math.min(8,Q.length-Z),G=parseInt(Q.substring(Z,Z+q),j);if(q<8){var J=e1(O4(j,q));U=U.mul(J).add(e1(G))}else U=U.mul(W),U=U.add(e1(G))}return U.unsigned=H,U},Z3=function(Q,H){return typeof Q=="number"?e1(Q,H):typeof Q=="string"?a6(Q,H):e(Q.low,Q.high,typeof H=="boolean"?H:Q.unsigned)},r6="./",G5="./onyx-runtimeweb.js";/*!
 * ONNX Runtime Web v1.18.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var{create:_Z,defineProperty:C5,getOwnPropertyDescriptor:PZ,getOwnPropertyNames:EZ,getPrototypeOf:IZ}=Object,xZ=Object.prototype.hasOwnProperty,E=(Q,H)=>()=>(Q&&(H=Q(Q=0)),H),U1=(Q,H)=>()=>(H||Q((H={exports:{}}).exports,H),H.exports),X4=(Q,H)=>{for(var j in H)C5(Q,j,{get:H[j],enumerable:!0})},_2=(Q,H,j,K)=>{if(H&&typeof H=="object"||typeof H=="function")for(let W of EZ(H))!xZ.call(Q,W)&&W!==j&&C5(Q,W,{get:()=>H[W],enumerable:!(K=PZ(H,W))||K.enumerable});return Q},Z4=(Q,H,j)=>(j=Q!=null?_Z(IZ(Q)):{},_2(H||!Q||!Q.__esModule?C5(j,"default",{value:Q,enumerable:!0}):j,Q)),a3=(Q)=>_2(C5({},"__esModule",{value:!0}),Q),A4,v3,p4,a7,t6,e6=E(()=>{A4=new Map,v3=[],p4=(Q,H,j)=>{if(H&&typeof H.init=="function"&&typeof H.createInferenceSessionHandler=="function"){let K=A4.get(Q);if(K===void 0)A4.set(Q,{backend:H,priority:j});else{if(K.priority>j)return;if(K.priority===j&&K.backend!==H)throw new Error(`cannot register backend "${Q}" using priority ${j}`)}if(j>=0){let W=v3.indexOf(Q);W!==-1&&v3.splice(W,1);for(let U=0;U<v3.length;U++)if(A4.get(v3[U]).priority<=j){v3.splice(U,0,Q);return}v3.push(Q)}return}throw new TypeError("not a valid backend")},a7=async(Q)=>{let H=A4.get(Q);if(!H)return"backend not found.";if(H.initialized)return H.backend;if(H.aborted)return H.error;{let j=!!H.initPromise;try{return j||(H.initPromise=H.backend.init(Q)),await H.initPromise,H.initialized=!0,H.backend}catch(K){return j||(H.error=`${K}`,H.aborted=!0),H.error}finally{delete H.initPromise}}},t6=async(Q)=>{let H=Q.executionProviders||[],j=H.map((G)=>typeof G=="string"?G:G.name),K=j.length===0?v3:j,W,U=[],Z=new Set;for(let G of K){let J=await a7(G);typeof J=="string"?U.push({name:G,err:J}):(W||(W=J),W===J&&Z.add(G))}if(!W)throw new Error(`no available backend found. ERR: ${U.map((G)=>`[${G.name}] ${G.err}`).join(", ")}`);for(let{name:G,err:J}of U)j.includes(G)&&console.warn(`removing requested execution provider "${G}" from session options because it is not available: ${J}`);let q=H.filter((G)=>Z.has(typeof G=="string"?G:G.name));return[W,new Proxy(Q,{get:(G,J)=>J==="executionProviders"?q:Reflect.get(G,J)})]}}),OZ=E(()=>{e6()}),P2,gZ=E(()=>{P2="1.18.0"}),E5,r1,E2=E(()=>{gZ(),E5="warning",r1={wasm:{},webgl:{},webgpu:{},versions:{common:P2},set logLevel(Q){if(Q!==void 0){if(typeof Q!="string"||["verbose","info","warning","error","fatal"].indexOf(Q)===-1)throw new Error(`Unsupported logging level: ${Q}`);E5=Q}},get logLevel(){return E5}},Object.defineProperty(r1,"logLevel",{enumerable:!0})}),i,yZ=E(()=>{E2(),i=r1}),I2,x2,dZ=E(()=>{I2=(Q,H)=>{let j=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);j.width=Q.dims[3],j.height=Q.dims[2];let K=j.getContext("2d");if(K!=null){let W,U;H?.tensorLayout!==void 0&&H.tensorLayout==="NHWC"?(W=Q.dims[2],U=Q.dims[3]):(W=Q.dims[3],U=Q.dims[2]);let Z=H?.format!==void 0?H.format:"RGB",q=H?.norm,G,J;q===void 0||q.mean===void 0?G=[255,255,255,255]:typeof q.mean=="number"?G=[q.mean,q.mean,q.mean,q.mean]:(G=[q.mean[0],q.mean[1],q.mean[2],0],q.mean[3]!==void 0&&(G[3]=q.mean[3])),q===void 0||q.bias===void 0?J=[0,0,0,0]:typeof q.bias=="number"?J=[q.bias,q.bias,q.bias,q.bias]:(J=[q.bias[0],q.bias[1],q.bias[2],0],q.bias[3]!==void 0&&(J[3]=q.bias[3]));let X=U*W,V=0,R=X,z=X*2,Y=-1;Z==="RGBA"?(V=0,R=X,z=X*2,Y=X*3):Z==="RGB"?(V=0,R=X,z=X*2):Z==="RBG"&&(V=0,z=X,R=X*2);for(let B=0;B<U;B++)for(let k=0;k<W;k++){let w=(Q.data[V++]-J[0])*G[0],A=(Q.data[R++]-J[1])*G[1],D=(Q.data[z++]-J[2])*G[2],I=Y===-1?255:(Q.data[Y++]-J[3])*G[3];K.fillStyle="rgba("+w+","+A+","+D+","+I+")",K.fillRect(k,B,1,1)}if("toDataURL"in j)return j.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},x2=(Q,H)=>{let j=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),K;if(j!=null){let W,U,Z;H?.tensorLayout!==void 0&&H.tensorLayout==="NHWC"?(W=Q.dims[2],U=Q.dims[1],Z=Q.dims[3]):(W=Q.dims[3],U=Q.dims[2],Z=Q.dims[1]);let q=H!==void 0&&H.format!==void 0?H.format:"RGB",G=H?.norm,J,X;G===void 0||G.mean===void 0?J=[255,255,255,255]:typeof G.mean=="number"?J=[G.mean,G.mean,G.mean,G.mean]:(J=[G.mean[0],G.mean[1],G.mean[2],255],G.mean[3]!==void 0&&(J[3]=G.mean[3])),G===void 0||G.bias===void 0?X=[0,0,0,0]:typeof G.bias=="number"?X=[G.bias,G.bias,G.bias,G.bias]:(X=[G.bias[0],G.bias[1],G.bias[2],0],G.bias[3]!==void 0&&(X[3]=G.bias[3]));let V=U*W;if(H!==void 0&&(H.format!==void 0&&Z===4&&H.format!=="RGBA"||Z===3&&H.format!=="RGB"&&H.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let R=4,z=0,Y=1,B=2,k=3,w=0,A=V,D=V*2,I=-1;q==="RGBA"?(w=0,A=V,D=V*2,I=V*3):q==="RGB"?(w=0,A=V,D=V*2):q==="RBG"&&(w=0,D=V,A=V*2),K=j.createImageData(W,U);for(let h=0;h<U*W;z+=R,Y+=R,B+=R,k+=R,h++)K.data[z]=(Q.data[w++]-X[0])*J[0],K.data[Y]=(Q.data[A++]-X[1])*J[1],K.data[B]=(Q.data[D++]-X[2])*J[2],K.data[k]=I===-1?255:(Q.data[I++]-X[3])*J[3]}else throw new Error("Can not access image data");return K}}),Z5,O2,g2,y2,d2,pZ=E(()=>{Q7(),Z5=(Q,H)=>{if(Q===void 0)throw new Error("Image buffer must be defined");if(H.height===void 0||H.width===void 0)throw new Error("Image height and width must be defined");if(H.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:j,width:K}=H,W=H.norm??{mean:255,bias:0},U,Z;typeof W.mean=="number"?U=[W.mean,W.mean,W.mean,W.mean]:U=[W.mean[0],W.mean[1],W.mean[2],W.mean[3]??255],typeof W.bias=="number"?Z=[W.bias,W.bias,W.bias,W.bias]:Z=[W.bias[0],W.bias[1],W.bias[2],W.bias[3]??0];let q=H.format!==void 0?H.format:"RGBA",G=H.tensorFormat!==void 0&&H.tensorFormat!==void 0?H.tensorFormat:"RGB",J=j*K,X=G==="RGBA"?new Float32Array(J*4):new Float32Array(J*3),V=4,R=0,z=1,Y=2,B=3,k=0,w=J,A=J*2,D=-1;q==="RGB"&&(V=3,R=0,z=1,Y=2,B=-1),G==="RGBA"?D=J*3:G==="RBG"?(k=0,A=J,w=J*2):G==="BGR"&&(A=0,w=J,k=J*2);for(let I=0;I<J;I++,R+=V,Y+=V,z+=V,B+=V)X[k++]=(Q[R]+Z[0])/U[0],X[w++]=(Q[z]+Z[1])/U[1],X[A++]=(Q[Y]+Z[2])/U[2],D!==-1&&B!==-1&&(X[D++]=(Q[B]+Z[3])/U[3]);return G==="RGBA"?new j3("float32",X,[1,4,j,K]):new j3("float32",X,[1,3,j,K])},O2=async(Q,H)=>{let j=typeof HTMLImageElement<"u"&&Q instanceof HTMLImageElement,K=typeof ImageData<"u"&&Q instanceof ImageData,W=typeof ImageBitmap<"u"&&Q instanceof ImageBitmap,U=typeof Q=="string",Z,q=H??{},G=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},J=(X)=>X instanceof HTMLCanvasElement||X instanceof OffscreenCanvas?X.getContext("2d"):null;if(j){let X=G();X.width=Q.width,X.height=Q.height;let V=J(X);if(V!=null){let{height:R,width:z}=Q;if(H!==void 0&&H.resizedHeight!==void 0&&H.resizedWidth!==void 0&&(R=H.resizedHeight,z=H.resizedWidth),H!==void 0){if(q=H,H.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");q.tensorFormat="RGBA",q.height=R,q.width=z}else q.tensorFormat="RGBA",q.height=R,q.width=z;V.drawImage(Q,0,0),Z=V.getImageData(0,0,z,R).data}else throw new Error("Can not access image data")}else if(K){let X,V;if(H!==void 0&&H.resizedWidth!==void 0&&H.resizedHeight!==void 0?(X=H.resizedHeight,V=H.resizedWidth):(X=Q.height,V=Q.width),H!==void 0&&(q=H),q.format="RGBA",q.height=X,q.width=V,H!==void 0){let R=G();R.width=V,R.height=X;let z=J(R);if(z!=null)z.putImageData(Q,0,0),Z=z.getImageData(0,0,V,X).data;else throw new Error("Can not access image data")}else Z=Q.data}else if(W){if(H===void 0)throw new Error("Please provide image config with format for Imagebitmap");let X=G();X.width=Q.width,X.height=Q.height;let V=J(X);if(V!=null){let{height:R,width:z}=Q;return V.drawImage(Q,0,0,z,R),Z=V.getImageData(0,0,z,R).data,q.height=R,q.width=z,Z5(Z,q)}else throw new Error("Can not access image data")}else{if(U)return new Promise((X,V)=>{let R=G(),z=J(R);if(!Q||!z)return V();let Y=new Image;Y.crossOrigin="Anonymous",Y.src=Q,Y.onload=()=>{R.width=Y.width,R.height=Y.height,z.drawImage(Y,0,0,R.width,R.height);let B=z.getImageData(0,0,R.width,R.height);q.height=R.height,q.width=R.width,X(Z5(B.data,q))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(Z!==void 0)return Z5(Z,q);throw new Error("Input data provided is not supported - aborted tensor creation")},g2=(Q,H)=>{let{width:j,height:K,download:W,dispose:U}=H;return new j3({location:"texture",type:"float32",texture:Q,dims:[1,K,j,4],download:W,dispose:U})},y2=(Q,H)=>{let{dataType:j,dims:K,download:W,dispose:U}=H;return new j3({location:"gpu-buffer",type:j??"float32",gpuBuffer:Q,dims:K,download:W,dispose:U})},d2=(Q,H,j)=>new j3({location:"cpu-pinned",type:Q,data:H,dims:j??[H.length]})}),i3,I4,I5,p2,hZ=E(()=>{i3=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),I4=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),I5=!1,p2=()=>{if(!I5){I5=!0;let Q=typeof BigInt64Array<"u"&&BigInt64Array.from,H=typeof BigUint64Array<"u"&&BigUint64Array.from,j=typeof Float16Array<"u"&&Float16Array.from;Q&&(i3.set("int64",BigInt64Array),I4.set(BigInt64Array,"int64")),H&&(i3.set("uint64",BigUint64Array),I4.set(BigUint64Array,"uint64")),j?(i3.set("float16",Float16Array),I4.set(Float16Array,"float16")):i3.set("float16",Uint16Array)}}}),h2,b2,bZ=E(()=>{Q7(),h2=(Q)=>{let H=1;for(let j=0;j<Q.length;j++){let K=Q[j];if(typeof K!="number"||!Number.isSafeInteger(K))throw new TypeError(`dims[${j}] must be an integer, got: ${K}`);if(K<0)throw new RangeError(`dims[${j}] must be a non-negative integer, got: ${K}`);H*=K}return H},b2=(Q,H)=>{switch(Q.location){case"cpu":return new j3(Q.type,Q.data,H);case"cpu-pinned":return new j3({location:"cpu-pinned",data:Q.data,type:Q.type,dims:H});case"texture":return new j3({location:"texture",texture:Q.texture,type:Q.type,dims:H});case"gpu-buffer":return new j3({location:"gpu-buffer",gpuBuffer:Q.gpuBuffer,type:Q.type,dims:H});default:throw new Error(`tensorReshape: tensor location ${Q.location} is not supported`)}}}),j3,Q7=E(()=>{dZ(),pZ(),hZ(),bZ(),j3=class{constructor(Q,H,j){p2();let K,W;if(typeof Q=="object"&&"location"in Q)switch(this.dataLocation=Q.location,K=Q.type,W=Q.dims,Q.location){case"cpu-pinned":{let Z=i3.get(K);if(!Z)throw new TypeError(`unsupported type "${K}" to create tensor from pinned buffer`);if(!(Q.data instanceof Z))throw new TypeError(`buffer should be of type ${Z.name}`);this.cpuData=Q.data;break}case"texture":{if(K!=="float32")throw new TypeError(`unsupported type "${K}" to create tensor from texture`);this.gpuTextureData=Q.texture,this.downloader=Q.download,this.disposer=Q.dispose;break}case"gpu-buffer":{if(K!=="float32"&&K!=="float16"&&K!=="int32"&&K!=="int64"&&K!=="uint32"&&K!=="uint8"&&K!=="bool")throw new TypeError(`unsupported type "${K}" to create tensor from gpu buffer`);this.gpuBufferData=Q.gpuBuffer,this.downloader=Q.download,this.disposer=Q.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let Z,q;if(typeof Q=="string")if(K=Q,q=j,Q==="string"){if(!Array.isArray(H))throw new TypeError("A string tensor's data must be a string array.");Z=H}else{let G=i3.get(Q);if(G===void 0)throw new TypeError(`Unsupported tensor type: ${Q}.`);if(Array.isArray(H)){if(Q==="float16"&&G===Uint16Array)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");Q==="uint64"||Q==="int64"?Z=G.from(H,BigInt):Z=G.from(H)}else if(H instanceof G)Z=H;else throw new TypeError(`A ${K} tensor's data must be type of ${G}`)}else if(q=H,Array.isArray(Q)){if(Q.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let G=typeof Q[0];if(G==="string")K="string",Z=Q;else if(G==="boolean")K="bool",Z=Uint8Array.from(Q);else throw new TypeError(`Invalid element type of data array: ${G}.`)}else{let G=I4.get(Q.constructor);if(G===void 0)throw new TypeError(`Unsupported type for tensor data: ${Q.constructor}.`);K=G,Z=Q}if(q===void 0)q=[Z.length];else if(!Array.isArray(q))throw new TypeError("A tensor's dims must be a number array");W=q,this.cpuData=Z,this.dataLocation="cpu"}let U=h2(W);if(this.cpuData&&U!==this.cpuData.length)throw new Error(`Tensor's size(${U}) does not match data length(${this.cpuData.length}).`);this.type=K,this.dims=W,this.size=U}static async fromImage(Q,H){return O2(Q,H)}static fromTexture(Q,H){return g2(Q,H)}static fromGpuBuffer(Q,H){return y2(Q,H)}static fromPinnedBuffer(Q,H,j){return d2(Q,H,j)}toDataURL(Q){return I2(this,Q)}toImageData(Q){return x2(this,Q)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(Q){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let H=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=H,Q&&this.disposer&&(this.disposer(),this.disposer=void 0),H}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(Q){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return b2(this,Q)}}}),d1,J7=E(()=>{Q7(),d1=j3}),Y6,x5,j4,V4,m2=E(()=>{E2(),Y6=(Q,H)=>{(typeof r1.trace>"u"?!r1.wasm.trace:!r1.trace)||console.timeStamp(`${Q}::ORT::${H}`)},x5=(Q,H)=>{let j=new Error().stack?.split(/\r\n|\r|\n/g)||[],K=!1;for(let W=0;W<j.length;W++){if(K&&!j[W].includes("TRACE_FUNC")){let U=`FUNC_${Q}::${j[W].trim().split(" ")[1]}`;H&&(U+=`::${H}`),Y6("CPU",U);return}j[W].includes("TRACE_FUNC")&&(K=!0)}},j4=(Q)=>{(typeof r1.trace>"u"?!r1.wasm.trace:!r1.trace)||x5("BEGIN",Q)},V4=(Q)=>{(typeof r1.trace>"u"?!r1.wasm.trace:!r1.trace)||x5("END",Q)}}),c2,mZ=E(()=>{e6(),J7(),m2(),c2=class Q{constructor(H){this.handler=H}async run(H,j,K){j4();let W={},U={};if(typeof H!="object"||H===null||H instanceof d1||Array.isArray(H))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let Z=!0;if(typeof j=="object"){if(j===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(j instanceof d1)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(j)){if(j.length===0)throw new TypeError("'fetches' cannot be an empty array.");Z=!1;for(let J of j){if(typeof J!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(J)===-1)throw new RangeError(`'fetches' contains invalid output name: ${J}.`);W[J]=null}if(typeof K=="object"&&K!==null)U=K;else if(typeof K<"u")throw new TypeError("'options' must be an object.")}else{let J=!1,X=Object.getOwnPropertyNames(j);for(let V of this.outputNames)if(X.indexOf(V)!==-1){let R=j[V];(R===null||R instanceof d1)&&(J=!0,Z=!1,W[V]=R)}if(J){if(typeof K=="object"&&K!==null)U=K;else if(typeof K<"u")throw new TypeError("'options' must be an object.")}else U=j}}else if(typeof j<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let J of this.inputNames)if(typeof H[J]>"u")throw new Error(`input '${J}' is missing in 'feeds'.`);if(Z)for(let J of this.outputNames)W[J]=null;let q=await this.handler.run(H,W,U),G={};for(let J in q)if(Object.hasOwnProperty.call(q,J)){let X=q[J];X instanceof d1?G[J]=X:G[J]=new d1(X.type,X.data,X.dims)}return V4(),G}async release(){return this.handler.dispose()}static async create(H,j,K,W){j4();let U,Z={};if(typeof H=="string"){if(U=H,typeof j=="object"&&j!==null)Z=j;else if(typeof j<"u")throw new TypeError("'options' must be an object.")}else if(H instanceof Uint8Array){if(U=H,typeof j=="object"&&j!==null)Z=j;else if(typeof j<"u")throw new TypeError("'options' must be an object.")}else if(H instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&H instanceof SharedArrayBuffer){let X=H,V=0,R=H.byteLength;if(typeof j=="object"&&j!==null)Z=j;else if(typeof j=="number"){if(V=j,!Number.isSafeInteger(V))throw new RangeError("'byteOffset' must be an integer.");if(V<0||V>=X.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${X.byteLength}).`);if(R=H.byteLength-V,typeof K=="number"){if(R=K,!Number.isSafeInteger(R))throw new RangeError("'byteLength' must be an integer.");if(R<=0||V+R>X.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${X.byteLength-V}].`);if(typeof W=="object"&&W!==null)Z=W;else if(typeof W<"u")throw new TypeError("'options' must be an object.")}else if(typeof K<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof j<"u")throw new TypeError("'options' must be an object.");U=new Uint8Array(X,V,R)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[q,G]=await t6(Z),J=await q.createInferenceSessionHandler(U,G);return V4(),new Q(J)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),f2,cZ=E(()=>{mZ(),f2=c2}),fZ=E(()=>{}),lZ=E(()=>{}),uZ=E(()=>{}),sZ=E(()=>{}),n7,l2,iZ=E(()=>{e6(),J7(),n7="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",l2=class Q{constructor(H,j,K){this.handler=H,this.hasOptimizerModel=j,this.hasEvalModel=K}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(H,j){let K=H.evalModel||"",W=H.optimizerModel||"",U=j||{},[Z,q]=await t6(U);if(Z.createTrainingSessionHandler){let G=await Z.createTrainingSessionHandler(H.checkpointState,H.trainModel,K,W,q);return new Q(G,!!H.optimizerModel,!!H.evalModel)}else throw new Error(n7)}typeNarrowingForRunStep(H,j,K,W,U){let Z={},q={};if(typeof K!="object"||K===null||K instanceof d1||Array.isArray(K))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let G=!0;if(typeof W=="object"){if(W===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(W instanceof d1)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(W)){if(W.length===0)throw new TypeError("'fetches' cannot be an empty array.");G=!1;for(let J of W){if(typeof J!="string")throw new TypeError("'fetches' must be a string array or an object.");if(j.indexOf(J)===-1)throw new RangeError(`'fetches' contains invalid output name: ${J}.`);Z[J]=null}if(typeof U=="object"&&U!==null)q=U;else if(typeof U<"u")throw new TypeError("'options' must be an object.")}else{let J=!1,X=Object.getOwnPropertyNames(W);for(let V of j)if(X.indexOf(V)!==-1){let R=W[V];(R===null||R instanceof d1)&&(J=!0,G=!1,Z[V]=R)}if(J){if(typeof U=="object"&&U!==null)q=U;else if(typeof U<"u")throw new TypeError("'options' must be an object.")}else q=W}}else if(typeof W<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let J of H)if(typeof K[J]>"u")throw new Error(`input '${J}' is missing in 'feeds'.`);if(G)for(let J of j)Z[J]=null;return[Z,q]}convertHandlerReturnTypeToMapOfTensors(H){let j={};for(let K in H)if(Object.hasOwnProperty.call(H,K)){let W=H[K];W instanceof d1?j[K]=W:j[K]=new d1(W.type,W.data,W.dims)}return j}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(H,j,K){let[W,U]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,H,j,K),Z=await this.handler.runTrainStep(H,W,U);return this.convertHandlerReturnTypeToMapOfTensors(Z)}async runOptimizerStep(H){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(H||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(H,j,K){if(this.hasEvalModel){let[W,U]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,H,j,K),Z=await this.handler.runEvalStep(H,W,U);return this.convertHandlerReturnTypeToMapOfTensors(Z)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(H=!0){return this.handler.getParametersSize(H)}async loadParametersBuffer(H,j=!0){let K=await this.getParametersSize(j);if(H.length!==4*K)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(H,j)}async getContiguousParameters(H=!0){return this.handler.getContiguousParameters(H)}async release(){return this.handler.dispose()}}}),u2,oZ=E(()=>{iZ(),u2=l2}),s2={};X4(s2,{InferenceSession:()=>f2,TRACE:()=>Y6,TRACE_FUNC_BEGIN:()=>j4,TRACE_FUNC_END:()=>V4,Tensor:()=>d1,TrainingSession:()=>u2,env:()=>i,registerBackend:()=>p4});var z3=E(()=>{OZ(),yZ(),cZ(),J7(),fZ(),lZ(),m2(),uZ(),sZ(),oZ()}),r7,t7,C6,i2,O5,J4,C1,g5,y5,o2,S4,V3=E(()=>{r7=class{log(Q,H,j){}},t7=class{log(Q,H,j){console.log(`${this.color(Q)} ${j?"\x1B[35m"+j+"\x1B[0m ":""}${H}`)}color(Q){switch(Q){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${Q}`)}}},C6={verbose:1000,info:2000,warning:4000,error:5000,fatal:6000},i2={none:new r7,console:new t7},O5={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1},J4={"":O5},((Q)=>{function H(J,X){Q("verbose",J,X)}Q.verbose=H;function j(J,X){Q("info",J,X)}Q.info=j;function K(J,X){Q("warning",J,X)}Q.warning=K;function W(J,X){Q("error",J,X)}Q.error=W;function U(J,X){Q("fatal",J,X)}Q.fatal=U;function Z(J){J4={},q("",J||{})}Q.reset=Z;function q(J,X){if(J==="*")Z(X);else{let V=J4[J]||O5;J4[J]={provider:X.provider||V.provider,minimalSeverity:X.minimalSeverity||V.minimalSeverity,logDateTime:X.logDateTime===void 0?V.logDateTime:X.logDateTime,logSourceLocation:X.logSourceLocation===void 0?V.logSourceLocation:X.logSourceLocation}}}Q.set=q;function G(J){let X={};J.logLevel&&(X.minimalSeverity=J.logLevel),q("",X)}Q.setWithEnv=G})(s3||={}),C1=s3,g5=class{constructor(Q,H,j,K,W,U){this.category=Q,this.name=H,this.startTime=j,this.endCallback=K,this.timer=W,this.ctx=U}async end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}},y5=class{constructor(Q,H,j,K){this.category=Q,this.name=H,this.startTime=j,this.endTime=K}},o2=class{constructor(Q,H,j){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=Q===void 0?1e4:Q,this._flushBatchSize=H===void 0?10:H,this._flushIntervalInMilliseconds=j===void 0?5000:j}static create(Q){return Q===void 0?new this:new this(Q.maxNumberEvents,Q.flushBatchSize,Q.flushIntervalInMilliseconds)}start(){this._started=!0,this._timingEvents=[],this._flushTime=S4(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(Q,H,j,K){let W=this._started?this.begin(Q,H,K):void 0,U=!1,Z=j();if(Z&&typeof Z.then=="function")return U=!0,new Promise((q,G)=>{Z.then(async(J)=>{W&&await W.end(),q(J)},async(J)=>{W&&await W.end(),G(J)})});if(!U&&W){let q=W.end();if(q&&typeof q.then=="function")return new Promise((G,J)=>{q.then(()=>{G(Z)},(X)=>{J(X)})})}return Z}begin(Q,H,j){if(!this._started)throw new Error("profiler is not started yet");if(j===void 0){let K=S4();return this.flush(K),new g5(Q,H,K,(W)=>this.endSync(W))}else{let K=j.beginTimer();return new g5(Q,H,0,async(W)=>this.end(W),K,j)}}async end(Q){let H=await Q.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new y5(Q.category,Q.name,Q.startTime,H)),this.flush(H))}endSync(Q){let H=S4();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new y5(Q.category,Q.name,Q.startTime,H)),this.flush(H))}logOneEvent(Q){C1.verbose(`Profiler.${Q.category}`,`${(Q.endTime-Q.startTime).toFixed(2)}ms on event '${Q.name}' at ${Q.endTime.toFixed(2)}`)}flush(Q){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||Q-this._flushTime>=this._flushIntervalInMilliseconds){for(let H=this._flushPointer;this._flushPointer<H+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=S4()}}get started(){return this._started}},S4=typeof performance<"u"&&performance.now?()=>performance.now():Date.now}),aZ=E(()=>{}),nZ=U1((Q)=>{Q.__esModule=!0;var H=function(){function j(K){if(!K)throw new TypeError("Invalid argument; `value` has no value.");this.value=j.EMPTY,K&&j.isGuid(K)&&(this.value=K)}return j.isGuid=function(K){var W=K.toString();return K&&(K instanceof j||j.validator.test(W))},j.create=function(){return new j([j.gen(2),j.gen(1),j.gen(1),j.gen(1),j.gen(3)].join("-"))},j.createEmpty=function(){return new j("emptyguid")},j.parse=function(K){return new j(K)},j.raw=function(){return[j.gen(2),j.gen(1),j.gen(1),j.gen(1),j.gen(3)].join("-")},j.gen=function(K){for(var W="",U=0;U<K;U++)W+=((1+Math.random())*65536|0).toString(16).substring(1);return W},j.prototype.equals=function(K){return j.isGuid(K)&&this.value===K.toString()},j.prototype.isEmpty=function(){return this.value===j.EMPTY},j.prototype.toString=function(){return this.value},j.prototype.toJSON=function(){return{value:this.value}},j.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),j.EMPTY="00000000-0000-0000-0000-000000000000",j}();Q.Guid=H}),l1,B6,F6,O4,d5,e7,o3,k6,A6,p5,t1,W3,m3,h5,j5,S6,$6,y1,O,_3,a2=E(()=>{l1=null;try{l1=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}X1.prototype.__isLong__,Object.defineProperty(X1.prototype,"__isLong__",{value:!0}),X1.isLong=I1,B6={},F6={},X1.fromInt=b3,X1.fromNumber=e1,X1.fromBits=e,O4=Math.pow,X1.fromString=a6,X1.fromValue=Z3,d5=65536,e7=1<<24,o3=d5*d5,k6=o3*o3,A6=k6/2,p5=b3(e7),t1=b3(0),X1.ZERO=t1,W3=b3(0,!0),X1.UZERO=W3,m3=b3(1),X1.ONE=m3,h5=b3(1,!0),X1.UONE=h5,j5=b3(-1),X1.NEG_ONE=j5,S6=e(-1,2147483647,!1),X1.MAX_VALUE=S6,$6=e(-1,-1,!0),X1.MAX_UNSIGNED_VALUE=$6,y1=e(0,-2147483648,!1),X1.MIN_VALUE=y1,O=X1.prototype,O.toInt=function(){return this.unsigned?this.low>>>0:this.low},O.toNumber=function(){return this.unsigned?(this.high>>>0)*o3+(this.low>>>0):this.high*o3+(this.low>>>0)},O.toString=function(Q){if(Q=Q||10,Q<2||36<Q)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(y1)){var H=e1(Q),j=this.div(H),K=j.mul(H).sub(this);return j.toString(Q)+K.toInt().toString(Q)}else return"-"+this.neg().toString(Q);for(var W=e1(O4(Q,6),this.unsigned),U=this,Z="";;){var q=U.div(W),G=U.sub(q.mul(W)).toInt()>>>0,J=G.toString(Q);if(U=q,U.isZero())return J+Z;for(;J.length<6;)J="0"+J;Z=""+J+Z}},O.getHighBits=function(){return this.high},O.getHighBitsUnsigned=function(){return this.high>>>0},O.getLowBits=function(){return this.low},O.getLowBitsUnsigned=function(){return this.low>>>0},O.getNumBitsAbs=function(){if(this.isNegative())return this.eq(y1)?64:this.neg().getNumBitsAbs();for(var Q=this.high!=0?this.high:this.low,H=31;H>0&&!(Q&1<<H);H--);return this.high!=0?H+33:H+1},O.isZero=function(){return this.high===0&&this.low===0},O.eqz=O.isZero,O.isNegative=function(){return!this.unsigned&&this.high<0},O.isPositive=function(){return this.unsigned||this.high>=0},O.isOdd=function(){return(this.low&1)===1},O.isEven=function(){return(this.low&1)===0},O.equals=function(Q){return I1(Q)||(Q=Z3(Q)),this.unsigned!==Q.unsigned&&this.high>>>31===1&&Q.high>>>31===1?!1:this.high===Q.high&&this.low===Q.low},O.eq=O.equals,O.notEquals=function(Q){return!this.eq(Q)},O.neq=O.notEquals,O.ne=O.notEquals,O.lessThan=function(Q){return this.comp(Q)<0},O.lt=O.lessThan,O.lessThanOrEqual=function(Q){return this.comp(Q)<=0},O.lte=O.lessThanOrEqual,O.le=O.lessThanOrEqual,O.greaterThan=function(Q){return this.comp(Q)>0},O.gt=O.greaterThan,O.greaterThanOrEqual=function(Q){return this.comp(Q)>=0},O.gte=O.greaterThanOrEqual,O.ge=O.greaterThanOrEqual,O.compare=function(Q){if(I1(Q)||(Q=Z3(Q)),this.eq(Q))return 0;var H=this.isNegative(),j=Q.isNegative();return H&&!j?-1:!H&&j?1:this.unsigned?Q.high>>>0>this.high>>>0||Q.high===this.high&&Q.low>>>0>this.low>>>0?-1:1:this.sub(Q).isNegative()?-1:1},O.comp=O.compare,O.negate=function(){return!this.unsigned&&this.eq(y1)?y1:this.not().add(m3)},O.neg=O.negate,O.add=function(Q){I1(Q)||(Q=Z3(Q));var H=this.high>>>16,j=this.high&65535,K=this.low>>>16,W=this.low&65535,U=Q.high>>>16,Z=Q.high&65535,q=Q.low>>>16,G=Q.low&65535,J=0,X=0,V=0,R=0;return R+=W+G,V+=R>>>16,R&=65535,V+=K+q,X+=V>>>16,V&=65535,X+=j+Z,J+=X>>>16,X&=65535,J+=H+U,J&=65535,e(V<<16|R,J<<16|X,this.unsigned)},O.subtract=function(Q){return I1(Q)||(Q=Z3(Q)),this.add(Q.neg())},O.sub=O.subtract,O.multiply=function(Q){if(this.isZero())return this;if(I1(Q)||(Q=Z3(Q)),l1){var H=l1.mul(this.low,this.high,Q.low,Q.high);return e(H,l1.get_high(),this.unsigned)}if(Q.isZero())return this.unsigned?W3:t1;if(this.eq(y1))return Q.isOdd()?y1:t1;if(Q.eq(y1))return this.isOdd()?y1:t1;if(this.isNegative())return Q.isNegative()?this.neg().mul(Q.neg()):this.neg().mul(Q).neg();if(Q.isNegative())return this.mul(Q.neg()).neg();if(this.lt(p5)&&Q.lt(p5))return e1(this.toNumber()*Q.toNumber(),this.unsigned);var j=this.high>>>16,K=this.high&65535,W=this.low>>>16,U=this.low&65535,Z=Q.high>>>16,q=Q.high&65535,G=Q.low>>>16,J=Q.low&65535,X=0,V=0,R=0,z=0;return z+=U*J,R+=z>>>16,z&=65535,R+=W*J,V+=R>>>16,R&=65535,R+=U*G,V+=R>>>16,R&=65535,V+=K*J,X+=V>>>16,V&=65535,V+=W*G,X+=V>>>16,V&=65535,V+=U*q,X+=V>>>16,V&=65535,X+=j*J+K*G+W*q+U*Z,X&=65535,e(R<<16|z,X<<16|V,this.unsigned)},O.mul=O.multiply,O.divide=function(Q){if(I1(Q)||(Q=Z3(Q)),Q.isZero())throw Error("division by zero");if(l1){if(!this.unsigned&&this.high===-2147483648&&Q.low===-1&&Q.high===-1)return this;var H=(this.unsigned?l1.div_u:l1.div_s)(this.low,this.high,Q.low,Q.high);return e(H,l1.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?W3:t1;var j,K,W;if(this.unsigned){if(Q.unsigned||(Q=Q.toUnsigned()),Q.gt(this))return W3;if(Q.gt(this.shru(1)))return h5;W=W3}else{if(this.eq(y1)){if(Q.eq(m3)||Q.eq(j5))return y1;if(Q.eq(y1))return m3;var U=this.shr(1);return j=U.div(Q).shl(1),j.eq(t1)?Q.isNegative()?m3:j5:(K=this.sub(Q.mul(j)),W=j.add(K.div(Q)),W)}else if(Q.eq(y1))return this.unsigned?W3:t1;if(this.isNegative())return Q.isNegative()?this.neg().div(Q.neg()):this.neg().div(Q).neg();if(Q.isNegative())return this.div(Q.neg()).neg();W=t1}for(K=this;K.gte(Q);){j=Math.max(1,Math.floor(K.toNumber()/Q.toNumber()));for(var Z=Math.ceil(Math.log(j)/Math.LN2),q=Z<=48?1:O4(2,Z-48),G=e1(j),J=G.mul(Q);J.isNegative()||J.gt(K);)j-=q,G=e1(j,this.unsigned),J=G.mul(Q);G.isZero()&&(G=m3),W=W.add(G),K=K.sub(J)}return W},O.div=O.divide,O.modulo=function(Q){if(I1(Q)||(Q=Z3(Q)),l1){var H=(this.unsigned?l1.rem_u:l1.rem_s)(this.low,this.high,Q.low,Q.high);return e(H,l1.get_high(),this.unsigned)}return this.sub(this.div(Q).mul(Q))},O.mod=O.modulo,O.rem=O.modulo,O.not=function(){return e(~this.low,~this.high,this.unsigned)},O.countLeadingZeros=function(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32},O.clz=O.countLeadingZeros,O.countTrailingZeros=function(){return this.low?c7(this.low):c7(this.high)+32},O.ctz=O.countTrailingZeros,O.and=function(Q){return I1(Q)||(Q=Z3(Q)),e(this.low&Q.low,this.high&Q.high,this.unsigned)},O.or=function(Q){return I1(Q)||(Q=Z3(Q)),e(this.low|Q.low,this.high|Q.high,this.unsigned)},O.xor=function(Q){return I1(Q)||(Q=Z3(Q)),e(this.low^Q.low,this.high^Q.high,this.unsigned)},O.shiftLeft=function(Q){return I1(Q)&&(Q=Q.toInt()),(Q&=63)===0?this:Q<32?e(this.low<<Q,this.high<<Q|this.low>>>32-Q,this.unsigned):e(0,this.low<<Q-32,this.unsigned)},O.shl=O.shiftLeft,O.shiftRight=function(Q){return I1(Q)&&(Q=Q.toInt()),(Q&=63)===0?this:Q<32?e(this.low>>>Q|this.high<<32-Q,this.high>>Q,this.unsigned):e(this.high>>Q-32,this.high>=0?0:-1,this.unsigned)},O.shr=O.shiftRight,O.shiftRightUnsigned=function(Q){return I1(Q)&&(Q=Q.toInt()),(Q&=63)===0?this:Q<32?e(this.low>>>Q|this.high<<32-Q,this.high>>>Q,this.unsigned):Q===32?e(this.high,0,this.unsigned):e(this.high>>>Q-32,0,this.unsigned)},O.shru=O.shiftRightUnsigned,O.shr_u=O.shiftRightUnsigned,O.rotateLeft=function(Q){var H;return I1(Q)&&(Q=Q.toInt()),(Q&=63)===0?this:Q===32?e(this.high,this.low,this.unsigned):Q<32?(H=32-Q,e(this.low<<Q|this.high>>>H,this.high<<Q|this.low>>>H,this.unsigned)):(Q-=32,H=32-Q,e(this.high<<Q|this.low>>>H,this.low<<Q|this.high>>>H,this.unsigned))},O.rotl=O.rotateLeft,O.rotateRight=function(Q){var H;return I1(Q)&&(Q=Q.toInt()),(Q&=63)===0?this:Q===32?e(this.high,this.low,this.unsigned):Q<32?(H=32-Q,e(this.high<<H|this.low>>>Q,this.low<<H|this.high>>>Q,this.unsigned)):(Q-=32,H=32-Q,e(this.low<<H|this.high>>>Q,this.high<<H|this.low>>>Q,this.unsigned))},O.rotr=O.rotateRight,O.toSigned=function(){return this.unsigned?e(this.low,this.high,!1):this},O.toUnsigned=function(){return this.unsigned?this:e(this.low,this.high,!0)},O.toBytes=function(Q){return Q?this.toBytesLE():this.toBytesBE()},O.toBytesLE=function(){var Q=this.high,H=this.low;return[H&255,H>>>8&255,H>>>16&255,H>>>24,Q&255,Q>>>8&255,Q>>>16&255,Q>>>24]},O.toBytesBE=function(){var Q=this.high,H=this.low;return[Q>>>24,Q>>>16&255,Q>>>8&255,Q&255,H>>>24,H>>>16&255,H>>>8&255,H&255]},X1.fromBytes=function(Q,H,j){return j?X1.fromBytesLE(Q,H):X1.fromBytesBE(Q,H)},X1.fromBytesLE=function(Q,H){return new X1(Q[0]|Q[1]<<8|Q[2]<<16|Q[3]<<24,Q[4]|Q[5]<<8|Q[6]<<16|Q[7]<<24,H)},X1.fromBytesBE=function(Q,H){return new X1(Q[4]<<24|Q[5]<<16|Q[6]<<8|Q[7],Q[0]<<24|Q[1]<<16|Q[2]<<8|Q[3],H)},_3=X1}),$,H7=E(()=>{$={},$.Offset,$.Table,$.SIZEOF_SHORT=2,$.SIZEOF_INT=4,$.FILE_IDENTIFIER_LENGTH=4,$.SIZE_PREFIX_LENGTH=4,$.Encoding={UTF8_BYTES:1,UTF16_STRING:2},$.int32=new Int32Array(2),$.float32=new Float32Array($.int32.buffer),$.float64=new Float64Array($.int32.buffer),$.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1,$.Long=function(Q,H){this.low=Q|0,this.high=H|0},$.Long.create=function(Q,H){return Q==0&&H==0?$.Long.ZERO:new $.Long(Q,H)},$.Long.prototype.toFloat64=function(){return(this.low>>>0)+this.high*4294967296},$.Long.prototype.equals=function(Q){return this.low==Q.low&&this.high==Q.high},$.Long.ZERO=new $.Long(0,0),$.Builder=function(Q){if(Q)var H=Q;else var H=1024;this.bb=$.ByteBuffer.allocate(H),this.space=H,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},$.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},$.Builder.prototype.forceDefaults=function(Q){this.force_defaults=Q},$.Builder.prototype.dataBuffer=function(){return this.bb},$.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},$.Builder.prototype.prep=function(Q,H){Q>this.minalign&&(this.minalign=Q);for(var j=~(this.bb.capacity()-this.space+H)+1&Q-1;this.space<j+Q+H;){var K=this.bb.capacity();this.bb=$.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-K}this.pad(j)},$.Builder.prototype.pad=function(Q){for(var H=0;H<Q;H++)this.bb.writeInt8(--this.space,0)},$.Builder.prototype.writeInt8=function(Q){this.bb.writeInt8(this.space-=1,Q)},$.Builder.prototype.writeInt16=function(Q){this.bb.writeInt16(this.space-=2,Q)},$.Builder.prototype.writeInt32=function(Q){this.bb.writeInt32(this.space-=4,Q)},$.Builder.prototype.writeInt64=function(Q){this.bb.writeInt64(this.space-=8,Q)},$.Builder.prototype.writeFloat32=function(Q){this.bb.writeFloat32(this.space-=4,Q)},$.Builder.prototype.writeFloat64=function(Q){this.bb.writeFloat64(this.space-=8,Q)},$.Builder.prototype.addInt8=function(Q){this.prep(1,0),this.writeInt8(Q)},$.Builder.prototype.addInt16=function(Q){this.prep(2,0),this.writeInt16(Q)},$.Builder.prototype.addInt32=function(Q){this.prep(4,0),this.writeInt32(Q)},$.Builder.prototype.addInt64=function(Q){this.prep(8,0),this.writeInt64(Q)},$.Builder.prototype.addFloat32=function(Q){this.prep(4,0),this.writeFloat32(Q)},$.Builder.prototype.addFloat64=function(Q){this.prep(8,0),this.writeFloat64(Q)},$.Builder.prototype.addFieldInt8=function(Q,H,j){(this.force_defaults||H!=j)&&(this.addInt8(H),this.slot(Q))},$.Builder.prototype.addFieldInt16=function(Q,H,j){(this.force_defaults||H!=j)&&(this.addInt16(H),this.slot(Q))},$.Builder.prototype.addFieldInt32=function(Q,H,j){(this.force_defaults||H!=j)&&(this.addInt32(H),this.slot(Q))},$.Builder.prototype.addFieldInt64=function(Q,H,j){(this.force_defaults||!H.equals(j))&&(this.addInt64(H),this.slot(Q))},$.Builder.prototype.addFieldFloat32=function(Q,H,j){(this.force_defaults||H!=j)&&(this.addFloat32(H),this.slot(Q))},$.Builder.prototype.addFieldFloat64=function(Q,H,j){(this.force_defaults||H!=j)&&(this.addFloat64(H),this.slot(Q))},$.Builder.prototype.addFieldOffset=function(Q,H,j){(this.force_defaults||H!=j)&&(this.addOffset(H),this.slot(Q))},$.Builder.prototype.addFieldStruct=function(Q,H,j){H!=j&&(this.nested(H),this.slot(Q))},$.Builder.prototype.nested=function(Q){if(Q!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},$.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},$.Builder.prototype.slot=function(Q){this.vtable[Q]=this.offset()},$.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},$.Builder.growByteBuffer=function(Q){var H=Q.capacity();if(H&3221225472)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var j=H<<1,K=$.ByteBuffer.allocate(j);return K.setPosition(j-H),K.bytes().set(Q.bytes(),j-H),K},$.Builder.prototype.addOffset=function(Q){this.prep($.SIZEOF_INT,0),this.writeInt32(this.offset()-Q+$.SIZEOF_INT)},$.Builder.prototype.startObject=function(Q){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=Q;for(var H=0;H<Q;H++)this.vtable[H]=0;this.isNested=!0,this.object_start=this.offset()},$.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var Q=this.offset(),H=this.vtable_in_use-1;H>=0&&this.vtable[H]==0;H--);for(var j=H+1;H>=0;H--)this.addInt16(this.vtable[H]!=0?Q-this.vtable[H]:0);var K=2;this.addInt16(Q-this.object_start);var W=(j+K)*$.SIZEOF_SHORT;this.addInt16(W);var U=0,Z=this.space;Q:for(H=0;H<this.vtables.length;H++){var q=this.bb.capacity()-this.vtables[H];if(W==this.bb.readInt16(q)){for(var G=$.SIZEOF_SHORT;G<W;G+=$.SIZEOF_SHORT)if(this.bb.readInt16(Z+G)!=this.bb.readInt16(q+G))continue Q;U=this.vtables[H];break}}return U?(this.space=this.bb.capacity()-Q,this.bb.writeInt32(this.space,U-Q)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-Q,this.offset()-Q)),this.isNested=!1,Q},$.Builder.prototype.finish=function(Q,H,j){var K=j?$.SIZE_PREFIX_LENGTH:0;if(H){var W=H;if(this.prep(this.minalign,$.SIZEOF_INT+$.FILE_IDENTIFIER_LENGTH+K),W.length!=$.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+$.FILE_IDENTIFIER_LENGTH);for(var U=$.FILE_IDENTIFIER_LENGTH-1;U>=0;U--)this.writeInt8(W.charCodeAt(U))}this.prep(this.minalign,$.SIZEOF_INT+K),this.addOffset(Q),K&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},$.Builder.prototype.finishSizePrefixed=function(Q,H){this.finish(Q,H,!0)},$.Builder.prototype.requiredField=function(Q,H){var j=this.bb.capacity()-Q,K=j-this.bb.readInt32(j),W=this.bb.readInt16(K+H)!=0;if(!W)throw new Error("FlatBuffers: field "+H+" must be set")},$.Builder.prototype.startVector=function(Q,H,j){this.notNested(),this.vector_num_elems=H,this.prep($.SIZEOF_INT,Q*H),this.prep(j,Q*H)},$.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},$.Builder.prototype.createString=function(Q){if(Q instanceof Uint8Array)var H=Q;else for(var H=[],j=0;j<Q.length;){var K,W=Q.charCodeAt(j++);if(W<55296||W>=56320)K=W;else{var U=Q.charCodeAt(j++);K=(W<<10)+U+-56613888}K<128?H.push(K):(K<2048?H.push(K>>6&31|192):(K<65536?H.push(K>>12&15|224):H.push(K>>18&7|240,K>>12&63|128),H.push(K>>6&63|128)),H.push(K&63|128))}this.addInt8(0),this.startVector(1,H.length,1),this.bb.setPosition(this.space-=H.length);for(var j=0,Z=this.space,q=this.bb.bytes();j<H.length;j++)q[Z++]=H[j];return this.endVector()},$.Builder.prototype.createLong=function(Q,H){return $.Long.create(Q,H)},$.ByteBuffer=function(Q){this.bytes_=Q,this.position_=0},$.ByteBuffer.allocate=function(Q){return new $.ByteBuffer(new Uint8Array(Q))},$.ByteBuffer.prototype.clear=function(){this.position_=0},$.ByteBuffer.prototype.bytes=function(){return this.bytes_},$.ByteBuffer.prototype.position=function(){return this.position_},$.ByteBuffer.prototype.setPosition=function(Q){this.position_=Q},$.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},$.ByteBuffer.prototype.readInt8=function(Q){return this.readUint8(Q)<<24>>24},$.ByteBuffer.prototype.readUint8=function(Q){return this.bytes_[Q]},$.ByteBuffer.prototype.readInt16=function(Q){return this.readUint16(Q)<<16>>16},$.ByteBuffer.prototype.readUint16=function(Q){return this.bytes_[Q]|this.bytes_[Q+1]<<8},$.ByteBuffer.prototype.readInt32=function(Q){return this.bytes_[Q]|this.bytes_[Q+1]<<8|this.bytes_[Q+2]<<16|this.bytes_[Q+3]<<24},$.ByteBuffer.prototype.readUint32=function(Q){return this.readInt32(Q)>>>0},$.ByteBuffer.prototype.readInt64=function(Q){return new $.Long(this.readInt32(Q),this.readInt32(Q+4))},$.ByteBuffer.prototype.readUint64=function(Q){return new $.Long(this.readUint32(Q),this.readUint32(Q+4))},$.ByteBuffer.prototype.readFloat32=function(Q){return $.int32[0]=this.readInt32(Q),$.float32[0]},$.ByteBuffer.prototype.readFloat64=function(Q){return $.int32[$.isLittleEndian?0:1]=this.readInt32(Q),$.int32[$.isLittleEndian?1:0]=this.readInt32(Q+4),$.float64[0]},$.ByteBuffer.prototype.writeInt8=function(Q,H){this.bytes_[Q]=H},$.ByteBuffer.prototype.writeUint8=function(Q,H){this.bytes_[Q]=H},$.ByteBuffer.prototype.writeInt16=function(Q,H){this.bytes_[Q]=H,this.bytes_[Q+1]=H>>8},$.ByteBuffer.prototype.writeUint16=function(Q,H){this.bytes_[Q]=H,this.bytes_[Q+1]=H>>8},$.ByteBuffer.prototype.writeInt32=function(Q,H){this.bytes_[Q]=H,this.bytes_[Q+1]=H>>8,this.bytes_[Q+2]=H>>16,this.bytes_[Q+3]=H>>24},$.ByteBuffer.prototype.writeUint32=function(Q,H){this.bytes_[Q]=H,this.bytes_[Q+1]=H>>8,this.bytes_[Q+2]=H>>16,this.bytes_[Q+3]=H>>24},$.ByteBuffer.prototype.writeInt64=function(Q,H){this.writeInt32(Q,H.low),this.writeInt32(Q+4,H.high)},$.ByteBuffer.prototype.writeUint64=function(Q,H){this.writeUint32(Q,H.low),this.writeUint32(Q+4,H.high)},$.ByteBuffer.prototype.writeFloat32=function(Q,H){$.float32[0]=H,this.writeInt32(Q,$.int32[0])},$.ByteBuffer.prototype.writeFloat64=function(Q,H){$.float64[0]=H,this.writeInt32(Q,$.int32[$.isLittleEndian?0:1]),this.writeInt32(Q+4,$.int32[$.isLittleEndian?1:0])},$.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+$.SIZEOF_INT+$.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var Q="",H=0;H<$.FILE_IDENTIFIER_LENGTH;H++)Q+=String.fromCharCode(this.readInt8(this.position_+$.SIZEOF_INT+H));return Q},$.ByteBuffer.prototype.__offset=function(Q,H){var j=Q-this.readInt32(Q);return H<this.readInt16(j)?this.readInt16(j+H):0},$.ByteBuffer.prototype.__union=function(Q,H){return Q.bb_pos=H+this.readInt32(H),Q.bb=this,Q},$.ByteBuffer.prototype.__string=function(Q,H){Q+=this.readInt32(Q);var j=this.readInt32(Q),K="",W=0;if(Q+=$.SIZEOF_INT,H===$.Encoding.UTF8_BYTES)return this.bytes_.subarray(Q,Q+j);for(;W<j;){var U,Z=this.readUint8(Q+W++);if(Z<192)U=Z;else{var q=this.readUint8(Q+W++);if(Z<224)U=(Z&31)<<6|q&63;else{var G=this.readUint8(Q+W++);if(Z<240)U=(Z&15)<<12|(q&63)<<6|G&63;else{var J=this.readUint8(Q+W++);U=(Z&7)<<18|(q&63)<<12|(G&63)<<6|J&63}}}U<65536?K+=String.fromCharCode(U):(U-=65536,K+=String.fromCharCode((U>>10)+55296,(U&1023)+56320))}return K},$.ByteBuffer.prototype.__indirect=function(Q){return Q+this.readInt32(Q)},$.ByteBuffer.prototype.__vector=function(Q){return Q+this.readInt32(Q)+$.SIZEOF_INT},$.ByteBuffer.prototype.__vector_len=function(Q){return this.readInt32(Q+this.readInt32(Q))},$.ByteBuffer.prototype.__has_identifier=function(Q){if(Q.length!=$.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+$.FILE_IDENTIFIER_LENGTH);for(var H=0;H<$.FILE_IDENTIFIER_LENGTH;H++)if(Q.charCodeAt(H)!=this.readInt8(this.position_+$.SIZEOF_INT+H))return!1;return!0},$.ByteBuffer.prototype.createLong=function(Q,H){return $.Long.create(Q,H)}}),H1,B5=E(()=>{H7(),((Q)=>{let H;((j)=>{let K;((W)=>{let U;((Z)=>(Z[Z.UNDEFINED=0]="UNDEFINED",Z[Z.FLOAT=1]="FLOAT",Z[Z.INT=2]="INT",Z[Z.STRING=3]="STRING",Z[Z.TENSOR=4]="TENSOR",Z[Z.GRAPH=5]="GRAPH",Z[Z.FLOATS=6]="FLOATS",Z[Z.INTS=7]="INTS",Z[Z.STRINGS=8]="STRINGS",Z[Z.TENSORS=9]="TENSORS",Z[Z.GRAPHS=10]="GRAPHS",Z[Z.SPARSE_TENSOR=11]="SPARSE_TENSOR",Z[Z.SPARSE_TENSORS=12]="SPARSE_TENSORS"))(U=W.AttributeType||={})})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{let U;((Z)=>(Z[Z.UNKNOWN=0]="UNKNOWN",Z[Z.VALUE=1]="VALUE",Z[Z.PARAM=2]="PARAM"))(U=W.DimensionValueType||={})})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{let U;((Z)=>(Z[Z.UNDEFINED=0]="UNDEFINED",Z[Z.FLOAT=1]="FLOAT",Z[Z.UINT8=2]="UINT8",Z[Z.INT8=3]="INT8",Z[Z.UINT16=4]="UINT16",Z[Z.INT16=5]="INT16",Z[Z.INT32=6]="INT32",Z[Z.INT64=7]="INT64",Z[Z.STRING=8]="STRING",Z[Z.BOOL=9]="BOOL",Z[Z.FLOAT16=10]="FLOAT16",Z[Z.DOUBLE=11]="DOUBLE",Z[Z.UINT32=12]="UINT32",Z[Z.UINT64=13]="UINT64",Z[Z.COMPLEX64=14]="COMPLEX64",Z[Z.COMPLEX128=15]="COMPLEX128",Z[Z.BFLOAT16=16]="BFLOAT16",Z[Z.FLOAT8E4M3FN=17]="FLOAT8E4M3FN",Z[Z.FLOAT8E4M3FNUZ=18]="FLOAT8E4M3FNUZ",Z[Z.FLOAT8E5M2=19]="FLOAT8E5M2",Z[Z.FLOAT8E5M2FNUZ=20]="FLOAT8E5M2FNUZ"))(U=W.TensorDataType||={})})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{let U;((Z)=>(Z[Z.Primitive=0]="Primitive",Z[Z.Fused=1]="Fused"))(U=W.NodeType||={})})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{let U;((Z)=>(Z[Z.NONE=0]="NONE",Z[Z.tensor_type=1]="tensor_type",Z[Z.sequence_type=2]="sequence_type",Z[Z.map_type=3]="map_type"))(U=W.TypeInfoValue||={})})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{class U{constructor(){this.bb=null,this.bb_pos=0}__init(Z,q){return this.bb_pos=Z,this.bb=q,this}static getRootAsShape(Z,q){return(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}static getSizePrefixedRootAsShape(Z,q){return Z.setPosition(Z.position()+$.SIZE_PREFIX_LENGTH),(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}dim(Z,q){let G=this.bb.__offset(this.bb_pos,4);return G?(q||new Q.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+G)+Z*4),this.bb):null}dimLength(){let Z=this.bb.__offset(this.bb_pos,4);return Z?this.bb.__vector_len(this.bb_pos+Z):0}static startShape(Z){Z.startObject(1)}static addDim(Z,q){Z.addFieldOffset(0,q,0)}static createDimVector(Z,q){Z.startVector(4,q.length,4);for(let G=q.length-1;G>=0;G--)Z.addOffset(q[G]);return Z.endVector()}static startDimVector(Z,q){Z.startVector(4,q,4)}static endShape(Z){return Z.endObject()}static createShape(Z,q){return U.startShape(Z),U.addDim(Z,q),U.endShape(Z)}}W.Shape=U})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{class U{constructor(){this.bb=null,this.bb_pos=0}__init(Z,q){return this.bb_pos=Z,this.bb=q,this}static getRootAsDimension(Z,q){return(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}static getSizePrefixedRootAsDimension(Z,q){return Z.setPosition(Z.position()+$.SIZE_PREFIX_LENGTH),(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}value(Z){let q=this.bb.__offset(this.bb_pos,4);return q?(Z||new Q.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+q),this.bb):null}denotation(Z){let q=this.bb.__offset(this.bb_pos,6);return q?this.bb.__string(this.bb_pos+q,Z):null}static startDimension(Z){Z.startObject(2)}static addValue(Z,q){Z.addFieldOffset(0,q,0)}static addDenotation(Z,q){Z.addFieldOffset(1,q,0)}static endDimension(Z){return Z.endObject()}static createDimension(Z,q,G){return U.startDimension(Z),U.addValue(Z,q),U.addDenotation(Z,G),U.endDimension(Z)}}W.Dimension=U})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{class U{constructor(){this.bb=null,this.bb_pos=0}__init(Z,q){return this.bb_pos=Z,this.bb=q,this}static getRootAsDimensionValue(Z,q){return(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}static getSizePrefixedRootAsDimensionValue(Z,q){return Z.setPosition(Z.position()+$.SIZE_PREFIX_LENGTH),(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}dimType(){let Z=this.bb.__offset(this.bb_pos,4);return Z?this.bb.readInt8(this.bb_pos+Z):0}dimValue(){let Z=this.bb.__offset(this.bb_pos,6);return Z?this.bb.readInt64(this.bb_pos+Z):this.bb.createLong(0,0)}dimParam(Z){let q=this.bb.__offset(this.bb_pos,8);return q?this.bb.__string(this.bb_pos+q,Z):null}static startDimensionValue(Z){Z.startObject(3)}static addDimType(Z,q){Z.addFieldInt8(0,q,0)}static addDimValue(Z,q){Z.addFieldInt64(1,q,Z.createLong(0,0))}static addDimParam(Z,q){Z.addFieldOffset(2,q,0)}static endDimensionValue(Z){return Z.endObject()}static createDimensionValue(Z,q,G,J){return U.startDimensionValue(Z),U.addDimType(Z,q),U.addDimValue(Z,G),U.addDimParam(Z,J),U.endDimensionValue(Z)}}W.DimensionValue=U})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{class U{constructor(){this.bb=null,this.bb_pos=0}__init(Z,q){return this.bb_pos=Z,this.bb=q,this}static getRootAsTensorTypeAndShape(Z,q){return(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}static getSizePrefixedRootAsTensorTypeAndShape(Z,q){return Z.setPosition(Z.position()+$.SIZE_PREFIX_LENGTH),(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}elemType(){let Z=this.bb.__offset(this.bb_pos,4);return Z?this.bb.readInt32(this.bb_pos+Z):0}shape(Z){let q=this.bb.__offset(this.bb_pos,6);return q?(Z||new Q.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+q),this.bb):null}static startTensorTypeAndShape(Z){Z.startObject(2)}static addElemType(Z,q){Z.addFieldInt32(0,q,0)}static addShape(Z,q){Z.addFieldOffset(1,q,0)}static endTensorTypeAndShape(Z){return Z.endObject()}static createTensorTypeAndShape(Z,q,G){return U.startTensorTypeAndShape(Z),U.addElemType(Z,q),U.addShape(Z,G),U.endTensorTypeAndShape(Z)}}W.TensorTypeAndShape=U})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{class U{constructor(){this.bb=null,this.bb_pos=0}__init(Z,q){return this.bb_pos=Z,this.bb=q,this}static getRootAsMapType(Z,q){return(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}static getSizePrefixedRootAsMapType(Z,q){return Z.setPosition(Z.position()+$.SIZE_PREFIX_LENGTH),(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}keyType(){let Z=this.bb.__offset(this.bb_pos,4);return Z?this.bb.readInt32(this.bb_pos+Z):0}valueType(Z){let q=this.bb.__offset(this.bb_pos,6);return q?(Z||new Q.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+q),this.bb):null}static startMapType(Z){Z.startObject(2)}static addKeyType(Z,q){Z.addFieldInt32(0,q,0)}static addValueType(Z,q){Z.addFieldOffset(1,q,0)}static endMapType(Z){return Z.endObject()}static createMapType(Z,q,G){return U.startMapType(Z),U.addKeyType(Z,q),U.addValueType(Z,G),U.endMapType(Z)}}W.MapType=U})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{class U{constructor(){this.bb=null,this.bb_pos=0}__init(Z,q){return this.bb_pos=Z,this.bb=q,this}static getRootAsSequenceType(Z,q){return(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}static getSizePrefixedRootAsSequenceType(Z,q){return Z.setPosition(Z.position()+$.SIZE_PREFIX_LENGTH),(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}elemType(Z){let q=this.bb.__offset(this.bb_pos,4);return q?(Z||new Q.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+q),this.bb):null}static startSequenceType(Z){Z.startObject(1)}static addElemType(Z,q){Z.addFieldOffset(0,q,0)}static endSequenceType(Z){return Z.endObject()}static createSequenceType(Z,q){return U.startSequenceType(Z),U.addElemType(Z,q),U.endSequenceType(Z)}}W.SequenceType=U})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{class U{constructor(){this.bb=null,this.bb_pos=0}__init(Z,q){return this.bb_pos=Z,this.bb=q,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(Z,q,G,J){return Z.prep(4,12),Z.writeInt32(J),Z.writeInt32(G),Z.writeInt32(q),Z.offset()}}W.EdgeEnd=U})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{class U{constructor(){this.bb=null,this.bb_pos=0}__init(Z,q){return this.bb_pos=Z,this.bb=q,this}static getRootAsNodeEdge(Z,q){return(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}static getSizePrefixedRootAsNodeEdge(Z,q){return Z.setPosition(Z.position()+$.SIZE_PREFIX_LENGTH),(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}nodeIndex(){let Z=this.bb.__offset(this.bb_pos,4);return Z?this.bb.readUint32(this.bb_pos+Z):0}inputEdges(Z,q){let G=this.bb.__offset(this.bb_pos,6);return G?(q||new Q.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+G)+Z*12,this.bb):null}inputEdgesLength(){let Z=this.bb.__offset(this.bb_pos,6);return Z?this.bb.__vector_len(this.bb_pos+Z):0}outputEdges(Z,q){let G=this.bb.__offset(this.bb_pos,8);return G?(q||new Q.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+G)+Z*12,this.bb):null}outputEdgesLength(){let Z=this.bb.__offset(this.bb_pos,8);return Z?this.bb.__vector_len(this.bb_pos+Z):0}static startNodeEdge(Z){Z.startObject(3)}static addNodeIndex(Z,q){Z.addFieldInt32(0,q,0)}static addInputEdges(Z,q){Z.addFieldOffset(1,q,0)}static startInputEdgesVector(Z,q){Z.startVector(12,q,4)}static addOutputEdges(Z,q){Z.addFieldOffset(2,q,0)}static startOutputEdgesVector(Z,q){Z.startVector(12,q,4)}static endNodeEdge(Z){return Z.endObject()}static createNodeEdge(Z,q,G,J){return U.startNodeEdge(Z),U.addNodeIndex(Z,q),U.addInputEdges(Z,G),U.addOutputEdges(Z,J),U.endNodeEdge(Z)}}W.NodeEdge=U})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{class U{constructor(){this.bb=null,this.bb_pos=0}__init(Z,q){return this.bb_pos=Z,this.bb=q,this}static getRootAsNode(Z,q){return(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}static getSizePrefixedRootAsNode(Z,q){return Z.setPosition(Z.position()+$.SIZE_PREFIX_LENGTH),(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}name(Z){let q=this.bb.__offset(this.bb_pos,4);return q?this.bb.__string(this.bb_pos+q,Z):null}docString(Z){let q=this.bb.__offset(this.bb_pos,6);return q?this.bb.__string(this.bb_pos+q,Z):null}domain(Z){let q=this.bb.__offset(this.bb_pos,8);return q?this.bb.__string(this.bb_pos+q,Z):null}sinceVersion(){let Z=this.bb.__offset(this.bb_pos,10);return Z?this.bb.readInt32(this.bb_pos+Z):0}index(){let Z=this.bb.__offset(this.bb_pos,12);return Z?this.bb.readUint32(this.bb_pos+Z):0}opType(Z){let q=this.bb.__offset(this.bb_pos,14);return q?this.bb.__string(this.bb_pos+q,Z):null}type(){let Z=this.bb.__offset(this.bb_pos,16);return Z?this.bb.readInt32(this.bb_pos+Z):0}executionProviderType(Z){let q=this.bb.__offset(this.bb_pos,18);return q?this.bb.__string(this.bb_pos+q,Z):null}inputs(Z,q){let G=this.bb.__offset(this.bb_pos,20);return G?this.bb.__string(this.bb.__vector(this.bb_pos+G)+Z*4,q):null}inputsLength(){let Z=this.bb.__offset(this.bb_pos,20);return Z?this.bb.__vector_len(this.bb_pos+Z):0}outputs(Z,q){let G=this.bb.__offset(this.bb_pos,22);return G?this.bb.__string(this.bb.__vector(this.bb_pos+G)+Z*4,q):null}outputsLength(){let Z=this.bb.__offset(this.bb_pos,22);return Z?this.bb.__vector_len(this.bb_pos+Z):0}attributes(Z,q){let G=this.bb.__offset(this.bb_pos,24);return G?(q||new Q.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+G)+Z*4),this.bb):null}attributesLength(){let Z=this.bb.__offset(this.bb_pos,24);return Z?this.bb.__vector_len(this.bb_pos+Z):0}inputArgCounts(Z){let q=this.bb.__offset(this.bb_pos,26);return q?this.bb.readInt32(this.bb.__vector(this.bb_pos+q)+Z*4):0}inputArgCountsLength(){let Z=this.bb.__offset(this.bb_pos,26);return Z?this.bb.__vector_len(this.bb_pos+Z):0}inputArgCountsArray(){let Z=this.bb.__offset(this.bb_pos,26);return Z?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+Z),this.bb.__vector_len(this.bb_pos+Z)):null}implicitInputs(Z,q){let G=this.bb.__offset(this.bb_pos,28);return G?this.bb.__string(this.bb.__vector(this.bb_pos+G)+Z*4,q):null}implicitInputsLength(){let Z=this.bb.__offset(this.bb_pos,28);return Z?this.bb.__vector_len(this.bb_pos+Z):0}static startNode(Z){Z.startObject(13)}static addName(Z,q){Z.addFieldOffset(0,q,0)}static addDocString(Z,q){Z.addFieldOffset(1,q,0)}static addDomain(Z,q){Z.addFieldOffset(2,q,0)}static addSinceVersion(Z,q){Z.addFieldInt32(3,q,0)}static addIndex(Z,q){Z.addFieldInt32(4,q,0)}static addOpType(Z,q){Z.addFieldOffset(5,q,0)}static addType(Z,q){Z.addFieldInt32(6,q,0)}static addExecutionProviderType(Z,q){Z.addFieldOffset(7,q,0)}static addInputs(Z,q){Z.addFieldOffset(8,q,0)}static createInputsVector(Z,q){Z.startVector(4,q.length,4);for(let G=q.length-1;G>=0;G--)Z.addOffset(q[G]);return Z.endVector()}static startInputsVector(Z,q){Z.startVector(4,q,4)}static addOutputs(Z,q){Z.addFieldOffset(9,q,0)}static createOutputsVector(Z,q){Z.startVector(4,q.length,4);for(let G=q.length-1;G>=0;G--)Z.addOffset(q[G]);return Z.endVector()}static startOutputsVector(Z,q){Z.startVector(4,q,4)}static addAttributes(Z,q){Z.addFieldOffset(10,q,0)}static createAttributesVector(Z,q){Z.startVector(4,q.length,4);for(let G=q.length-1;G>=0;G--)Z.addOffset(q[G]);return Z.endVector()}static startAttributesVector(Z,q){Z.startVector(4,q,4)}static addInputArgCounts(Z,q){Z.addFieldOffset(11,q,0)}static createInputArgCountsVector(Z,q){Z.startVector(4,q.length,4);for(let G=q.length-1;G>=0;G--)Z.addInt32(q[G]);return Z.endVector()}static startInputArgCountsVector(Z,q){Z.startVector(4,q,4)}static addImplicitInputs(Z,q){Z.addFieldOffset(12,q,0)}static createImplicitInputsVector(Z,q){Z.startVector(4,q.length,4);for(let G=q.length-1;G>=0;G--)Z.addOffset(q[G]);return Z.endVector()}static startImplicitInputsVector(Z,q){Z.startVector(4,q,4)}static endNode(Z){return Z.endObject()}static createNode(Z,q,G,J,X,V,R,z,Y,B,k,w,A,D){return U.startNode(Z),U.addName(Z,q),U.addDocString(Z,G),U.addDomain(Z,J),U.addSinceVersion(Z,X),U.addIndex(Z,V),U.addOpType(Z,R),U.addType(Z,z),U.addExecutionProviderType(Z,Y),U.addInputs(Z,B),U.addOutputs(Z,k),U.addAttributes(Z,w),U.addInputArgCounts(Z,A),U.addImplicitInputs(Z,D),U.endNode(Z)}}W.Node=U})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{class U{constructor(){this.bb=null,this.bb_pos=0}__init(Z,q){return this.bb_pos=Z,this.bb=q,this}static getRootAsValueInfo(Z,q){return(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}static getSizePrefixedRootAsValueInfo(Z,q){return Z.setPosition(Z.position()+$.SIZE_PREFIX_LENGTH),(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}name(Z){let q=this.bb.__offset(this.bb_pos,4);return q?this.bb.__string(this.bb_pos+q,Z):null}docString(Z){let q=this.bb.__offset(this.bb_pos,6);return q?this.bb.__string(this.bb_pos+q,Z):null}type(Z){let q=this.bb.__offset(this.bb_pos,8);return q?(Z||new Q.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+q),this.bb):null}static startValueInfo(Z){Z.startObject(3)}static addName(Z,q){Z.addFieldOffset(0,q,0)}static addDocString(Z,q){Z.addFieldOffset(1,q,0)}static addType(Z,q){Z.addFieldOffset(2,q,0)}static endValueInfo(Z){return Z.endObject()}static createValueInfo(Z,q,G,J){return U.startValueInfo(Z),U.addName(Z,q),U.addDocString(Z,G),U.addType(Z,J),U.endValueInfo(Z)}}W.ValueInfo=U})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{class U{constructor(){this.bb=null,this.bb_pos=0}__init(Z,q){return this.bb_pos=Z,this.bb=q,this}static getRootAsTypeInfo(Z,q){return(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}static getSizePrefixedRootAsTypeInfo(Z,q){return Z.setPosition(Z.position()+$.SIZE_PREFIX_LENGTH),(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}denotation(Z){let q=this.bb.__offset(this.bb_pos,4);return q?this.bb.__string(this.bb_pos+q,Z):null}valueType(){let Z=this.bb.__offset(this.bb_pos,6);return Z?this.bb.readUint8(this.bb_pos+Z):0}value(Z){let q=this.bb.__offset(this.bb_pos,8);return q?this.bb.__union(Z,this.bb_pos+q):null}static startTypeInfo(Z){Z.startObject(3)}static addDenotation(Z,q){Z.addFieldOffset(0,q,0)}static addValueType(Z,q){Z.addFieldInt8(1,q,0)}static addValue(Z,q){Z.addFieldOffset(2,q,0)}static endTypeInfo(Z){return Z.endObject()}static createTypeInfo(Z,q,G,J){return U.startTypeInfo(Z),U.addDenotation(Z,q),U.addValueType(Z,G),U.addValue(Z,J),U.endTypeInfo(Z)}}W.TypeInfo=U})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{class U{constructor(){this.bb=null,this.bb_pos=0}__init(Z,q){return this.bb_pos=Z,this.bb=q,this}static getRootAsOperatorSetId(Z,q){return(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}static getSizePrefixedRootAsOperatorSetId(Z,q){return Z.setPosition(Z.position()+$.SIZE_PREFIX_LENGTH),(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}domain(Z){let q=this.bb.__offset(this.bb_pos,4);return q?this.bb.__string(this.bb_pos+q,Z):null}version(){let Z=this.bb.__offset(this.bb_pos,6);return Z?this.bb.readInt64(this.bb_pos+Z):this.bb.createLong(0,0)}static startOperatorSetId(Z){Z.startObject(2)}static addDomain(Z,q){Z.addFieldOffset(0,q,0)}static addVersion(Z,q){Z.addFieldInt64(1,q,Z.createLong(0,0))}static endOperatorSetId(Z){return Z.endObject()}static createOperatorSetId(Z,q,G){return U.startOperatorSetId(Z),U.addDomain(Z,q),U.addVersion(Z,G),U.endOperatorSetId(Z)}}W.OperatorSetId=U})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{class U{constructor(){this.bb=null,this.bb_pos=0}__init(Z,q){return this.bb_pos=Z,this.bb=q,this}static getRootAsTensor(Z,q){return(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}static getSizePrefixedRootAsTensor(Z,q){return Z.setPosition(Z.position()+$.SIZE_PREFIX_LENGTH),(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}name(Z){let q=this.bb.__offset(this.bb_pos,4);return q?this.bb.__string(this.bb_pos+q,Z):null}docString(Z){let q=this.bb.__offset(this.bb_pos,6);return q?this.bb.__string(this.bb_pos+q,Z):null}dims(Z){let q=this.bb.__offset(this.bb_pos,8);return q?this.bb.readInt64(this.bb.__vector(this.bb_pos+q)+Z*8):this.bb.createLong(0,0)}dimsLength(){let Z=this.bb.__offset(this.bb_pos,8);return Z?this.bb.__vector_len(this.bb_pos+Z):0}dataType(){let Z=this.bb.__offset(this.bb_pos,10);return Z?this.bb.readInt32(this.bb_pos+Z):0}rawData(Z){let q=this.bb.__offset(this.bb_pos,12);return q?this.bb.readUint8(this.bb.__vector(this.bb_pos+q)+Z):0}rawDataLength(){let Z=this.bb.__offset(this.bb_pos,12);return Z?this.bb.__vector_len(this.bb_pos+Z):0}rawDataArray(){let Z=this.bb.__offset(this.bb_pos,12);return Z?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+Z),this.bb.__vector_len(this.bb_pos+Z)):null}stringData(Z,q){let G=this.bb.__offset(this.bb_pos,14);return G?this.bb.__string(this.bb.__vector(this.bb_pos+G)+Z*4,q):null}stringDataLength(){let Z=this.bb.__offset(this.bb_pos,14);return Z?this.bb.__vector_len(this.bb_pos+Z):0}static startTensor(Z){Z.startObject(6)}static addName(Z,q){Z.addFieldOffset(0,q,0)}static addDocString(Z,q){Z.addFieldOffset(1,q,0)}static addDims(Z,q){Z.addFieldOffset(2,q,0)}static createDimsVector(Z,q){Z.startVector(8,q.length,8);for(let G=q.length-1;G>=0;G--)Z.addInt64(q[G]);return Z.endVector()}static startDimsVector(Z,q){Z.startVector(8,q,8)}static addDataType(Z,q){Z.addFieldInt32(3,q,0)}static addRawData(Z,q){Z.addFieldOffset(4,q,0)}static createRawDataVector(Z,q){Z.startVector(1,q.length,1);for(let G=q.length-1;G>=0;G--)Z.addInt8(q[G]);return Z.endVector()}static startRawDataVector(Z,q){Z.startVector(1,q,1)}static addStringData(Z,q){Z.addFieldOffset(5,q,0)}static createStringDataVector(Z,q){Z.startVector(4,q.length,4);for(let G=q.length-1;G>=0;G--)Z.addOffset(q[G]);return Z.endVector()}static startStringDataVector(Z,q){Z.startVector(4,q,4)}static endTensor(Z){return Z.endObject()}static createTensor(Z,q,G,J,X,V,R){return U.startTensor(Z),U.addName(Z,q),U.addDocString(Z,G),U.addDims(Z,J),U.addDataType(Z,X),U.addRawData(Z,V),U.addStringData(Z,R),U.endTensor(Z)}}W.Tensor=U})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{class U{constructor(){this.bb=null,this.bb_pos=0}__init(Z,q){return this.bb_pos=Z,this.bb=q,this}static getRootAsSparseTensor(Z,q){return(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}static getSizePrefixedRootAsSparseTensor(Z,q){return Z.setPosition(Z.position()+$.SIZE_PREFIX_LENGTH),(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}values(Z){let q=this.bb.__offset(this.bb_pos,4);return q?(Z||new Q.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+q),this.bb):null}indices(Z){let q=this.bb.__offset(this.bb_pos,6);return q?(Z||new Q.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+q),this.bb):null}dims(Z){let q=this.bb.__offset(this.bb_pos,8);return q?this.bb.readInt64(this.bb.__vector(this.bb_pos+q)+Z*8):this.bb.createLong(0,0)}dimsLength(){let Z=this.bb.__offset(this.bb_pos,8);return Z?this.bb.__vector_len(this.bb_pos+Z):0}static startSparseTensor(Z){Z.startObject(3)}static addValues(Z,q){Z.addFieldOffset(0,q,0)}static addIndices(Z,q){Z.addFieldOffset(1,q,0)}static addDims(Z,q){Z.addFieldOffset(2,q,0)}static createDimsVector(Z,q){Z.startVector(8,q.length,8);for(let G=q.length-1;G>=0;G--)Z.addInt64(q[G]);return Z.endVector()}static startDimsVector(Z,q){Z.startVector(8,q,8)}static endSparseTensor(Z){return Z.endObject()}static createSparseTensor(Z,q,G,J){return U.startSparseTensor(Z),U.addValues(Z,q),U.addIndices(Z,G),U.addDims(Z,J),U.endSparseTensor(Z)}}W.SparseTensor=U})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{class U{constructor(){this.bb=null,this.bb_pos=0}__init(Z,q){return this.bb_pos=Z,this.bb=q,this}static getRootAsAttribute(Z,q){return(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}static getSizePrefixedRootAsAttribute(Z,q){return Z.setPosition(Z.position()+$.SIZE_PREFIX_LENGTH),(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}name(Z){let q=this.bb.__offset(this.bb_pos,4);return q?this.bb.__string(this.bb_pos+q,Z):null}docString(Z){let q=this.bb.__offset(this.bb_pos,6);return q?this.bb.__string(this.bb_pos+q,Z):null}type(){let Z=this.bb.__offset(this.bb_pos,8);return Z?this.bb.readInt32(this.bb_pos+Z):0}f(){let Z=this.bb.__offset(this.bb_pos,10);return Z?this.bb.readFloat32(this.bb_pos+Z):0}i(){let Z=this.bb.__offset(this.bb_pos,12);return Z?this.bb.readInt64(this.bb_pos+Z):this.bb.createLong(0,0)}s(Z){let q=this.bb.__offset(this.bb_pos,14);return q?this.bb.__string(this.bb_pos+q,Z):null}t(Z){let q=this.bb.__offset(this.bb_pos,16);return q?(Z||new Q.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+q),this.bb):null}g(Z){let q=this.bb.__offset(this.bb_pos,18);return q?(Z||new Q.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+q),this.bb):null}floats(Z){let q=this.bb.__offset(this.bb_pos,20);return q?this.bb.readFloat32(this.bb.__vector(this.bb_pos+q)+Z*4):0}floatsLength(){let Z=this.bb.__offset(this.bb_pos,20);return Z?this.bb.__vector_len(this.bb_pos+Z):0}floatsArray(){let Z=this.bb.__offset(this.bb_pos,20);return Z?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+Z),this.bb.__vector_len(this.bb_pos+Z)):null}ints(Z){let q=this.bb.__offset(this.bb_pos,22);return q?this.bb.readInt64(this.bb.__vector(this.bb_pos+q)+Z*8):this.bb.createLong(0,0)}intsLength(){let Z=this.bb.__offset(this.bb_pos,22);return Z?this.bb.__vector_len(this.bb_pos+Z):0}strings(Z,q){let G=this.bb.__offset(this.bb_pos,24);return G?this.bb.__string(this.bb.__vector(this.bb_pos+G)+Z*4,q):null}stringsLength(){let Z=this.bb.__offset(this.bb_pos,24);return Z?this.bb.__vector_len(this.bb_pos+Z):0}tensors(Z,q){let G=this.bb.__offset(this.bb_pos,26);return G?(q||new Q.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+G)+Z*4),this.bb):null}tensorsLength(){let Z=this.bb.__offset(this.bb_pos,26);return Z?this.bb.__vector_len(this.bb_pos+Z):0}graphs(Z,q){let G=this.bb.__offset(this.bb_pos,28);return G?(q||new Q.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+G)+Z*4),this.bb):null}graphsLength(){let Z=this.bb.__offset(this.bb_pos,28);return Z?this.bb.__vector_len(this.bb_pos+Z):0}static startAttribute(Z){Z.startObject(13)}static addName(Z,q){Z.addFieldOffset(0,q,0)}static addDocString(Z,q){Z.addFieldOffset(1,q,0)}static addType(Z,q){Z.addFieldInt32(2,q,0)}static addF(Z,q){Z.addFieldFloat32(3,q,0)}static addI(Z,q){Z.addFieldInt64(4,q,Z.createLong(0,0))}static addS(Z,q){Z.addFieldOffset(5,q,0)}static addT(Z,q){Z.addFieldOffset(6,q,0)}static addG(Z,q){Z.addFieldOffset(7,q,0)}static addFloats(Z,q){Z.addFieldOffset(8,q,0)}static createFloatsVector(Z,q){Z.startVector(4,q.length,4);for(let G=q.length-1;G>=0;G--)Z.addFloat32(q[G]);return Z.endVector()}static startFloatsVector(Z,q){Z.startVector(4,q,4)}static addInts(Z,q){Z.addFieldOffset(9,q,0)}static createIntsVector(Z,q){Z.startVector(8,q.length,8);for(let G=q.length-1;G>=0;G--)Z.addInt64(q[G]);return Z.endVector()}static startIntsVector(Z,q){Z.startVector(8,q,8)}static addStrings(Z,q){Z.addFieldOffset(10,q,0)}static createStringsVector(Z,q){Z.startVector(4,q.length,4);for(let G=q.length-1;G>=0;G--)Z.addOffset(q[G]);return Z.endVector()}static startStringsVector(Z,q){Z.startVector(4,q,4)}static addTensors(Z,q){Z.addFieldOffset(11,q,0)}static createTensorsVector(Z,q){Z.startVector(4,q.length,4);for(let G=q.length-1;G>=0;G--)Z.addOffset(q[G]);return Z.endVector()}static startTensorsVector(Z,q){Z.startVector(4,q,4)}static addGraphs(Z,q){Z.addFieldOffset(12,q,0)}static createGraphsVector(Z,q){Z.startVector(4,q.length,4);for(let G=q.length-1;G>=0;G--)Z.addOffset(q[G]);return Z.endVector()}static startGraphsVector(Z,q){Z.startVector(4,q,4)}static endAttribute(Z){return Z.endObject()}static createAttribute(Z,q,G,J,X,V,R,z,Y,B,k,w,A,D){return U.startAttribute(Z),U.addName(Z,q),U.addDocString(Z,G),U.addType(Z,J),U.addF(Z,X),U.addI(Z,V),U.addS(Z,R),U.addT(Z,z),U.addG(Z,Y),U.addFloats(Z,B),U.addInts(Z,k),U.addStrings(Z,w),U.addTensors(Z,A),U.addGraphs(Z,D),U.endAttribute(Z)}}W.Attribute=U})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{class U{constructor(){this.bb=null,this.bb_pos=0}__init(Z,q){return this.bb_pos=Z,this.bb=q,this}static getRootAsGraph(Z,q){return(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}static getSizePrefixedRootAsGraph(Z,q){return Z.setPosition(Z.position()+$.SIZE_PREFIX_LENGTH),(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}initializers(Z,q){let G=this.bb.__offset(this.bb_pos,4);return G?(q||new Q.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+G)+Z*4),this.bb):null}initializersLength(){let Z=this.bb.__offset(this.bb_pos,4);return Z?this.bb.__vector_len(this.bb_pos+Z):0}nodeArgs(Z,q){let G=this.bb.__offset(this.bb_pos,6);return G?(q||new Q.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+G)+Z*4),this.bb):null}nodeArgsLength(){let Z=this.bb.__offset(this.bb_pos,6);return Z?this.bb.__vector_len(this.bb_pos+Z):0}nodes(Z,q){let G=this.bb.__offset(this.bb_pos,8);return G?(q||new Q.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+G)+Z*4),this.bb):null}nodesLength(){let Z=this.bb.__offset(this.bb_pos,8);return Z?this.bb.__vector_len(this.bb_pos+Z):0}maxNodeIndex(){let Z=this.bb.__offset(this.bb_pos,10);return Z?this.bb.readUint32(this.bb_pos+Z):0}nodeEdges(Z,q){let G=this.bb.__offset(this.bb_pos,12);return G?(q||new Q.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+G)+Z*4),this.bb):null}nodeEdgesLength(){let Z=this.bb.__offset(this.bb_pos,12);return Z?this.bb.__vector_len(this.bb_pos+Z):0}inputs(Z,q){let G=this.bb.__offset(this.bb_pos,14);return G?this.bb.__string(this.bb.__vector(this.bb_pos+G)+Z*4,q):null}inputsLength(){let Z=this.bb.__offset(this.bb_pos,14);return Z?this.bb.__vector_len(this.bb_pos+Z):0}outputs(Z,q){let G=this.bb.__offset(this.bb_pos,16);return G?this.bb.__string(this.bb.__vector(this.bb_pos+G)+Z*4,q):null}outputsLength(){let Z=this.bb.__offset(this.bb_pos,16);return Z?this.bb.__vector_len(this.bb_pos+Z):0}sparseInitializers(Z,q){let G=this.bb.__offset(this.bb_pos,18);return G?(q||new Q.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+G)+Z*4),this.bb):null}sparseInitializersLength(){let Z=this.bb.__offset(this.bb_pos,18);return Z?this.bb.__vector_len(this.bb_pos+Z):0}static startGraph(Z){Z.startObject(8)}static addInitializers(Z,q){Z.addFieldOffset(0,q,0)}static createInitializersVector(Z,q){Z.startVector(4,q.length,4);for(let G=q.length-1;G>=0;G--)Z.addOffset(q[G]);return Z.endVector()}static startInitializersVector(Z,q){Z.startVector(4,q,4)}static addNodeArgs(Z,q){Z.addFieldOffset(1,q,0)}static createNodeArgsVector(Z,q){Z.startVector(4,q.length,4);for(let G=q.length-1;G>=0;G--)Z.addOffset(q[G]);return Z.endVector()}static startNodeArgsVector(Z,q){Z.startVector(4,q,4)}static addNodes(Z,q){Z.addFieldOffset(2,q,0)}static createNodesVector(Z,q){Z.startVector(4,q.length,4);for(let G=q.length-1;G>=0;G--)Z.addOffset(q[G]);return Z.endVector()}static startNodesVector(Z,q){Z.startVector(4,q,4)}static addMaxNodeIndex(Z,q){Z.addFieldInt32(3,q,0)}static addNodeEdges(Z,q){Z.addFieldOffset(4,q,0)}static createNodeEdgesVector(Z,q){Z.startVector(4,q.length,4);for(let G=q.length-1;G>=0;G--)Z.addOffset(q[G]);return Z.endVector()}static startNodeEdgesVector(Z,q){Z.startVector(4,q,4)}static addInputs(Z,q){Z.addFieldOffset(5,q,0)}static createInputsVector(Z,q){Z.startVector(4,q.length,4);for(let G=q.length-1;G>=0;G--)Z.addOffset(q[G]);return Z.endVector()}static startInputsVector(Z,q){Z.startVector(4,q,4)}static addOutputs(Z,q){Z.addFieldOffset(6,q,0)}static createOutputsVector(Z,q){Z.startVector(4,q.length,4);for(let G=q.length-1;G>=0;G--)Z.addOffset(q[G]);return Z.endVector()}static startOutputsVector(Z,q){Z.startVector(4,q,4)}static addSparseInitializers(Z,q){Z.addFieldOffset(7,q,0)}static createSparseInitializersVector(Z,q){Z.startVector(4,q.length,4);for(let G=q.length-1;G>=0;G--)Z.addOffset(q[G]);return Z.endVector()}static startSparseInitializersVector(Z,q){Z.startVector(4,q,4)}static endGraph(Z){return Z.endObject()}static createGraph(Z,q,G,J,X,V,R,z,Y){return U.startGraph(Z),U.addInitializers(Z,q),U.addNodeArgs(Z,G),U.addNodes(Z,J),U.addMaxNodeIndex(Z,X),U.addNodeEdges(Z,V),U.addInputs(Z,R),U.addOutputs(Z,z),U.addSparseInitializers(Z,Y),U.endGraph(Z)}}W.Graph=U})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{class U{constructor(){this.bb=null,this.bb_pos=0}__init(Z,q){return this.bb_pos=Z,this.bb=q,this}static getRootAsModel(Z,q){return(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}static getSizePrefixedRootAsModel(Z,q){return Z.setPosition(Z.position()+$.SIZE_PREFIX_LENGTH),(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}irVersion(){let Z=this.bb.__offset(this.bb_pos,4);return Z?this.bb.readInt64(this.bb_pos+Z):this.bb.createLong(0,0)}opsetImport(Z,q){let G=this.bb.__offset(this.bb_pos,6);return G?(q||new Q.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+G)+Z*4),this.bb):null}opsetImportLength(){let Z=this.bb.__offset(this.bb_pos,6);return Z?this.bb.__vector_len(this.bb_pos+Z):0}producerName(Z){let q=this.bb.__offset(this.bb_pos,8);return q?this.bb.__string(this.bb_pos+q,Z):null}producerVersion(Z){let q=this.bb.__offset(this.bb_pos,10);return q?this.bb.__string(this.bb_pos+q,Z):null}domain(Z){let q=this.bb.__offset(this.bb_pos,12);return q?this.bb.__string(this.bb_pos+q,Z):null}modelVersion(){let Z=this.bb.__offset(this.bb_pos,14);return Z?this.bb.readInt64(this.bb_pos+Z):this.bb.createLong(0,0)}docString(Z){let q=this.bb.__offset(this.bb_pos,16);return q?this.bb.__string(this.bb_pos+q,Z):null}graph(Z){let q=this.bb.__offset(this.bb_pos,18);return q?(Z||new Q.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+q),this.bb):null}graphDocString(Z){let q=this.bb.__offset(this.bb_pos,20);return q?this.bb.__string(this.bb_pos+q,Z):null}static startModel(Z){Z.startObject(9)}static addIrVersion(Z,q){Z.addFieldInt64(0,q,Z.createLong(0,0))}static addOpsetImport(Z,q){Z.addFieldOffset(1,q,0)}static createOpsetImportVector(Z,q){Z.startVector(4,q.length,4);for(let G=q.length-1;G>=0;G--)Z.addOffset(q[G]);return Z.endVector()}static startOpsetImportVector(Z,q){Z.startVector(4,q,4)}static addProducerName(Z,q){Z.addFieldOffset(2,q,0)}static addProducerVersion(Z,q){Z.addFieldOffset(3,q,0)}static addDomain(Z,q){Z.addFieldOffset(4,q,0)}static addModelVersion(Z,q){Z.addFieldInt64(5,q,Z.createLong(0,0))}static addDocString(Z,q){Z.addFieldOffset(6,q,0)}static addGraph(Z,q){Z.addFieldOffset(7,q,0)}static addGraphDocString(Z,q){Z.addFieldOffset(8,q,0)}static endModel(Z){return Z.endObject()}static createModel(Z,q,G,J,X,V,R,z,Y,B){return U.startModel(Z),U.addIrVersion(Z,q),U.addOpsetImport(Z,G),U.addProducerName(Z,J),U.addProducerVersion(Z,X),U.addDomain(Z,V),U.addModelVersion(Z,R),U.addDocString(Z,z),U.addGraph(Z,Y),U.addGraphDocString(Z,B),U.endModel(Z)}}W.Model=U})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{class U{constructor(){this.bb=null,this.bb_pos=0}__init(Z,q){return this.bb_pos=Z,this.bb=q,this}static getRootAsKernelCreateInfos(Z,q){return(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}static getSizePrefixedRootAsKernelCreateInfos(Z,q){return Z.setPosition(Z.position()+$.SIZE_PREFIX_LENGTH),(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}nodeIndices(Z){let q=this.bb.__offset(this.bb_pos,4);return q?this.bb.readUint32(this.bb.__vector(this.bb_pos+q)+Z*4):0}nodeIndicesLength(){let Z=this.bb.__offset(this.bb_pos,4);return Z?this.bb.__vector_len(this.bb_pos+Z):0}nodeIndicesArray(){let Z=this.bb.__offset(this.bb_pos,4);return Z?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+Z),this.bb.__vector_len(this.bb_pos+Z)):null}kernelDefHashes(Z){let q=this.bb.__offset(this.bb_pos,6);return q?this.bb.readUint64(this.bb.__vector(this.bb_pos+q)+Z*8):this.bb.createLong(0,0)}kernelDefHashesLength(){let Z=this.bb.__offset(this.bb_pos,6);return Z?this.bb.__vector_len(this.bb_pos+Z):0}static startKernelCreateInfos(Z){Z.startObject(2)}static addNodeIndices(Z,q){Z.addFieldOffset(0,q,0)}static createNodeIndicesVector(Z,q){Z.startVector(4,q.length,4);for(let G=q.length-1;G>=0;G--)Z.addInt32(q[G]);return Z.endVector()}static startNodeIndicesVector(Z,q){Z.startVector(4,q,4)}static addKernelDefHashes(Z,q){Z.addFieldOffset(1,q,0)}static createKernelDefHashesVector(Z,q){Z.startVector(8,q.length,8);for(let G=q.length-1;G>=0;G--)Z.addInt64(q[G]);return Z.endVector()}static startKernelDefHashesVector(Z,q){Z.startVector(8,q,8)}static endKernelCreateInfos(Z){return Z.endObject()}static createKernelCreateInfos(Z,q,G){return U.startKernelCreateInfos(Z),U.addNodeIndices(Z,q),U.addKernelDefHashes(Z,G),U.endKernelCreateInfos(Z)}}W.KernelCreateInfos=U})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{class U{constructor(){this.bb=null,this.bb_pos=0}__init(Z,q){return this.bb_pos=Z,this.bb=q,this}static getRootAsSubGraphSessionState(Z,q){return(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}static getSizePrefixedRootAsSubGraphSessionState(Z,q){return Z.setPosition(Z.position()+$.SIZE_PREFIX_LENGTH),(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}graphId(Z){let q=this.bb.__offset(this.bb_pos,4);return q?this.bb.__string(this.bb_pos+q,Z):null}sessionState(Z){let q=this.bb.__offset(this.bb_pos,6);return q?(Z||new Q.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+q),this.bb):null}static startSubGraphSessionState(Z){Z.startObject(2)}static addGraphId(Z,q){Z.addFieldOffset(0,q,0)}static addSessionState(Z,q){Z.addFieldOffset(1,q,0)}static endSubGraphSessionState(Z){let q=Z.endObject();return Z.requiredField(q,4),q}static createSubGraphSessionState(Z,q,G){return U.startSubGraphSessionState(Z),U.addGraphId(Z,q),U.addSessionState(Z,G),U.endSubGraphSessionState(Z)}}W.SubGraphSessionState=U})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{class U{constructor(){this.bb=null,this.bb_pos=0}__init(Z,q){return this.bb_pos=Z,this.bb=q,this}static getRootAsSessionState(Z,q){return(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}static getSizePrefixedRootAsSessionState(Z,q){return Z.setPosition(Z.position()+$.SIZE_PREFIX_LENGTH),(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}kernels(Z){let q=this.bb.__offset(this.bb_pos,4);return q?(Z||new Q.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+q),this.bb):null}subGraphSessionStates(Z,q){let G=this.bb.__offset(this.bb_pos,6);return G?(q||new Q.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+G)+Z*4),this.bb):null}subGraphSessionStatesLength(){let Z=this.bb.__offset(this.bb_pos,6);return Z?this.bb.__vector_len(this.bb_pos+Z):0}static startSessionState(Z){Z.startObject(2)}static addKernels(Z,q){Z.addFieldOffset(0,q,0)}static addSubGraphSessionStates(Z,q){Z.addFieldOffset(1,q,0)}static createSubGraphSessionStatesVector(Z,q){Z.startVector(4,q.length,4);for(let G=q.length-1;G>=0;G--)Z.addOffset(q[G]);return Z.endVector()}static startSubGraphSessionStatesVector(Z,q){Z.startVector(4,q,4)}static endSessionState(Z){return Z.endObject()}static createSessionState(Z,q,G){return U.startSessionState(Z),U.addKernels(Z,q),U.addSubGraphSessionStates(Z,G),U.endSessionState(Z)}}W.SessionState=U})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={}),((Q)=>{let H;((j)=>{let K;((W)=>{class U{constructor(){this.bb=null,this.bb_pos=0}__init(Z,q){return this.bb_pos=Z,this.bb=q,this}static getRootAsInferenceSession(Z,q){return(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}static getSizePrefixedRootAsInferenceSession(Z,q){return Z.setPosition(Z.position()+$.SIZE_PREFIX_LENGTH),(q||new U).__init(Z.readInt32(Z.position())+Z.position(),Z)}static bufferHasIdentifier(Z){return Z.__has_identifier("ORTM")}ortVersion(Z){let q=this.bb.__offset(this.bb_pos,4);return q?this.bb.__string(this.bb_pos+q,Z):null}model(Z){let q=this.bb.__offset(this.bb_pos,6);return q?(Z||new Q.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+q),this.bb):null}sessionState(Z){let q=this.bb.__offset(this.bb_pos,8);return q?(Z||new Q.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+q),this.bb):null}static startInferenceSession(Z){Z.startObject(3)}static addOrtVersion(Z,q){Z.addFieldOffset(0,q,0)}static addModel(Z,q){Z.addFieldOffset(1,q,0)}static addSessionState(Z,q){Z.addFieldOffset(2,q,0)}static endInferenceSession(Z){return Z.endObject()}static finishInferenceSessionBuffer(Z,q){Z.finish(q,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(Z,q){Z.finish(q,"ORTM",!0)}static createInferenceSession(Z,q,G,J){return U.startInferenceSession(Z),U.addOrtVersion(Z,q),U.addModel(Z,G),U.addSessionState(Z,J),U.endInferenceSession(Z)}}W.InferenceSession=U})(K=j.fbs||={})})(H=Q.experimental||={})})(H1||={})}),rZ=U1((Q,H)=>{H.exports=j;function j(K,W){for(var U=new Array(arguments.length-1),Z=0,q=2,G=!0;q<arguments.length;)U[Z++]=arguments[q++];return new Promise(function(J,X){U[Z]=function(V){if(G)if(G=!1,V)X(V);else{for(var R=new Array(arguments.length-1),z=0;z<R.length;)R[z++]=arguments[z];J.apply(null,R)}};try{K.apply(W||null,U)}catch(V){G&&(G=!1,X(V))}})}}),tZ=U1((Q)=>{var H=Q;H.length=function(Z){var q=Z.length;if(!q)return 0;for(var G=0;--q%4>1&&Z.charAt(q)==="=";)++G;return Math.ceil(Z.length*3)/4-G};var j=new Array(64),K=new Array(123);for(W=0;W<64;)K[j[W]=W<26?W+65:W<52?W+71:W<62?W-4:W-59|43]=W++;var W;H.encode=function(Z,q,G){for(var J=null,X=[],V=0,R=0,z;q<G;){var Y=Z[q++];switch(R){case 0:X[V++]=j[Y>>2],z=(Y&3)<<4,R=1;break;case 1:X[V++]=j[z|Y>>4],z=(Y&15)<<2,R=2;break;case 2:X[V++]=j[z|Y>>6],X[V++]=j[Y&63],R=0;break}V>8191&&((J||(J=[])).push(String.fromCharCode.apply(String,X)),V=0)}return R&&(X[V++]=j[z],X[V++]=61,R===1&&(X[V++]=61)),J?(V&&J.push(String.fromCharCode.apply(String,X.slice(0,V))),J.join("")):String.fromCharCode.apply(String,X.slice(0,V))};var U="invalid encoding";H.decode=function(Z,q,G){for(var J=G,X=0,V,R=0;R<Z.length;){var z=Z.charCodeAt(R++);if(z===61&&X>1)break;if((z=K[z])===void 0)throw Error(U);switch(X){case 0:V=z,X=1;break;case 1:q[G++]=V<<2|(z&48)>>4,V=z,X=2;break;case 2:q[G++]=(V&15)<<4|(z&60)>>2,V=z,X=3;break;case 3:q[G++]=(V&3)<<6|z,X=0;break}}if(X===1)throw Error(U);return G-J},H.test=function(Z){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(Z)}}),eZ=U1((Q,H)=>{H.exports=j;function j(){this._listeners={}}j.prototype.on=function(K,W,U){return(this._listeners[K]||(this._listeners[K]=[])).push({fn:W,ctx:U||this}),this},j.prototype.off=function(K,W){if(K===void 0)this._listeners={};else if(W===void 0)this._listeners[K]=[];else for(var U=this._listeners[K],Z=0;Z<U.length;)U[Z].fn===W?U.splice(Z,1):++Z;return this},j.prototype.emit=function(K){var W=this._listeners[K];if(W){for(var U=[],Z=1;Z<arguments.length;)U.push(arguments[Z++]);for(Z=0;Z<W.length;)W[Z].fn.apply(W[Z++].ctx,U)}return this}}),Qj=U1((Q,H)=>{H.exports=j(j);function j(q){return typeof Float32Array<"u"?function(){var G=new Float32Array([-0]),J=new Uint8Array(G.buffer),X=J[3]===128;function V(B,k,w){G[0]=B,k[w]=J[0],k[w+1]=J[1],k[w+2]=J[2],k[w+3]=J[3]}function R(B,k,w){G[0]=B,k[w]=J[3],k[w+1]=J[2],k[w+2]=J[1],k[w+3]=J[0]}q.writeFloatLE=X?V:R,q.writeFloatBE=X?R:V;function z(B,k){return J[0]=B[k],J[1]=B[k+1],J[2]=B[k+2],J[3]=B[k+3],G[0]}function Y(B,k){return J[3]=B[k],J[2]=B[k+1],J[1]=B[k+2],J[0]=B[k+3],G[0]}q.readFloatLE=X?z:Y,q.readFloatBE=X?Y:z}():function(){function G(X,V,R,z){var Y=V<0?1:0;if(Y&&(V=-V),V===0)X(1/V>0?0:2147483648,R,z);else if(isNaN(V))X(2143289344,R,z);else if(V>340282346638528860000000000000000000000)X((Y<<31|2139095040)>>>0,R,z);else if(V<0.000000000000000000000000000000000000011754943508222875)X((Y<<31|Math.round(V/0.000000000000000000000000000000000000000000001401298464324817))>>>0,R,z);else{var B=Math.floor(Math.log(V)/Math.LN2),k=Math.round(V*Math.pow(2,-B)*8388608)&8388607;X((Y<<31|B+127<<23|k)>>>0,R,z)}}q.writeFloatLE=G.bind(null,K),q.writeFloatBE=G.bind(null,W);function J(X,V,R){var z=X(V,R),Y=(z>>31)*2+1,B=z>>>23&255,k=z&8388607;return B===255?k?NaN:Y*(1/0):B===0?Y*0.000000000000000000000000000000000000000000001401298464324817*k:Y*Math.pow(2,B-150)*(k+8388608)}q.readFloatLE=J.bind(null,U),q.readFloatBE=J.bind(null,Z)}(),typeof Float64Array<"u"?function(){var G=new Float64Array([-0]),J=new Uint8Array(G.buffer),X=J[7]===128;function V(B,k,w){G[0]=B,k[w]=J[0],k[w+1]=J[1],k[w+2]=J[2],k[w+3]=J[3],k[w+4]=J[4],k[w+5]=J[5],k[w+6]=J[6],k[w+7]=J[7]}function R(B,k,w){G[0]=B,k[w]=J[7],k[w+1]=J[6],k[w+2]=J[5],k[w+3]=J[4],k[w+4]=J[3],k[w+5]=J[2],k[w+6]=J[1],k[w+7]=J[0]}q.writeDoubleLE=X?V:R,q.writeDoubleBE=X?R:V;function z(B,k){return J[0]=B[k],J[1]=B[k+1],J[2]=B[k+2],J[3]=B[k+3],J[4]=B[k+4],J[5]=B[k+5],J[6]=B[k+6],J[7]=B[k+7],G[0]}function Y(B,k){return J[7]=B[k],J[6]=B[k+1],J[5]=B[k+2],J[4]=B[k+3],J[3]=B[k+4],J[2]=B[k+5],J[1]=B[k+6],J[0]=B[k+7],G[0]}q.readDoubleLE=X?z:Y,q.readDoubleBE=X?Y:z}():function(){function G(X,V,R,z,Y,B){var k=z<0?1:0;if(k&&(z=-z),z===0)X(0,Y,B+V),X(1/z>0?0:2147483648,Y,B+R);else if(isNaN(z))X(0,Y,B+V),X(2146959360,Y,B+R);else if(z>179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)X(0,Y,B+V),X((k<<31|2146435072)>>>0,Y,B+R);else{var w;if(z<0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000022250738585072014)w=z/0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005,X(w>>>0,Y,B+V),X((k<<31|w/4294967296)>>>0,Y,B+R);else{var A=Math.floor(Math.log(z)/Math.LN2);A===1024&&(A=1023),w=z*Math.pow(2,-A),X(w*4503599627370496>>>0,Y,B+V),X((k<<31|A+1023<<20|w*1048576&1048575)>>>0,Y,B+R)}}}q.writeDoubleLE=G.bind(null,K,0,4),q.writeDoubleBE=G.bind(null,W,4,0);function J(X,V,R,z,Y){var B=X(z,Y+V),k=X(z,Y+R),w=(k>>31)*2+1,A=k>>>20&2047,D=4294967296*(k&1048575)+B;return A===2047?D?NaN:w*(1/0):A===0?w*0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005*D:w*Math.pow(2,A-1075)*(D+4503599627370496)}q.readDoubleLE=J.bind(null,U,0,4),q.readDoubleBE=J.bind(null,Z,4,0)}(),q}function K(q,G,J){G[J]=q&255,G[J+1]=q>>>8&255,G[J+2]=q>>>16&255,G[J+3]=q>>>24}function W(q,G,J){G[J]=q>>>24,G[J+1]=q>>>16&255,G[J+2]=q>>>8&255,G[J+3]=q&255}function U(q,G){return(q[G]|q[G+1]<<8|q[G+2]<<16|q[G+3]<<24)>>>0}function Z(q,G){return(q[G]<<24|q[G+1]<<16|q[G+2]<<8|q[G+3])>>>0}}),Jj=U1((exports,module)=>{module.exports=inquire;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(Q){}return null}}),Hj=U1((Q)=>{var H=Q;H.length=function(j){for(var K=0,W=0,U=0;U<j.length;++U)W=j.charCodeAt(U),W<128?K+=1:W<2048?K+=2:(W&64512)===55296&&(j.charCodeAt(U+1)&64512)===56320?(++U,K+=4):K+=3;return K},H.read=function(j,K,W){var U=W-K;if(U<1)return"";for(var Z=null,q=[],G=0,J;K<W;)J=j[K++],J<128?q[G++]=J:J>191&&J<224?q[G++]=(J&31)<<6|j[K++]&63:J>239&&J<365?(J=((J&7)<<18|(j[K++]&63)<<12|(j[K++]&63)<<6|j[K++]&63)-65536,q[G++]=55296+(J>>10),q[G++]=56320+(J&1023)):q[G++]=(J&15)<<12|(j[K++]&63)<<6|j[K++]&63,G>8191&&((Z||(Z=[])).push(String.fromCharCode.apply(String,q)),G=0);return Z?(G&&Z.push(String.fromCharCode.apply(String,q.slice(0,G))),Z.join("")):String.fromCharCode.apply(String,q.slice(0,G))},H.write=function(j,K,W){for(var U=W,Z,q,G=0;G<j.length;++G)Z=j.charCodeAt(G),Z<128?K[W++]=Z:Z<2048?(K[W++]=Z>>6|192,K[W++]=Z&63|128):(Z&64512)===55296&&((q=j.charCodeAt(G+1))&64512)===56320?(Z=65536+((Z&1023)<<10)+(q&1023),++G,K[W++]=Z>>18|240,K[W++]=Z>>12&63|128,K[W++]=Z>>6&63|128,K[W++]=Z&63|128):(K[W++]=Z>>12|224,K[W++]=Z>>6&63|128,K[W++]=Z&63|128);return W-U}}),Zj=U1((Q,H)=>{H.exports=j;function j(K,W,U){var Z=U||8192,q=Z>>>1,G=null,J=Z;return function(X){if(X<1||X>q)return K(X);J+X>Z&&(G=K(Z),J=0);var V=W.call(G,J,J+=X);return J&7&&(J=(J|7)+1),V}}}),jj=U1((Q,H)=>{H.exports=K;var j=n3();function K(q,G){this.lo=q>>>0,this.hi=G>>>0}var W=K.zero=new K(0,0);W.toNumber=function(){return 0},W.zzEncode=W.zzDecode=function(){return this},W.length=function(){return 1};var U=K.zeroHash="\0\0\0\0\0\0\0\0";K.fromNumber=function(q){if(q===0)return W;var G=q<0;G&&(q=-q);var J=q>>>0,X=(q-J)/4294967296>>>0;return G&&(X=~X>>>0,J=~J>>>0,++J>4294967295&&(J=0,++X>4294967295&&(X=0))),new K(J,X)},K.from=function(q){if(typeof q=="number")return K.fromNumber(q);if(j.isString(q))if(j.Long)q=j.Long.fromString(q);else return K.fromNumber(parseInt(q,10));return q.low||q.high?new K(q.low>>>0,q.high>>>0):W},K.prototype.toNumber=function(q){if(!q&&this.hi>>>31){var G=~this.lo+1>>>0,J=~this.hi>>>0;return G||(J=J+1>>>0),-(G+J*4294967296)}return this.lo+this.hi*4294967296},K.prototype.toLong=function(q){return j.Long?new j.Long(this.lo|0,this.hi|0,!!q):{low:this.lo|0,high:this.hi|0,unsigned:!!q}};var Z=String.prototype.charCodeAt;K.fromHash=function(q){return q===U?W:new K((Z.call(q,0)|Z.call(q,1)<<8|Z.call(q,2)<<16|Z.call(q,3)<<24)>>>0,(Z.call(q,4)|Z.call(q,5)<<8|Z.call(q,6)<<16|Z.call(q,7)<<24)>>>0)},K.prototype.toHash=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},K.prototype.zzEncode=function(){var q=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^q)>>>0,this.lo=(this.lo<<1^q)>>>0,this},K.prototype.zzDecode=function(){var q=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^q)>>>0,this.hi=(this.hi>>>1^q)>>>0,this},K.prototype.length=function(){var q=this.lo,G=(this.lo>>>28|this.hi<<4)>>>0,J=this.hi>>>24;return J===0?G===0?q<16384?q<128?1:2:q<2097152?3:4:G<16384?G<128?5:6:G<2097152?7:8:J<128?9:10}}),n3=U1((Q)=>{var H=Q;H.asPromise=rZ(),H.base64=tZ(),H.EventEmitter=eZ(),H.float=Qj(),H.inquire=Jj(),H.utf8=Hj(),H.pool=Zj(),H.LongBits=jj(),H.isNode=!!(typeof global<"u"&&global&&global.process&&global.process.versions&&global.process.versions.node),H.global=H.isNode&&global||typeof window<"u"&&window||typeof self<"u"&&self||Q,H.emptyArray=Object.freeze?Object.freeze([]):[],H.emptyObject=Object.freeze?Object.freeze({}):{},H.isInteger=Number.isInteger||function(W){return typeof W=="number"&&isFinite(W)&&Math.floor(W)===W},H.isString=function(W){return typeof W=="string"||W instanceof String},H.isObject=function(W){return W&&typeof W=="object"},H.isset=H.isSet=function(W,U){var Z=W[U];return Z!=null&&W.hasOwnProperty(U)?typeof Z!="object"||(Array.isArray(Z)?Z.length:Object.keys(Z).length)>0:!1},H.Buffer=function(){try{var W=H.inquire("buffer").Buffer;return W.prototype.utf8Write?W:null}catch{return null}}(),H._Buffer_from=null,H._Buffer_allocUnsafe=null,H.newBuffer=function(W){return typeof W=="number"?H.Buffer?H._Buffer_allocUnsafe(W):new H.Array(W):H.Buffer?H._Buffer_from(W):typeof Uint8Array>"u"?W:new Uint8Array(W)},H.Array=typeof Uint8Array<"u"?Uint8Array:Array,H.Long=H.global.dcodeIO&&H.global.dcodeIO.Long||H.global.Long||H.inquire("long"),H.key2Re=/^true|false|0|1$/,H.key32Re=/^-?(?:0|[1-9][0-9]*)$/,H.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,H.longToHash=function(W){return W?H.LongBits.from(W).toHash():H.LongBits.zeroHash},H.longFromHash=function(W,U){var Z=H.LongBits.fromHash(W);return H.Long?H.Long.fromBits(Z.lo,Z.hi,U):Z.toNumber(!!U)};function j(W,U,Z){for(var q=Object.keys(U),G=0;G<q.length;++G)(W[q[G]]===void 0||!Z)&&(W[q[G]]=U[q[G]]);return W}H.merge=j,H.lcFirst=function(W){return W.charAt(0).toLowerCase()+W.substring(1)};function K(W){function U(Z,q){if(!(this instanceof U))return new U(Z,q);Object.defineProperty(this,"message",{get:function(){return Z}}),Error.captureStackTrace?Error.captureStackTrace(this,U):Object.defineProperty(this,"stack",{value:new Error().stack||""}),q&&j(this,q)}return U.prototype=Object.create(Error.prototype,{constructor:{value:U,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return W},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),U}H.newError=K,H.ProtocolError=K("ProtocolError"),H.oneOfGetter=function(W){for(var U={},Z=0;Z<W.length;++Z)U[W[Z]]=1;return function(){for(var q=Object.keys(this),G=q.length-1;G>-1;--G)if(U[q[G]]===1&&this[q[G]]!==void 0&&this[q[G]]!==null)return q[G]}},H.oneOfSetter=function(W){return function(U){for(var Z=0;Z<W.length;++Z)W[Z]!==U&&delete this[W[Z]]}},H.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},H._configure=function(){var W=H.Buffer;if(!W){H._Buffer_from=H._Buffer_allocUnsafe=null;return}H._Buffer_from=W.from!==Uint8Array.from&&W.from||function(U,Z){return new W(U,Z)},H._Buffer_allocUnsafe=W.allocUnsafe||function(U){return new W(U)}}}),n2=U1((Q,H)=>{H.exports=X;var j=n3(),K,W=j.LongBits,U=j.base64,Z=j.utf8;function q(A,D,I){this.fn=A,this.len=D,this.next=void 0,this.val=I}function G(){}function J(A){this.head=A.head,this.tail=A.tail,this.len=A.len,this.next=A.states}function X(){this.len=0,this.head=new q(G,0,0),this.tail=this.head,this.states=null}var V=function(){return j.Buffer?function(){return(X.create=function(){return new K})()}:function(){return new X}};X.create=V(),X.alloc=function(A){return new j.Array(A)},j.Array!==Array&&(X.alloc=j.pool(X.alloc,j.Array.prototype.subarray)),X.prototype._push=function(A,D,I){return this.tail=this.tail.next=new q(A,D,I),this.len+=D,this};function R(A,D,I){D[I]=A&255}function z(A,D,I){for(;A>127;)D[I++]=A&127|128,A>>>=7;D[I]=A}function Y(A,D){this.len=A,this.next=void 0,this.val=D}Y.prototype=Object.create(q.prototype),Y.prototype.fn=z,X.prototype.uint32=function(A){return this.len+=(this.tail=this.tail.next=new Y((A=A>>>0)<128?1:A<16384?2:A<2097152?3:A<268435456?4:5,A)).len,this},X.prototype.int32=function(A){return A<0?this._push(B,10,W.fromNumber(A)):this.uint32(A)},X.prototype.sint32=function(A){return this.uint32((A<<1^A>>31)>>>0)};function B(A,D,I){for(;A.hi;)D[I++]=A.lo&127|128,A.lo=(A.lo>>>7|A.hi<<25)>>>0,A.hi>>>=7;for(;A.lo>127;)D[I++]=A.lo&127|128,A.lo=A.lo>>>7;D[I++]=A.lo}X.prototype.uint64=function(A){var D=W.from(A);return this._push(B,D.length(),D)},X.prototype.int64=X.prototype.uint64,X.prototype.sint64=function(A){var D=W.from(A).zzEncode();return this._push(B,D.length(),D)},X.prototype.bool=function(A){return this._push(R,1,A?1:0)};function k(A,D,I){D[I]=A&255,D[I+1]=A>>>8&255,D[I+2]=A>>>16&255,D[I+3]=A>>>24}X.prototype.fixed32=function(A){return this._push(k,4,A>>>0)},X.prototype.sfixed32=X.prototype.fixed32,X.prototype.fixed64=function(A){var D=W.from(A);return this._push(k,4,D.lo)._push(k,4,D.hi)},X.prototype.sfixed64=X.prototype.fixed64,X.prototype.float=function(A){return this._push(j.float.writeFloatLE,4,A)},X.prototype.double=function(A){return this._push(j.float.writeDoubleLE,8,A)};var w=j.Array.prototype.set?function(A,D,I){D.set(A,I)}:function(A,D,I){for(var h=0;h<A.length;++h)D[I+h]=A[h]};X.prototype.bytes=function(A){var D=A.length>>>0;if(!D)return this._push(R,1,0);if(j.isString(A)){var I=X.alloc(D=U.length(A));U.decode(A,I,0),A=I}return this.uint32(D)._push(w,D,A)},X.prototype.string=function(A){var D=Z.length(A);return D?this.uint32(D)._push(Z.write,D,A):this._push(R,1,0)},X.prototype.fork=function(){return this.states=new J(this),this.head=this.tail=new q(G,0,0),this.len=0,this},X.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new q(G,0,0),this.len=0),this},X.prototype.ldelim=function(){var A=this.head,D=this.tail,I=this.len;return this.reset().uint32(I),I&&(this.tail.next=A.next,this.tail=D,this.len+=I),this},X.prototype.finish=function(){for(var A=this.head.next,D=this.constructor.alloc(this.len),I=0;A;)A.fn(A.val,D,I),I+=A.len,A=A.next;return D},X._configure=function(A){K=A,X.create=V(),K._configure()}}),Vj=U1((Q,H)=>{H.exports=W;var j=n2();(W.prototype=Object.create(j.prototype)).constructor=W;var K=n3();function W(){j.call(this)}W._configure=function(){W.alloc=K._Buffer_allocUnsafe,W.writeBytesBuffer=K.Buffer&&K.Buffer.prototype instanceof Uint8Array&&K.Buffer.prototype.set.name==="set"?function(Z,q,G){q.set(Z,G)}:function(Z,q,G){if(Z.copy)Z.copy(q,G,0,Z.length);else for(var J=0;J<Z.length;)q[G++]=Z[J++]}},W.prototype.bytes=function(Z){K.isString(Z)&&(Z=K._Buffer_from(Z,"base64"));var q=Z.length>>>0;return this.uint32(q),q&&this._push(W.writeBytesBuffer,q,Z),this};function U(Z,q,G){Z.length<40?K.utf8.write(Z,q,G):q.utf8Write?q.utf8Write(Z,G):q.write(Z,G)}W.prototype.string=function(Z){var q=K.Buffer.byteLength(Z);return this.uint32(q),q&&this._push(U,q,Z),this},W._configure()}),r2=U1((Q,H)=>{H.exports=q;var j=n3(),K,W=j.LongBits,U=j.utf8;function Z(z,Y){return RangeError("index out of range: "+z.pos+" + "+(Y||1)+" > "+z.len)}function q(z){this.buf=z,this.pos=0,this.len=z.length}var G=typeof Uint8Array<"u"?function(z){if(z instanceof Uint8Array||Array.isArray(z))return new q(z);throw Error("illegal buffer")}:function(z){if(Array.isArray(z))return new q(z);throw Error("illegal buffer")},J=function(){return j.Buffer?function(z){return(q.create=function(Y){return j.Buffer.isBuffer(Y)?new K(Y):G(Y)})(z)}:G};q.create=J(),q.prototype._slice=j.Array.prototype.subarray||j.Array.prototype.slice,q.prototype.uint32=function(){var z=4294967295;return function(){if(z=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(z=(z|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(z=(z|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(z=(z|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(z=(z|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return z;if((this.pos+=5)>this.len)throw this.pos=this.len,Z(this,10);return z}}(),q.prototype.int32=function(){return this.uint32()|0},q.prototype.sint32=function(){var z=this.uint32();return z>>>1^-(z&1)|0};function X(){var z=new W(0,0),Y=0;if(this.len-this.pos>4){for(;Y<4;++Y)if(z.lo=(z.lo|(this.buf[this.pos]&127)<<Y*7)>>>0,this.buf[this.pos++]<128)return z;if(z.lo=(z.lo|(this.buf[this.pos]&127)<<28)>>>0,z.hi=(z.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return z;Y=0}else{for(;Y<3;++Y){if(this.pos>=this.len)throw Z(this);if(z.lo=(z.lo|(this.buf[this.pos]&127)<<Y*7)>>>0,this.buf[this.pos++]<128)return z}return z.lo=(z.lo|(this.buf[this.pos++]&127)<<Y*7)>>>0,z}if(this.len-this.pos>4){for(;Y<5;++Y)if(z.hi=(z.hi|(this.buf[this.pos]&127)<<Y*7+3)>>>0,this.buf[this.pos++]<128)return z}else for(;Y<5;++Y){if(this.pos>=this.len)throw Z(this);if(z.hi=(z.hi|(this.buf[this.pos]&127)<<Y*7+3)>>>0,this.buf[this.pos++]<128)return z}throw Error("invalid varint encoding")}q.prototype.bool=function(){return this.uint32()!==0};function V(z,Y){return(z[Y-4]|z[Y-3]<<8|z[Y-2]<<16|z[Y-1]<<24)>>>0}q.prototype.fixed32=function(){if(this.pos+4>this.len)throw Z(this,4);return V(this.buf,this.pos+=4)},q.prototype.sfixed32=function(){if(this.pos+4>this.len)throw Z(this,4);return V(this.buf,this.pos+=4)|0};function R(){if(this.pos+8>this.len)throw Z(this,8);return new W(V(this.buf,this.pos+=4),V(this.buf,this.pos+=4))}q.prototype.float=function(){if(this.pos+4>this.len)throw Z(this,4);var z=j.float.readFloatLE(this.buf,this.pos);return this.pos+=4,z},q.prototype.double=function(){if(this.pos+8>this.len)throw Z(this,4);var z=j.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,z},q.prototype.bytes=function(){var z=this.uint32(),Y=this.pos,B=this.pos+z;if(B>this.len)throw Z(this,z);if(this.pos+=z,Array.isArray(this.buf))return this.buf.slice(Y,B);if(Y===B){var k=j.Buffer;return k?k.alloc(0):new this.buf.constructor(0)}return this._slice.call(this.buf,Y,B)},q.prototype.string=function(){var z=this.bytes();return U.read(z,0,z.length)},q.prototype.skip=function(z){if(typeof z=="number"){if(this.pos+z>this.len)throw Z(this,z);this.pos+=z}else do if(this.pos>=this.len)throw Z(this);while(this.buf[this.pos++]&128);return this},q.prototype.skipType=function(z){switch(z){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(z=this.uint32()&7)!==4;)this.skipType(z);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+z+" at offset "+this.pos)}return this},q._configure=function(z){K=z,q.create=J(),K._configure();var Y=j.Long?"toLong":"toNumber";j.merge(q.prototype,{int64:function(){return X.call(this)[Y](!1)},uint64:function(){return X.call(this)[Y](!0)},sint64:function(){return X.call(this).zzDecode()[Y](!1)},fixed64:function(){return R.call(this)[Y](!0)},sfixed64:function(){return R.call(this)[Y](!1)}})}}),Xj=U1((Q,H)=>{H.exports=W;var j=r2();(W.prototype=Object.create(j.prototype)).constructor=W;var K=n3();function W(U){j.call(this,U)}W._configure=function(){K.Buffer&&(W.prototype._slice=K.Buffer.prototype.slice)},W.prototype.string=function(){var U=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+U,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+U,this.len))},W._configure()}),Kj=U1((Q,H)=>{H.exports=K;var j=n3();(K.prototype=Object.create(j.EventEmitter.prototype)).constructor=K;function K(W,U,Z){if(typeof W!="function")throw TypeError("rpcImpl must be a function");j.EventEmitter.call(this),this.rpcImpl=W,this.requestDelimited=!!U,this.responseDelimited=!!Z}K.prototype.rpcCall=function W(U,Z,q,G,J){if(!G)throw TypeError("request must be specified");var X=this;if(!J)return j.asPromise(W,X,U,Z,q,G);if(!X.rpcImpl){setTimeout(function(){J(Error("already ended"))},0);return}try{return X.rpcImpl(U,Z[X.requestDelimited?"encodeDelimited":"encode"](G).finish(),function(V,R){if(V)return X.emit("error",V,U),J(V);if(R===null){X.end(!0);return}if(!(R instanceof q))try{R=q[X.responseDelimited?"decodeDelimited":"decode"](R)}catch(z){return X.emit("error",z,U),J(z)}return X.emit("data",R,U),J(null,R)})}catch(V){X.emit("error",V,U),setTimeout(function(){J(V)},0);return}},K.prototype.end=function(W){return this.rpcImpl&&(W||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}}),Uj=U1((Q)=>{var H=Q;H.Service=Kj()}),qj=U1((Q,H)=>{H.exports={}}),Wj=U1((Q)=>{var H=Q;H.build="minimal",H.Writer=n2(),H.BufferWriter=Vj(),H.Reader=r2(),H.BufferReader=Xj(),H.util=n3(),H.rpc=Uj(),H.roots=qj(),H.configure=j;function j(){H.util._configure(),H.Writer._configure(H.BufferWriter),H.Reader._configure(H.BufferReader)}j()}),Gj=U1((Q,H)=>{H.exports=Wj()}),l4=U1((Q,H)=>{var j=Gj(),K=j.Reader,W=j.Writer,U=j.util,Z=j.roots.default||(j.roots.default={});Z.onnx=function(){var q={};return q.Version=function(){var G={},J=Object.create(G);return J[G[0]="_START_VERSION"]=0,J[G[1]="IR_VERSION_2017_10_10"]=1,J[G[2]="IR_VERSION_2017_10_30"]=2,J[G[3]="IR_VERSION_2017_11_3"]=3,J[G[4]="IR_VERSION_2019_1_22"]=4,J[G[5]="IR_VERSION_2019_3_18"]=5,J[G[6]="IR_VERSION_2019_9_19"]=6,J[G[7]="IR_VERSION_2020_5_8"]=7,J[G[8]="IR_VERSION_2021_7_30"]=8,J[G[9]="IR_VERSION"]=9,J}(),q.AttributeProto=function(){function G(J){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],this.sparseTensors=[],this.typeProtos=[],J)for(var X=Object.keys(J),V=0;V<X.length;++V)J[X[V]]!=null&&(this[X[V]]=J[X[V]])}return G.prototype.name="",G.prototype.refAttrName="",G.prototype.docString="",G.prototype.type=0,G.prototype.f=0,G.prototype.i=U.Long?U.Long.fromBits(0,0,!1):0,G.prototype.s=U.newBuffer([]),G.prototype.t=null,G.prototype.g=null,G.prototype.sparseTensor=null,G.prototype.tp=null,G.prototype.floats=U.emptyArray,G.prototype.ints=U.emptyArray,G.prototype.strings=U.emptyArray,G.prototype.tensors=U.emptyArray,G.prototype.graphs=U.emptyArray,G.prototype.sparseTensors=U.emptyArray,G.prototype.typeProtos=U.emptyArray,G.create=function(J){return new G(J)},G.encode=function(J,X){if(X||(X=W.create()),J.name!=null&&Object.hasOwnProperty.call(J,"name")&&X.uint32(10).string(J.name),J.f!=null&&Object.hasOwnProperty.call(J,"f")&&X.uint32(21).float(J.f),J.i!=null&&Object.hasOwnProperty.call(J,"i")&&X.uint32(24).int64(J.i),J.s!=null&&Object.hasOwnProperty.call(J,"s")&&X.uint32(34).bytes(J.s),J.t!=null&&Object.hasOwnProperty.call(J,"t")&&Z.onnx.TensorProto.encode(J.t,X.uint32(42).fork()).ldelim(),J.g!=null&&Object.hasOwnProperty.call(J,"g")&&Z.onnx.GraphProto.encode(J.g,X.uint32(50).fork()).ldelim(),J.floats!=null&&J.floats.length){X.uint32(58).fork();for(var V=0;V<J.floats.length;++V)X.float(J.floats[V]);X.ldelim()}if(J.ints!=null&&J.ints.length){X.uint32(66).fork();for(var V=0;V<J.ints.length;++V)X.int64(J.ints[V]);X.ldelim()}if(J.strings!=null&&J.strings.length)for(var V=0;V<J.strings.length;++V)X.uint32(74).bytes(J.strings[V]);if(J.tensors!=null&&J.tensors.length)for(var V=0;V<J.tensors.length;++V)Z.onnx.TensorProto.encode(J.tensors[V],X.uint32(82).fork()).ldelim();if(J.graphs!=null&&J.graphs.length)for(var V=0;V<J.graphs.length;++V)Z.onnx.GraphProto.encode(J.graphs[V],X.uint32(90).fork()).ldelim();if(J.docString!=null&&Object.hasOwnProperty.call(J,"docString")&&X.uint32(106).string(J.docString),J.tp!=null&&Object.hasOwnProperty.call(J,"tp")&&Z.onnx.TypeProto.encode(J.tp,X.uint32(114).fork()).ldelim(),J.typeProtos!=null&&J.typeProtos.length)for(var V=0;V<J.typeProtos.length;++V)Z.onnx.TypeProto.encode(J.typeProtos[V],X.uint32(122).fork()).ldelim();if(J.type!=null&&Object.hasOwnProperty.call(J,"type")&&X.uint32(160).int32(J.type),J.refAttrName!=null&&Object.hasOwnProperty.call(J,"refAttrName")&&X.uint32(170).string(J.refAttrName),J.sparseTensor!=null&&Object.hasOwnProperty.call(J,"sparseTensor")&&Z.onnx.SparseTensorProto.encode(J.sparseTensor,X.uint32(178).fork()).ldelim(),J.sparseTensors!=null&&J.sparseTensors.length)for(var V=0;V<J.sparseTensors.length;++V)Z.onnx.SparseTensorProto.encode(J.sparseTensors[V],X.uint32(186).fork()).ldelim();return X},G.encodeDelimited=function(J,X){return this.encode(J,X).ldelim()},G.decode=function(J,X){J instanceof K||(J=K.create(J));for(var V=X===void 0?J.len:J.pos+X,R=new Z.onnx.AttributeProto;J.pos<V;){var z=J.uint32();switch(z>>>3){case 1:{R.name=J.string();break}case 21:{R.refAttrName=J.string();break}case 13:{R.docString=J.string();break}case 20:{R.type=J.int32();break}case 2:{R.f=J.float();break}case 3:{R.i=J.int64();break}case 4:{R.s=J.bytes();break}case 5:{R.t=Z.onnx.TensorProto.decode(J,J.uint32());break}case 6:{R.g=Z.onnx.GraphProto.decode(J,J.uint32());break}case 22:{R.sparseTensor=Z.onnx.SparseTensorProto.decode(J,J.uint32());break}case 14:{R.tp=Z.onnx.TypeProto.decode(J,J.uint32());break}case 7:{if(R.floats&&R.floats.length||(R.floats=[]),(z&7)===2)for(var Y=J.uint32()+J.pos;J.pos<Y;)R.floats.push(J.float());else R.floats.push(J.float());break}case 8:{if(R.ints&&R.ints.length||(R.ints=[]),(z&7)===2)for(var Y=J.uint32()+J.pos;J.pos<Y;)R.ints.push(J.int64());else R.ints.push(J.int64());break}case 9:{R.strings&&R.strings.length||(R.strings=[]),R.strings.push(J.bytes());break}case 10:{R.tensors&&R.tensors.length||(R.tensors=[]),R.tensors.push(Z.onnx.TensorProto.decode(J,J.uint32()));break}case 11:{R.graphs&&R.graphs.length||(R.graphs=[]),R.graphs.push(Z.onnx.GraphProto.decode(J,J.uint32()));break}case 23:{R.sparseTensors&&R.sparseTensors.length||(R.sparseTensors=[]),R.sparseTensors.push(Z.onnx.SparseTensorProto.decode(J,J.uint32()));break}case 15:{R.typeProtos&&R.typeProtos.length||(R.typeProtos=[]),R.typeProtos.push(Z.onnx.TypeProto.decode(J,J.uint32()));break}default:J.skipType(z&7);break}}return R},G.decodeDelimited=function(J){return J instanceof K||(J=new K(J)),this.decode(J,J.uint32())},G.verify=function(J){if(typeof J!="object"||J===null)return"object expected";if(J.name!=null&&J.hasOwnProperty("name")&&!U.isString(J.name))return"name: string expected";if(J.refAttrName!=null&&J.hasOwnProperty("refAttrName")&&!U.isString(J.refAttrName))return"refAttrName: string expected";if(J.docString!=null&&J.hasOwnProperty("docString")&&!U.isString(J.docString))return"docString: string expected";if(J.type!=null&&J.hasOwnProperty("type"))switch(J.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 11:case 13:case 6:case 7:case 8:case 9:case 10:case 12:case 14:break}if(J.f!=null&&J.hasOwnProperty("f")&&typeof J.f!="number")return"f: number expected";if(J.i!=null&&J.hasOwnProperty("i")&&!U.isInteger(J.i)&&!(J.i&&U.isInteger(J.i.low)&&U.isInteger(J.i.high)))return"i: integer|Long expected";if(J.s!=null&&J.hasOwnProperty("s")&&!(J.s&&typeof J.s.length=="number"||U.isString(J.s)))return"s: buffer expected";if(J.t!=null&&J.hasOwnProperty("t")){var X=Z.onnx.TensorProto.verify(J.t);if(X)return"t."+X}if(J.g!=null&&J.hasOwnProperty("g")){var X=Z.onnx.GraphProto.verify(J.g);if(X)return"g."+X}if(J.sparseTensor!=null&&J.hasOwnProperty("sparseTensor")){var X=Z.onnx.SparseTensorProto.verify(J.sparseTensor);if(X)return"sparseTensor."+X}if(J.tp!=null&&J.hasOwnProperty("tp")){var X=Z.onnx.TypeProto.verify(J.tp);if(X)return"tp."+X}if(J.floats!=null&&J.hasOwnProperty("floats")){if(!Array.isArray(J.floats))return"floats: array expected";for(var V=0;V<J.floats.length;++V)if(typeof J.floats[V]!="number")return"floats: number[] expected"}if(J.ints!=null&&J.hasOwnProperty("ints")){if(!Array.isArray(J.ints))return"ints: array expected";for(var V=0;V<J.ints.length;++V)if(!U.isInteger(J.ints[V])&&!(J.ints[V]&&U.isInteger(J.ints[V].low)&&U.isInteger(J.ints[V].high)))return"ints: integer|Long[] expected"}if(J.strings!=null&&J.hasOwnProperty("strings")){if(!Array.isArray(J.strings))return"strings: array expected";for(var V=0;V<J.strings.length;++V)if(!(J.strings[V]&&typeof J.strings[V].length=="number"||U.isString(J.strings[V])))return"strings: buffer[] expected"}if(J.tensors!=null&&J.hasOwnProperty("tensors")){if(!Array.isArray(J.tensors))return"tensors: array expected";for(var V=0;V<J.tensors.length;++V){var X=Z.onnx.TensorProto.verify(J.tensors[V]);if(X)return"tensors."+X}}if(J.graphs!=null&&J.hasOwnProperty("graphs")){if(!Array.isArray(J.graphs))return"graphs: array expected";for(var V=0;V<J.graphs.length;++V){var X=Z.onnx.GraphProto.verify(J.graphs[V]);if(X)return"graphs."+X}}if(J.sparseTensors!=null&&J.hasOwnProperty("sparseTensors")){if(!Array.isArray(J.sparseTensors))return"sparseTensors: array expected";for(var V=0;V<J.sparseTensors.length;++V){var X=Z.onnx.SparseTensorProto.verify(J.sparseTensors[V]);if(X)return"sparseTensors."+X}}if(J.typeProtos!=null&&J.hasOwnProperty("typeProtos")){if(!Array.isArray(J.typeProtos))return"typeProtos: array expected";for(var V=0;V<J.typeProtos.length;++V){var X=Z.onnx.TypeProto.verify(J.typeProtos[V]);if(X)return"typeProtos."+X}}return null},G.fromObject=function(J){if(J instanceof Z.onnx.AttributeProto)return J;var X=new Z.onnx.AttributeProto;switch(J.name!=null&&(X.name=String(J.name)),J.refAttrName!=null&&(X.refAttrName=String(J.refAttrName)),J.docString!=null&&(X.docString=String(J.docString)),J.type){default:if(typeof J.type=="number"){X.type=J.type;break}break;case"UNDEFINED":case 0:X.type=0;break;case"FLOAT":case 1:X.type=1;break;case"INT":case 2:X.type=2;break;case"STRING":case 3:X.type=3;break;case"TENSOR":case 4:X.type=4;break;case"GRAPH":case 5:X.type=5;break;case"SPARSE_TENSOR":case 11:X.type=11;break;case"TYPE_PROTO":case 13:X.type=13;break;case"FLOATS":case 6:X.type=6;break;case"INTS":case 7:X.type=7;break;case"STRINGS":case 8:X.type=8;break;case"TENSORS":case 9:X.type=9;break;case"GRAPHS":case 10:X.type=10;break;case"SPARSE_TENSORS":case 12:X.type=12;break;case"TYPE_PROTOS":case 14:X.type=14;break}if(J.f!=null&&(X.f=Number(J.f)),J.i!=null&&(U.Long?(X.i=U.Long.fromValue(J.i)).unsigned=!1:typeof J.i=="string"?X.i=parseInt(J.i,10):typeof J.i=="number"?X.i=J.i:typeof J.i=="object"&&(X.i=new U.LongBits(J.i.low>>>0,J.i.high>>>0).toNumber())),J.s!=null&&(typeof J.s=="string"?U.base64.decode(J.s,X.s=U.newBuffer(U.base64.length(J.s)),0):J.s.length>=0&&(X.s=J.s)),J.t!=null){if(typeof J.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");X.t=Z.onnx.TensorProto.fromObject(J.t)}if(J.g!=null){if(typeof J.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");X.g=Z.onnx.GraphProto.fromObject(J.g)}if(J.sparseTensor!=null){if(typeof J.sparseTensor!="object")throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");X.sparseTensor=Z.onnx.SparseTensorProto.fromObject(J.sparseTensor)}if(J.tp!=null){if(typeof J.tp!="object")throw TypeError(".onnx.AttributeProto.tp: object expected");X.tp=Z.onnx.TypeProto.fromObject(J.tp)}if(J.floats){if(!Array.isArray(J.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");X.floats=[];for(var V=0;V<J.floats.length;++V)X.floats[V]=Number(J.floats[V])}if(J.ints){if(!Array.isArray(J.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");X.ints=[];for(var V=0;V<J.ints.length;++V)U.Long?(X.ints[V]=U.Long.fromValue(J.ints[V])).unsigned=!1:typeof J.ints[V]=="string"?X.ints[V]=parseInt(J.ints[V],10):typeof J.ints[V]=="number"?X.ints[V]=J.ints[V]:typeof J.ints[V]=="object"&&(X.ints[V]=new U.LongBits(J.ints[V].low>>>0,J.ints[V].high>>>0).toNumber())}if(J.strings){if(!Array.isArray(J.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");X.strings=[];for(var V=0;V<J.strings.length;++V)typeof J.strings[V]=="string"?U.base64.decode(J.strings[V],X.strings[V]=U.newBuffer(U.base64.length(J.strings[V])),0):J.strings[V].length>=0&&(X.strings[V]=J.strings[V])}if(J.tensors){if(!Array.isArray(J.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");X.tensors=[];for(var V=0;V<J.tensors.length;++V){if(typeof J.tensors[V]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");X.tensors[V]=Z.onnx.TensorProto.fromObject(J.tensors[V])}}if(J.graphs){if(!Array.isArray(J.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");X.graphs=[];for(var V=0;V<J.graphs.length;++V){if(typeof J.graphs[V]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");X.graphs[V]=Z.onnx.GraphProto.fromObject(J.graphs[V])}}if(J.sparseTensors){if(!Array.isArray(J.sparseTensors))throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");X.sparseTensors=[];for(var V=0;V<J.sparseTensors.length;++V){if(typeof J.sparseTensors[V]!="object")throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");X.sparseTensors[V]=Z.onnx.SparseTensorProto.fromObject(J.sparseTensors[V])}}if(J.typeProtos){if(!Array.isArray(J.typeProtos))throw TypeError(".onnx.AttributeProto.typeProtos: array expected");X.typeProtos=[];for(var V=0;V<J.typeProtos.length;++V){if(typeof J.typeProtos[V]!="object")throw TypeError(".onnx.AttributeProto.typeProtos: object expected");X.typeProtos[V]=Z.onnx.TypeProto.fromObject(J.typeProtos[V])}}return X},G.toObject=function(J,X){X||(X={});var V={};if((X.arrays||X.defaults)&&(V.floats=[],V.ints=[],V.strings=[],V.tensors=[],V.graphs=[],V.typeProtos=[],V.sparseTensors=[]),X.defaults){if(V.name="",V.f=0,U.Long){var R=new U.Long(0,0,!1);V.i=X.longs===String?R.toString():X.longs===Number?R.toNumber():R}else V.i=X.longs===String?"0":0;X.bytes===String?V.s="":(V.s=[],X.bytes!==Array&&(V.s=U.newBuffer(V.s))),V.t=null,V.g=null,V.docString="",V.tp=null,V.type=X.enums===String?"UNDEFINED":0,V.refAttrName="",V.sparseTensor=null}if(J.name!=null&&J.hasOwnProperty("name")&&(V.name=J.name),J.f!=null&&J.hasOwnProperty("f")&&(V.f=X.json&&!isFinite(J.f)?String(J.f):J.f),J.i!=null&&J.hasOwnProperty("i")&&(typeof J.i=="number"?V.i=X.longs===String?String(J.i):J.i:V.i=X.longs===String?U.Long.prototype.toString.call(J.i):X.longs===Number?new U.LongBits(J.i.low>>>0,J.i.high>>>0).toNumber():J.i),J.s!=null&&J.hasOwnProperty("s")&&(V.s=X.bytes===String?U.base64.encode(J.s,0,J.s.length):X.bytes===Array?Array.prototype.slice.call(J.s):J.s),J.t!=null&&J.hasOwnProperty("t")&&(V.t=Z.onnx.TensorProto.toObject(J.t,X)),J.g!=null&&J.hasOwnProperty("g")&&(V.g=Z.onnx.GraphProto.toObject(J.g,X)),J.floats&&J.floats.length){V.floats=[];for(var z=0;z<J.floats.length;++z)V.floats[z]=X.json&&!isFinite(J.floats[z])?String(J.floats[z]):J.floats[z]}if(J.ints&&J.ints.length){V.ints=[];for(var z=0;z<J.ints.length;++z)typeof J.ints[z]=="number"?V.ints[z]=X.longs===String?String(J.ints[z]):J.ints[z]:V.ints[z]=X.longs===String?U.Long.prototype.toString.call(J.ints[z]):X.longs===Number?new U.LongBits(J.ints[z].low>>>0,J.ints[z].high>>>0).toNumber():J.ints[z]}if(J.strings&&J.strings.length){V.strings=[];for(var z=0;z<J.strings.length;++z)V.strings[z]=X.bytes===String?U.base64.encode(J.strings[z],0,J.strings[z].length):X.bytes===Array?Array.prototype.slice.call(J.strings[z]):J.strings[z]}if(J.tensors&&J.tensors.length){V.tensors=[];for(var z=0;z<J.tensors.length;++z)V.tensors[z]=Z.onnx.TensorProto.toObject(J.tensors[z],X)}if(J.graphs&&J.graphs.length){V.graphs=[];for(var z=0;z<J.graphs.length;++z)V.graphs[z]=Z.onnx.GraphProto.toObject(J.graphs[z],X)}if(J.docString!=null&&J.hasOwnProperty("docString")&&(V.docString=J.docString),J.tp!=null&&J.hasOwnProperty("tp")&&(V.tp=Z.onnx.TypeProto.toObject(J.tp,X)),J.typeProtos&&J.typeProtos.length){V.typeProtos=[];for(var z=0;z<J.typeProtos.length;++z)V.typeProtos[z]=Z.onnx.TypeProto.toObject(J.typeProtos[z],X)}if(J.type!=null&&J.hasOwnProperty("type")&&(V.type=X.enums===String?Z.onnx.AttributeProto.AttributeType[J.type]===void 0?J.type:Z.onnx.AttributeProto.AttributeType[J.type]:J.type),J.refAttrName!=null&&J.hasOwnProperty("refAttrName")&&(V.refAttrName=J.refAttrName),J.sparseTensor!=null&&J.hasOwnProperty("sparseTensor")&&(V.sparseTensor=Z.onnx.SparseTensorProto.toObject(J.sparseTensor,X)),J.sparseTensors&&J.sparseTensors.length){V.sparseTensors=[];for(var z=0;z<J.sparseTensors.length;++z)V.sparseTensors[z]=Z.onnx.SparseTensorProto.toObject(J.sparseTensors[z],X)}return V},G.prototype.toJSON=function(){return this.constructor.toObject(this,j.util.toJSONOptions)},G.getTypeUrl=function(J){return J===void 0&&(J="type.googleapis.com"),J+"/onnx.AttributeProto"},G.AttributeType=function(){var J={},X=Object.create(J);return X[J[0]="UNDEFINED"]=0,X[J[1]="FLOAT"]=1,X[J[2]="INT"]=2,X[J[3]="STRING"]=3,X[J[4]="TENSOR"]=4,X[J[5]="GRAPH"]=5,X[J[11]="SPARSE_TENSOR"]=11,X[J[13]="TYPE_PROTO"]=13,X[J[6]="FLOATS"]=6,X[J[7]="INTS"]=7,X[J[8]="STRINGS"]=8,X[J[9]="TENSORS"]=9,X[J[10]="GRAPHS"]=10,X[J[12]="SPARSE_TENSORS"]=12,X[J[14]="TYPE_PROTOS"]=14,X}(),G}(),q.ValueInfoProto=function(){function G(J){if(J)for(var X=Object.keys(J),V=0;V<X.length;++V)J[X[V]]!=null&&(this[X[V]]=J[X[V]])}return G.prototype.name="",G.prototype.type=null,G.prototype.docString="",G.create=function(J){return new G(J)},G.encode=function(J,X){return X||(X=W.create()),J.name!=null&&Object.hasOwnProperty.call(J,"name")&&X.uint32(10).string(J.name),J.type!=null&&Object.hasOwnProperty.call(J,"type")&&Z.onnx.TypeProto.encode(J.type,X.uint32(18).fork()).ldelim(),J.docString!=null&&Object.hasOwnProperty.call(J,"docString")&&X.uint32(26).string(J.docString),X},G.encodeDelimited=function(J,X){return this.encode(J,X).ldelim()},G.decode=function(J,X){J instanceof K||(J=K.create(J));for(var V=X===void 0?J.len:J.pos+X,R=new Z.onnx.ValueInfoProto;J.pos<V;){var z=J.uint32();switch(z>>>3){case 1:{R.name=J.string();break}case 2:{R.type=Z.onnx.TypeProto.decode(J,J.uint32());break}case 3:{R.docString=J.string();break}default:J.skipType(z&7);break}}return R},G.decodeDelimited=function(J){return J instanceof K||(J=new K(J)),this.decode(J,J.uint32())},G.verify=function(J){if(typeof J!="object"||J===null)return"object expected";if(J.name!=null&&J.hasOwnProperty("name")&&!U.isString(J.name))return"name: string expected";if(J.type!=null&&J.hasOwnProperty("type")){var X=Z.onnx.TypeProto.verify(J.type);if(X)return"type."+X}return J.docString!=null&&J.hasOwnProperty("docString")&&!U.isString(J.docString)?"docString: string expected":null},G.fromObject=function(J){if(J instanceof Z.onnx.ValueInfoProto)return J;var X=new Z.onnx.ValueInfoProto;if(J.name!=null&&(X.name=String(J.name)),J.type!=null){if(typeof J.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");X.type=Z.onnx.TypeProto.fromObject(J.type)}return J.docString!=null&&(X.docString=String(J.docString)),X},G.toObject=function(J,X){X||(X={});var V={};return X.defaults&&(V.name="",V.type=null,V.docString=""),J.name!=null&&J.hasOwnProperty("name")&&(V.name=J.name),J.type!=null&&J.hasOwnProperty("type")&&(V.type=Z.onnx.TypeProto.toObject(J.type,X)),J.docString!=null&&J.hasOwnProperty("docString")&&(V.docString=J.docString),V},G.prototype.toJSON=function(){return this.constructor.toObject(this,j.util.toJSONOptions)},G.getTypeUrl=function(J){return J===void 0&&(J="type.googleapis.com"),J+"/onnx.ValueInfoProto"},G}(),q.NodeProto=function(){function G(J){if(this.input=[],this.output=[],this.attribute=[],J)for(var X=Object.keys(J),V=0;V<X.length;++V)J[X[V]]!=null&&(this[X[V]]=J[X[V]])}return G.prototype.input=U.emptyArray,G.prototype.output=U.emptyArray,G.prototype.name="",G.prototype.opType="",G.prototype.domain="",G.prototype.attribute=U.emptyArray,G.prototype.docString="",G.create=function(J){return new G(J)},G.encode=function(J,X){if(X||(X=W.create()),J.input!=null&&J.input.length)for(var V=0;V<J.input.length;++V)X.uint32(10).string(J.input[V]);if(J.output!=null&&J.output.length)for(var V=0;V<J.output.length;++V)X.uint32(18).string(J.output[V]);if(J.name!=null&&Object.hasOwnProperty.call(J,"name")&&X.uint32(26).string(J.name),J.opType!=null&&Object.hasOwnProperty.call(J,"opType")&&X.uint32(34).string(J.opType),J.attribute!=null&&J.attribute.length)for(var V=0;V<J.attribute.length;++V)Z.onnx.AttributeProto.encode(J.attribute[V],X.uint32(42).fork()).ldelim();return J.docString!=null&&Object.hasOwnProperty.call(J,"docString")&&X.uint32(50).string(J.docString),J.domain!=null&&Object.hasOwnProperty.call(J,"domain")&&X.uint32(58).string(J.domain),X},G.encodeDelimited=function(J,X){return this.encode(J,X).ldelim()},G.decode=function(J,X){J instanceof K||(J=K.create(J));for(var V=X===void 0?J.len:J.pos+X,R=new Z.onnx.NodeProto;J.pos<V;){var z=J.uint32();switch(z>>>3){case 1:{R.input&&R.input.length||(R.input=[]),R.input.push(J.string());break}case 2:{R.output&&R.output.length||(R.output=[]),R.output.push(J.string());break}case 3:{R.name=J.string();break}case 4:{R.opType=J.string();break}case 7:{R.domain=J.string();break}case 5:{R.attribute&&R.attribute.length||(R.attribute=[]),R.attribute.push(Z.onnx.AttributeProto.decode(J,J.uint32()));break}case 6:{R.docString=J.string();break}default:J.skipType(z&7);break}}return R},G.decodeDelimited=function(J){return J instanceof K||(J=new K(J)),this.decode(J,J.uint32())},G.verify=function(J){if(typeof J!="object"||J===null)return"object expected";if(J.input!=null&&J.hasOwnProperty("input")){if(!Array.isArray(J.input))return"input: array expected";for(var X=0;X<J.input.length;++X)if(!U.isString(J.input[X]))return"input: string[] expected"}if(J.output!=null&&J.hasOwnProperty("output")){if(!Array.isArray(J.output))return"output: array expected";for(var X=0;X<J.output.length;++X)if(!U.isString(J.output[X]))return"output: string[] expected"}if(J.name!=null&&J.hasOwnProperty("name")&&!U.isString(J.name))return"name: string expected";if(J.opType!=null&&J.hasOwnProperty("opType")&&!U.isString(J.opType))return"opType: string expected";if(J.domain!=null&&J.hasOwnProperty("domain")&&!U.isString(J.domain))return"domain: string expected";if(J.attribute!=null&&J.hasOwnProperty("attribute")){if(!Array.isArray(J.attribute))return"attribute: array expected";for(var X=0;X<J.attribute.length;++X){var V=Z.onnx.AttributeProto.verify(J.attribute[X]);if(V)return"attribute."+V}}return J.docString!=null&&J.hasOwnProperty("docString")&&!U.isString(J.docString)?"docString: string expected":null},G.fromObject=function(J){if(J instanceof Z.onnx.NodeProto)return J;var X=new Z.onnx.NodeProto;if(J.input){if(!Array.isArray(J.input))throw TypeError(".onnx.NodeProto.input: array expected");X.input=[];for(var V=0;V<J.input.length;++V)X.input[V]=String(J.input[V])}if(J.output){if(!Array.isArray(J.output))throw TypeError(".onnx.NodeProto.output: array expected");X.output=[];for(var V=0;V<J.output.length;++V)X.output[V]=String(J.output[V])}if(J.name!=null&&(X.name=String(J.name)),J.opType!=null&&(X.opType=String(J.opType)),J.domain!=null&&(X.domain=String(J.domain)),J.attribute){if(!Array.isArray(J.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");X.attribute=[];for(var V=0;V<J.attribute.length;++V){if(typeof J.attribute[V]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");X.attribute[V]=Z.onnx.AttributeProto.fromObject(J.attribute[V])}}return J.docString!=null&&(X.docString=String(J.docString)),X},G.toObject=function(J,X){X||(X={});var V={};if((X.arrays||X.defaults)&&(V.input=[],V.output=[],V.attribute=[]),X.defaults&&(V.name="",V.opType="",V.docString="",V.domain=""),J.input&&J.input.length){V.input=[];for(var R=0;R<J.input.length;++R)V.input[R]=J.input[R]}if(J.output&&J.output.length){V.output=[];for(var R=0;R<J.output.length;++R)V.output[R]=J.output[R]}if(J.name!=null&&J.hasOwnProperty("name")&&(V.name=J.name),J.opType!=null&&J.hasOwnProperty("opType")&&(V.opType=J.opType),J.attribute&&J.attribute.length){V.attribute=[];for(var R=0;R<J.attribute.length;++R)V.attribute[R]=Z.onnx.AttributeProto.toObject(J.attribute[R],X)}return J.docString!=null&&J.hasOwnProperty("docString")&&(V.docString=J.docString),J.domain!=null&&J.hasOwnProperty("domain")&&(V.domain=J.domain),V},G.prototype.toJSON=function(){return this.constructor.toObject(this,j.util.toJSONOptions)},G.getTypeUrl=function(J){return J===void 0&&(J="type.googleapis.com"),J+"/onnx.NodeProto"},G}(),q.TrainingInfoProto=function(){function G(J){if(this.initializationBinding=[],this.updateBinding=[],J)for(var X=Object.keys(J),V=0;V<X.length;++V)J[X[V]]!=null&&(this[X[V]]=J[X[V]])}return G.prototype.initialization=null,G.prototype.algorithm=null,G.prototype.initializationBinding=U.emptyArray,G.prototype.updateBinding=U.emptyArray,G.create=function(J){return new G(J)},G.encode=function(J,X){if(X||(X=W.create()),J.initialization!=null&&Object.hasOwnProperty.call(J,"initialization")&&Z.onnx.GraphProto.encode(J.initialization,X.uint32(10).fork()).ldelim(),J.algorithm!=null&&Object.hasOwnProperty.call(J,"algorithm")&&Z.onnx.GraphProto.encode(J.algorithm,X.uint32(18).fork()).ldelim(),J.initializationBinding!=null&&J.initializationBinding.length)for(var V=0;V<J.initializationBinding.length;++V)Z.onnx.StringStringEntryProto.encode(J.initializationBinding[V],X.uint32(26).fork()).ldelim();if(J.updateBinding!=null&&J.updateBinding.length)for(var V=0;V<J.updateBinding.length;++V)Z.onnx.StringStringEntryProto.encode(J.updateBinding[V],X.uint32(34).fork()).ldelim();return X},G.encodeDelimited=function(J,X){return this.encode(J,X).ldelim()},G.decode=function(J,X){J instanceof K||(J=K.create(J));for(var V=X===void 0?J.len:J.pos+X,R=new Z.onnx.TrainingInfoProto;J.pos<V;){var z=J.uint32();switch(z>>>3){case 1:{R.initialization=Z.onnx.GraphProto.decode(J,J.uint32());break}case 2:{R.algorithm=Z.onnx.GraphProto.decode(J,J.uint32());break}case 3:{R.initializationBinding&&R.initializationBinding.length||(R.initializationBinding=[]),R.initializationBinding.push(Z.onnx.StringStringEntryProto.decode(J,J.uint32()));break}case 4:{R.updateBinding&&R.updateBinding.length||(R.updateBinding=[]),R.updateBinding.push(Z.onnx.StringStringEntryProto.decode(J,J.uint32()));break}default:J.skipType(z&7);break}}return R},G.decodeDelimited=function(J){return J instanceof K||(J=new K(J)),this.decode(J,J.uint32())},G.verify=function(J){if(typeof J!="object"||J===null)return"object expected";if(J.initialization!=null&&J.hasOwnProperty("initialization")){var X=Z.onnx.GraphProto.verify(J.initialization);if(X)return"initialization."+X}if(J.algorithm!=null&&J.hasOwnProperty("algorithm")){var X=Z.onnx.GraphProto.verify(J.algorithm);if(X)return"algorithm."+X}if(J.initializationBinding!=null&&J.hasOwnProperty("initializationBinding")){if(!Array.isArray(J.initializationBinding))return"initializationBinding: array expected";for(var V=0;V<J.initializationBinding.length;++V){var X=Z.onnx.StringStringEntryProto.verify(J.initializationBinding[V]);if(X)return"initializationBinding."+X}}if(J.updateBinding!=null&&J.hasOwnProperty("updateBinding")){if(!Array.isArray(J.updateBinding))return"updateBinding: array expected";for(var V=0;V<J.updateBinding.length;++V){var X=Z.onnx.StringStringEntryProto.verify(J.updateBinding[V]);if(X)return"updateBinding."+X}}return null},G.fromObject=function(J){if(J instanceof Z.onnx.TrainingInfoProto)return J;var X=new Z.onnx.TrainingInfoProto;if(J.initialization!=null){if(typeof J.initialization!="object")throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");X.initialization=Z.onnx.GraphProto.fromObject(J.initialization)}if(J.algorithm!=null){if(typeof J.algorithm!="object")throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");X.algorithm=Z.onnx.GraphProto.fromObject(J.algorithm)}if(J.initializationBinding){if(!Array.isArray(J.initializationBinding))throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");X.initializationBinding=[];for(var V=0;V<J.initializationBinding.length;++V){if(typeof J.initializationBinding[V]!="object")throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");X.initializationBinding[V]=Z.onnx.StringStringEntryProto.fromObject(J.initializationBinding[V])}}if(J.updateBinding){if(!Array.isArray(J.updateBinding))throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");X.updateBinding=[];for(var V=0;V<J.updateBinding.length;++V){if(typeof J.updateBinding[V]!="object")throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");X.updateBinding[V]=Z.onnx.StringStringEntryProto.fromObject(J.updateBinding[V])}}return X},G.toObject=function(J,X){X||(X={});var V={};if((X.arrays||X.defaults)&&(V.initializationBinding=[],V.updateBinding=[]),X.defaults&&(V.initialization=null,V.algorithm=null),J.initialization!=null&&J.hasOwnProperty("initialization")&&(V.initialization=Z.onnx.GraphProto.toObject(J.initialization,X)),J.algorithm!=null&&J.hasOwnProperty("algorithm")&&(V.algorithm=Z.onnx.GraphProto.toObject(J.algorithm,X)),J.initializationBinding&&J.initializationBinding.length){V.initializationBinding=[];for(var R=0;R<J.initializationBinding.length;++R)V.initializationBinding[R]=Z.onnx.StringStringEntryProto.toObject(J.initializationBinding[R],X)}if(J.updateBinding&&J.updateBinding.length){V.updateBinding=[];for(var R=0;R<J.updateBinding.length;++R)V.updateBinding[R]=Z.onnx.StringStringEntryProto.toObject(J.updateBinding[R],X)}return V},G.prototype.toJSON=function(){return this.constructor.toObject(this,j.util.toJSONOptions)},G.getTypeUrl=function(J){return J===void 0&&(J="type.googleapis.com"),J+"/onnx.TrainingInfoProto"},G}(),q.ModelProto=function(){function G(J){if(this.opsetImport=[],this.metadataProps=[],this.trainingInfo=[],this.functions=[],J)for(var X=Object.keys(J),V=0;V<X.length;++V)J[X[V]]!=null&&(this[X[V]]=J[X[V]])}return G.prototype.irVersion=U.Long?U.Long.fromBits(0,0,!1):0,G.prototype.opsetImport=U.emptyArray,G.prototype.producerName="",G.prototype.producerVersion="",G.prototype.domain="",G.prototype.modelVersion=U.Long?U.Long.fromBits(0,0,!1):0,G.prototype.docString="",G.prototype.graph=null,G.prototype.metadataProps=U.emptyArray,G.prototype.trainingInfo=U.emptyArray,G.prototype.functions=U.emptyArray,G.create=function(J){return new G(J)},G.encode=function(J,X){if(X||(X=W.create()),J.irVersion!=null&&Object.hasOwnProperty.call(J,"irVersion")&&X.uint32(8).int64(J.irVersion),J.producerName!=null&&Object.hasOwnProperty.call(J,"producerName")&&X.uint32(18).string(J.producerName),J.producerVersion!=null&&Object.hasOwnProperty.call(J,"producerVersion")&&X.uint32(26).string(J.producerVersion),J.domain!=null&&Object.hasOwnProperty.call(J,"domain")&&X.uint32(34).string(J.domain),J.modelVersion!=null&&Object.hasOwnProperty.call(J,"modelVersion")&&X.uint32(40).int64(J.modelVersion),J.docString!=null&&Object.hasOwnProperty.call(J,"docString")&&X.uint32(50).string(J.docString),J.graph!=null&&Object.hasOwnProperty.call(J,"graph")&&Z.onnx.GraphProto.encode(J.graph,X.uint32(58).fork()).ldelim(),J.opsetImport!=null&&J.opsetImport.length)for(var V=0;V<J.opsetImport.length;++V)Z.onnx.OperatorSetIdProto.encode(J.opsetImport[V],X.uint32(66).fork()).ldelim();if(J.metadataProps!=null&&J.metadataProps.length)for(var V=0;V<J.metadataProps.length;++V)Z.onnx.StringStringEntryProto.encode(J.metadataProps[V],X.uint32(114).fork()).ldelim();if(J.trainingInfo!=null&&J.trainingInfo.length)for(var V=0;V<J.trainingInfo.length;++V)Z.onnx.TrainingInfoProto.encode(J.trainingInfo[V],X.uint32(162).fork()).ldelim();if(J.functions!=null&&J.functions.length)for(var V=0;V<J.functions.length;++V)Z.onnx.FunctionProto.encode(J.functions[V],X.uint32(202).fork()).ldelim();return X},G.encodeDelimited=function(J,X){return this.encode(J,X).ldelim()},G.decode=function(J,X){J instanceof K||(J=K.create(J));for(var V=X===void 0?J.len:J.pos+X,R=new Z.onnx.ModelProto;J.pos<V;){var z=J.uint32();switch(z>>>3){case 1:{R.irVersion=J.int64();break}case 8:{R.opsetImport&&R.opsetImport.length||(R.opsetImport=[]),R.opsetImport.push(Z.onnx.OperatorSetIdProto.decode(J,J.uint32()));break}case 2:{R.producerName=J.string();break}case 3:{R.producerVersion=J.string();break}case 4:{R.domain=J.string();break}case 5:{R.modelVersion=J.int64();break}case 6:{R.docString=J.string();break}case 7:{R.graph=Z.onnx.GraphProto.decode(J,J.uint32());break}case 14:{R.metadataProps&&R.metadataProps.length||(R.metadataProps=[]),R.metadataProps.push(Z.onnx.StringStringEntryProto.decode(J,J.uint32()));break}case 20:{R.trainingInfo&&R.trainingInfo.length||(R.trainingInfo=[]),R.trainingInfo.push(Z.onnx.TrainingInfoProto.decode(J,J.uint32()));break}case 25:{R.functions&&R.functions.length||(R.functions=[]),R.functions.push(Z.onnx.FunctionProto.decode(J,J.uint32()));break}default:J.skipType(z&7);break}}return R},G.decodeDelimited=function(J){return J instanceof K||(J=new K(J)),this.decode(J,J.uint32())},G.verify=function(J){if(typeof J!="object"||J===null)return"object expected";if(J.irVersion!=null&&J.hasOwnProperty("irVersion")&&!U.isInteger(J.irVersion)&&!(J.irVersion&&U.isInteger(J.irVersion.low)&&U.isInteger(J.irVersion.high)))return"irVersion: integer|Long expected";if(J.opsetImport!=null&&J.hasOwnProperty("opsetImport")){if(!Array.isArray(J.opsetImport))return"opsetImport: array expected";for(var X=0;X<J.opsetImport.length;++X){var V=Z.onnx.OperatorSetIdProto.verify(J.opsetImport[X]);if(V)return"opsetImport."+V}}if(J.producerName!=null&&J.hasOwnProperty("producerName")&&!U.isString(J.producerName))return"producerName: string expected";if(J.producerVersion!=null&&J.hasOwnProperty("producerVersion")&&!U.isString(J.producerVersion))return"producerVersion: string expected";if(J.domain!=null&&J.hasOwnProperty("domain")&&!U.isString(J.domain))return"domain: string expected";if(J.modelVersion!=null&&J.hasOwnProperty("modelVersion")&&!U.isInteger(J.modelVersion)&&!(J.modelVersion&&U.isInteger(J.modelVersion.low)&&U.isInteger(J.modelVersion.high)))return"modelVersion: integer|Long expected";if(J.docString!=null&&J.hasOwnProperty("docString")&&!U.isString(J.docString))return"docString: string expected";if(J.graph!=null&&J.hasOwnProperty("graph")){var V=Z.onnx.GraphProto.verify(J.graph);if(V)return"graph."+V}if(J.metadataProps!=null&&J.hasOwnProperty("metadataProps")){if(!Array.isArray(J.metadataProps))return"metadataProps: array expected";for(var X=0;X<J.metadataProps.length;++X){var V=Z.onnx.StringStringEntryProto.verify(J.metadataProps[X]);if(V)return"metadataProps."+V}}if(J.trainingInfo!=null&&J.hasOwnProperty("trainingInfo")){if(!Array.isArray(J.trainingInfo))return"trainingInfo: array expected";for(var X=0;X<J.trainingInfo.length;++X){var V=Z.onnx.TrainingInfoProto.verify(J.trainingInfo[X]);if(V)return"trainingInfo."+V}}if(J.functions!=null&&J.hasOwnProperty("functions")){if(!Array.isArray(J.functions))return"functions: array expected";for(var X=0;X<J.functions.length;++X){var V=Z.onnx.FunctionProto.verify(J.functions[X]);if(V)return"functions."+V}}return null},G.fromObject=function(J){if(J instanceof Z.onnx.ModelProto)return J;var X=new Z.onnx.ModelProto;if(J.irVersion!=null&&(U.Long?(X.irVersion=U.Long.fromValue(J.irVersion)).unsigned=!1:typeof J.irVersion=="string"?X.irVersion=parseInt(J.irVersion,10):typeof J.irVersion=="number"?X.irVersion=J.irVersion:typeof J.irVersion=="object"&&(X.irVersion=new U.LongBits(J.irVersion.low>>>0,J.irVersion.high>>>0).toNumber())),J.opsetImport){if(!Array.isArray(J.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");X.opsetImport=[];for(var V=0;V<J.opsetImport.length;++V){if(typeof J.opsetImport[V]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");X.opsetImport[V]=Z.onnx.OperatorSetIdProto.fromObject(J.opsetImport[V])}}if(J.producerName!=null&&(X.producerName=String(J.producerName)),J.producerVersion!=null&&(X.producerVersion=String(J.producerVersion)),J.domain!=null&&(X.domain=String(J.domain)),J.modelVersion!=null&&(U.Long?(X.modelVersion=U.Long.fromValue(J.modelVersion)).unsigned=!1:typeof J.modelVersion=="string"?X.modelVersion=parseInt(J.modelVersion,10):typeof J.modelVersion=="number"?X.modelVersion=J.modelVersion:typeof J.modelVersion=="object"&&(X.modelVersion=new U.LongBits(J.modelVersion.low>>>0,J.modelVersion.high>>>0).toNumber())),J.docString!=null&&(X.docString=String(J.docString)),J.graph!=null){if(typeof J.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");X.graph=Z.onnx.GraphProto.fromObject(J.graph)}if(J.metadataProps){if(!Array.isArray(J.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");X.metadataProps=[];for(var V=0;V<J.metadataProps.length;++V){if(typeof J.metadataProps[V]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");X.metadataProps[V]=Z.onnx.StringStringEntryProto.fromObject(J.metadataProps[V])}}if(J.trainingInfo){if(!Array.isArray(J.trainingInfo))throw TypeError(".onnx.ModelProto.trainingInfo: array expected");X.trainingInfo=[];for(var V=0;V<J.trainingInfo.length;++V){if(typeof J.trainingInfo[V]!="object")throw TypeError(".onnx.ModelProto.trainingInfo: object expected");X.trainingInfo[V]=Z.onnx.TrainingInfoProto.fromObject(J.trainingInfo[V])}}if(J.functions){if(!Array.isArray(J.functions))throw TypeError(".onnx.ModelProto.functions: array expected");X.functions=[];for(var V=0;V<J.functions.length;++V){if(typeof J.functions[V]!="object")throw TypeError(".onnx.ModelProto.functions: object expected");X.functions[V]=Z.onnx.FunctionProto.fromObject(J.functions[V])}}return X},G.toObject=function(J,X){X||(X={});var V={};if((X.arrays||X.defaults)&&(V.opsetImport=[],V.metadataProps=[],V.trainingInfo=[],V.functions=[]),X.defaults){if(U.Long){var R=new U.Long(0,0,!1);V.irVersion=X.longs===String?R.toString():X.longs===Number?R.toNumber():R}else V.irVersion=X.longs===String?"0":0;if(V.producerName="",V.producerVersion="",V.domain="",U.Long){var R=new U.Long(0,0,!1);V.modelVersion=X.longs===String?R.toString():X.longs===Number?R.toNumber():R}else V.modelVersion=X.longs===String?"0":0;V.docString="",V.graph=null}if(J.irVersion!=null&&J.hasOwnProperty("irVersion")&&(typeof J.irVersion=="number"?V.irVersion=X.longs===String?String(J.irVersion):J.irVersion:V.irVersion=X.longs===String?U.Long.prototype.toString.call(J.irVersion):X.longs===Number?new U.LongBits(J.irVersion.low>>>0,J.irVersion.high>>>0).toNumber():J.irVersion),J.producerName!=null&&J.hasOwnProperty("producerName")&&(V.producerName=J.producerName),J.producerVersion!=null&&J.hasOwnProperty("producerVersion")&&(V.producerVersion=J.producerVersion),J.domain!=null&&J.hasOwnProperty("domain")&&(V.domain=J.domain),J.modelVersion!=null&&J.hasOwnProperty("modelVersion")&&(typeof J.modelVersion=="number"?V.modelVersion=X.longs===String?String(J.modelVersion):J.modelVersion:V.modelVersion=X.longs===String?U.Long.prototype.toString.call(J.modelVersion):X.longs===Number?new U.LongBits(J.modelVersion.low>>>0,J.modelVersion.high>>>0).toNumber():J.modelVersion),J.docString!=null&&J.hasOwnProperty("docString")&&(V.docString=J.docString),J.graph!=null&&J.hasOwnProperty("graph")&&(V.graph=Z.onnx.GraphProto.toObject(J.graph,X)),J.opsetImport&&J.opsetImport.length){V.opsetImport=[];for(var z=0;z<J.opsetImport.length;++z)V.opsetImport[z]=Z.onnx.OperatorSetIdProto.toObject(J.opsetImport[z],X)}if(J.metadataProps&&J.metadataProps.length){V.metadataProps=[];for(var z=0;z<J.metadataProps.length;++z)V.metadataProps[z]=Z.onnx.StringStringEntryProto.toObject(J.metadataProps[z],X)}if(J.trainingInfo&&J.trainingInfo.length){V.trainingInfo=[];for(var z=0;z<J.trainingInfo.length;++z)V.trainingInfo[z]=Z.onnx.TrainingInfoProto.toObject(J.trainingInfo[z],X)}if(J.functions&&J.functions.length){V.functions=[];for(var z=0;z<J.functions.length;++z)V.functions[z]=Z.onnx.FunctionProto.toObject(J.functions[z],X)}return V},G.prototype.toJSON=function(){return this.constructor.toObject(this,j.util.toJSONOptions)},G.getTypeUrl=function(J){return J===void 0&&(J="type.googleapis.com"),J+"/onnx.ModelProto"},G}(),q.StringStringEntryProto=function(){function G(J){if(J)for(var X=Object.keys(J),V=0;V<X.length;++V)J[X[V]]!=null&&(this[X[V]]=J[X[V]])}return G.prototype.key="",G.prototype.value="",G.create=function(J){return new G(J)},G.encode=function(J,X){return X||(X=W.create()),J.key!=null&&Object.hasOwnProperty.call(J,"key")&&X.uint32(10).string(J.key),J.value!=null&&Object.hasOwnProperty.call(J,"value")&&X.uint32(18).string(J.value),X},G.encodeDelimited=function(J,X){return this.encode(J,X).ldelim()},G.decode=function(J,X){J instanceof K||(J=K.create(J));for(var V=X===void 0?J.len:J.pos+X,R=new Z.onnx.StringStringEntryProto;J.pos<V;){var z=J.uint32();switch(z>>>3){case 1:{R.key=J.string();break}case 2:{R.value=J.string();break}default:J.skipType(z&7);break}}return R},G.decodeDelimited=function(J){return J instanceof K||(J=new K(J)),this.decode(J,J.uint32())},G.verify=function(J){return typeof J!="object"||J===null?"object expected":J.key!=null&&J.hasOwnProperty("key")&&!U.isString(J.key)?"key: string expected":J.value!=null&&J.hasOwnProperty("value")&&!U.isString(J.value)?"value: string expected":null},G.fromObject=function(J){if(J instanceof Z.onnx.StringStringEntryProto)return J;var X=new Z.onnx.StringStringEntryProto;return J.key!=null&&(X.key=String(J.key)),J.value!=null&&(X.value=String(J.value)),X},G.toObject=function(J,X){X||(X={});var V={};return X.defaults&&(V.key="",V.value=""),J.key!=null&&J.hasOwnProperty("key")&&(V.key=J.key),J.value!=null&&J.hasOwnProperty("value")&&(V.value=J.value),V},G.prototype.toJSON=function(){return this.constructor.toObject(this,j.util.toJSONOptions)},G.getTypeUrl=function(J){return J===void 0&&(J="type.googleapis.com"),J+"/onnx.StringStringEntryProto"},G}(),q.TensorAnnotation=function(){function G(J){if(this.quantParameterTensorNames=[],J)for(var X=Object.keys(J),V=0;V<X.length;++V)J[X[V]]!=null&&(this[X[V]]=J[X[V]])}return G.prototype.tensorName="",G.prototype.quantParameterTensorNames=U.emptyArray,G.create=function(J){return new G(J)},G.encode=function(J,X){if(X||(X=W.create()),J.tensorName!=null&&Object.hasOwnProperty.call(J,"tensorName")&&X.uint32(10).string(J.tensorName),J.quantParameterTensorNames!=null&&J.quantParameterTensorNames.length)for(var V=0;V<J.quantParameterTensorNames.length;++V)Z.onnx.StringStringEntryProto.encode(J.quantParameterTensorNames[V],X.uint32(18).fork()).ldelim();return X},G.encodeDelimited=function(J,X){return this.encode(J,X).ldelim()},G.decode=function(J,X){J instanceof K||(J=K.create(J));for(var V=X===void 0?J.len:J.pos+X,R=new Z.onnx.TensorAnnotation;J.pos<V;){var z=J.uint32();switch(z>>>3){case 1:{R.tensorName=J.string();break}case 2:{R.quantParameterTensorNames&&R.quantParameterTensorNames.length||(R.quantParameterTensorNames=[]),R.quantParameterTensorNames.push(Z.onnx.StringStringEntryProto.decode(J,J.uint32()));break}default:J.skipType(z&7);break}}return R},G.decodeDelimited=function(J){return J instanceof K||(J=new K(J)),this.decode(J,J.uint32())},G.verify=function(J){if(typeof J!="object"||J===null)return"object expected";if(J.tensorName!=null&&J.hasOwnProperty("tensorName")&&!U.isString(J.tensorName))return"tensorName: string expected";if(J.quantParameterTensorNames!=null&&J.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(J.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var X=0;X<J.quantParameterTensorNames.length;++X){var V=Z.onnx.StringStringEntryProto.verify(J.quantParameterTensorNames[X]);if(V)return"quantParameterTensorNames."+V}}return null},G.fromObject=function(J){if(J instanceof Z.onnx.TensorAnnotation)return J;var X=new Z.onnx.TensorAnnotation;if(J.tensorName!=null&&(X.tensorName=String(J.tensorName)),J.quantParameterTensorNames){if(!Array.isArray(J.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");X.quantParameterTensorNames=[];for(var V=0;V<J.quantParameterTensorNames.length;++V){if(typeof J.quantParameterTensorNames[V]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");X.quantParameterTensorNames[V]=Z.onnx.StringStringEntryProto.fromObject(J.quantParameterTensorNames[V])}}return X},G.toObject=function(J,X){X||(X={});var V={};if((X.arrays||X.defaults)&&(V.quantParameterTensorNames=[]),X.defaults&&(V.tensorName=""),J.tensorName!=null&&J.hasOwnProperty("tensorName")&&(V.tensorName=J.tensorName),J.quantParameterTensorNames&&J.quantParameterTensorNames.length){V.quantParameterTensorNames=[];for(var R=0;R<J.quantParameterTensorNames.length;++R)V.quantParameterTensorNames[R]=Z.onnx.StringStringEntryProto.toObject(J.quantParameterTensorNames[R],X)}return V},G.prototype.toJSON=function(){return this.constructor.toObject(this,j.util.toJSONOptions)},G.getTypeUrl=function(J){return J===void 0&&(J="type.googleapis.com"),J+"/onnx.TensorAnnotation"},G}(),q.GraphProto=function(){function G(J){if(this.node=[],this.initializer=[],this.sparseInitializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],J)for(var X=Object.keys(J),V=0;V<X.length;++V)J[X[V]]!=null&&(this[X[V]]=J[X[V]])}return G.prototype.node=U.emptyArray,G.prototype.name="",G.prototype.initializer=U.emptyArray,G.prototype.sparseInitializer=U.emptyArray,G.prototype.docString="",G.prototype.input=U.emptyArray,G.prototype.output=U.emptyArray,G.prototype.valueInfo=U.emptyArray,G.prototype.quantizationAnnotation=U.emptyArray,G.create=function(J){return new G(J)},G.encode=function(J,X){if(X||(X=W.create()),J.node!=null&&J.node.length)for(var V=0;V<J.node.length;++V)Z.onnx.NodeProto.encode(J.node[V],X.uint32(10).fork()).ldelim();if(J.name!=null&&Object.hasOwnProperty.call(J,"name")&&X.uint32(18).string(J.name),J.initializer!=null&&J.initializer.length)for(var V=0;V<J.initializer.length;++V)Z.onnx.TensorProto.encode(J.initializer[V],X.uint32(42).fork()).ldelim();if(J.docString!=null&&Object.hasOwnProperty.call(J,"docString")&&X.uint32(82).string(J.docString),J.input!=null&&J.input.length)for(var V=0;V<J.input.length;++V)Z.onnx.ValueInfoProto.encode(J.input[V],X.uint32(90).fork()).ldelim();if(J.output!=null&&J.output.length)for(var V=0;V<J.output.length;++V)Z.onnx.ValueInfoProto.encode(J.output[V],X.uint32(98).fork()).ldelim();if(J.valueInfo!=null&&J.valueInfo.length)for(var V=0;V<J.valueInfo.length;++V)Z.onnx.ValueInfoProto.encode(J.valueInfo[V],X.uint32(106).fork()).ldelim();if(J.quantizationAnnotation!=null&&J.quantizationAnnotation.length)for(var V=0;V<J.quantizationAnnotation.length;++V)Z.onnx.TensorAnnotation.encode(J.quantizationAnnotation[V],X.uint32(114).fork()).ldelim();if(J.sparseInitializer!=null&&J.sparseInitializer.length)for(var V=0;V<J.sparseInitializer.length;++V)Z.onnx.SparseTensorProto.encode(J.sparseInitializer[V],X.uint32(122).fork()).ldelim();return X},G.encodeDelimited=function(J,X){return this.encode(J,X).ldelim()},G.decode=function(J,X){J instanceof K||(J=K.create(J));for(var V=X===void 0?J.len:J.pos+X,R=new Z.onnx.GraphProto;J.pos<V;){var z=J.uint32();switch(z>>>3){case 1:{R.node&&R.node.length||(R.node=[]),R.node.push(Z.onnx.NodeProto.decode(J,J.uint32()));break}case 2:{R.name=J.string();break}case 5:{R.initializer&&R.initializer.length||(R.initializer=[]),R.initializer.push(Z.onnx.TensorProto.decode(J,J.uint32()));break}case 15:{R.sparseInitializer&&R.sparseInitializer.length||(R.sparseInitializer=[]),R.sparseInitializer.push(Z.onnx.SparseTensorProto.decode(J,J.uint32()));break}case 10:{R.docString=J.string();break}case 11:{R.input&&R.input.length||(R.input=[]),R.input.push(Z.onnx.ValueInfoProto.decode(J,J.uint32()));break}case 12:{R.output&&R.output.length||(R.output=[]),R.output.push(Z.onnx.ValueInfoProto.decode(J,J.uint32()));break}case 13:{R.valueInfo&&R.valueInfo.length||(R.valueInfo=[]),R.valueInfo.push(Z.onnx.ValueInfoProto.decode(J,J.uint32()));break}case 14:{R.quantizationAnnotation&&R.quantizationAnnotation.length||(R.quantizationAnnotation=[]),R.quantizationAnnotation.push(Z.onnx.TensorAnnotation.decode(J,J.uint32()));break}default:J.skipType(z&7);break}}return R},G.decodeDelimited=function(J){return J instanceof K||(J=new K(J)),this.decode(J,J.uint32())},G.verify=function(J){if(typeof J!="object"||J===null)return"object expected";if(J.node!=null&&J.hasOwnProperty("node")){if(!Array.isArray(J.node))return"node: array expected";for(var X=0;X<J.node.length;++X){var V=Z.onnx.NodeProto.verify(J.node[X]);if(V)return"node."+V}}if(J.name!=null&&J.hasOwnProperty("name")&&!U.isString(J.name))return"name: string expected";if(J.initializer!=null&&J.hasOwnProperty("initializer")){if(!Array.isArray(J.initializer))return"initializer: array expected";for(var X=0;X<J.initializer.length;++X){var V=Z.onnx.TensorProto.verify(J.initializer[X]);if(V)return"initializer."+V}}if(J.sparseInitializer!=null&&J.hasOwnProperty("sparseInitializer")){if(!Array.isArray(J.sparseInitializer))return"sparseInitializer: array expected";for(var X=0;X<J.sparseInitializer.length;++X){var V=Z.onnx.SparseTensorProto.verify(J.sparseInitializer[X]);if(V)return"sparseInitializer."+V}}if(J.docString!=null&&J.hasOwnProperty("docString")&&!U.isString(J.docString))return"docString: string expected";if(J.input!=null&&J.hasOwnProperty("input")){if(!Array.isArray(J.input))return"input: array expected";for(var X=0;X<J.input.length;++X){var V=Z.onnx.ValueInfoProto.verify(J.input[X]);if(V)return"input."+V}}if(J.output!=null&&J.hasOwnProperty("output")){if(!Array.isArray(J.output))return"output: array expected";for(var X=0;X<J.output.length;++X){var V=Z.onnx.ValueInfoProto.verify(J.output[X]);if(V)return"output."+V}}if(J.valueInfo!=null&&J.hasOwnProperty("valueInfo")){if(!Array.isArray(J.valueInfo))return"valueInfo: array expected";for(var X=0;X<J.valueInfo.length;++X){var V=Z.onnx.ValueInfoProto.verify(J.valueInfo[X]);if(V)return"valueInfo."+V}}if(J.quantizationAnnotation!=null&&J.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(J.quantizationAnnotation))return"quantizationAnnotation: array expected";for(var X=0;X<J.quantizationAnnotation.length;++X){var V=Z.onnx.TensorAnnotation.verify(J.quantizationAnnotation[X]);if(V)return"quantizationAnnotation."+V}}return null},G.fromObject=function(J){if(J instanceof Z.onnx.GraphProto)return J;var X=new Z.onnx.GraphProto;if(J.node){if(!Array.isArray(J.node))throw TypeError(".onnx.GraphProto.node: array expected");X.node=[];for(var V=0;V<J.node.length;++V){if(typeof J.node[V]!="object")throw TypeError(".onnx.GraphProto.node: object expected");X.node[V]=Z.onnx.NodeProto.fromObject(J.node[V])}}if(J.name!=null&&(X.name=String(J.name)),J.initializer){if(!Array.isArray(J.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");X.initializer=[];for(var V=0;V<J.initializer.length;++V){if(typeof J.initializer[V]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");X.initializer[V]=Z.onnx.TensorProto.fromObject(J.initializer[V])}}if(J.sparseInitializer){if(!Array.isArray(J.sparseInitializer))throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");X.sparseInitializer=[];for(var V=0;V<J.sparseInitializer.length;++V){if(typeof J.sparseInitializer[V]!="object")throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");X.sparseInitializer[V]=Z.onnx.SparseTensorProto.fromObject(J.sparseInitializer[V])}}if(J.docString!=null&&(X.docString=String(J.docString)),J.input){if(!Array.isArray(J.input))throw TypeError(".onnx.GraphProto.input: array expected");X.input=[];for(var V=0;V<J.input.length;++V){if(typeof J.input[V]!="object")throw TypeError(".onnx.GraphProto.input: object expected");X.input[V]=Z.onnx.ValueInfoProto.fromObject(J.input[V])}}if(J.output){if(!Array.isArray(J.output))throw TypeError(".onnx.GraphProto.output: array expected");X.output=[];for(var V=0;V<J.output.length;++V){if(typeof J.output[V]!="object")throw TypeError(".onnx.GraphProto.output: object expected");X.output[V]=Z.onnx.ValueInfoProto.fromObject(J.output[V])}}if(J.valueInfo){if(!Array.isArray(J.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");X.valueInfo=[];for(var V=0;V<J.valueInfo.length;++V){if(typeof J.valueInfo[V]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");X.valueInfo[V]=Z.onnx.ValueInfoProto.fromObject(J.valueInfo[V])}}if(J.quantizationAnnotation){if(!Array.isArray(J.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");X.quantizationAnnotation=[];for(var V=0;V<J.quantizationAnnotation.length;++V){if(typeof J.quantizationAnnotation[V]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");X.quantizationAnnotation[V]=Z.onnx.TensorAnnotation.fromObject(J.quantizationAnnotation[V])}}return X},G.toObject=function(J,X){X||(X={});var V={};if((X.arrays||X.defaults)&&(V.node=[],V.initializer=[],V.input=[],V.output=[],V.valueInfo=[],V.quantizationAnnotation=[],V.sparseInitializer=[]),X.defaults&&(V.name="",V.docString=""),J.node&&J.node.length){V.node=[];for(var R=0;R<J.node.length;++R)V.node[R]=Z.onnx.NodeProto.toObject(J.node[R],X)}if(J.name!=null&&J.hasOwnProperty("name")&&(V.name=J.name),J.initializer&&J.initializer.length){V.initializer=[];for(var R=0;R<J.initializer.length;++R)V.initializer[R]=Z.onnx.TensorProto.toObject(J.initializer[R],X)}if(J.docString!=null&&J.hasOwnProperty("docString")&&(V.docString=J.docString),J.input&&J.input.length){V.input=[];for(var R=0;R<J.input.length;++R)V.input[R]=Z.onnx.ValueInfoProto.toObject(J.input[R],X)}if(J.output&&J.output.length){V.output=[];for(var R=0;R<J.output.length;++R)V.output[R]=Z.onnx.ValueInfoProto.toObject(J.output[R],X)}if(J.valueInfo&&J.valueInfo.length){V.valueInfo=[];for(var R=0;R<J.valueInfo.length;++R)V.valueInfo[R]=Z.onnx.ValueInfoProto.toObject(J.valueInfo[R],X)}if(J.quantizationAnnotation&&J.quantizationAnnotation.length){V.quantizationAnnotation=[];for(var R=0;R<J.quantizationAnnotation.length;++R)V.quantizationAnnotation[R]=Z.onnx.TensorAnnotation.toObject(J.quantizationAnnotation[R],X)}if(J.sparseInitializer&&J.sparseInitializer.length){V.sparseInitializer=[];for(var R=0;R<J.sparseInitializer.length;++R)V.sparseInitializer[R]=Z.onnx.SparseTensorProto.toObject(J.sparseInitializer[R],X)}return V},G.prototype.toJSON=function(){return this.constructor.toObject(this,j.util.toJSONOptions)},G.getTypeUrl=function(J){return J===void 0&&(J="type.googleapis.com"),J+"/onnx.GraphProto"},G}(),q.TensorProto=function(){function G(J){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],J)for(var X=Object.keys(J),V=0;V<X.length;++V)J[X[V]]!=null&&(this[X[V]]=J[X[V]])}return G.prototype.dims=U.emptyArray,G.prototype.dataType=0,G.prototype.segment=null,G.prototype.floatData=U.emptyArray,G.prototype.int32Data=U.emptyArray,G.prototype.stringData=U.emptyArray,G.prototype.int64Data=U.emptyArray,G.prototype.name="",G.prototype.docString="",G.prototype.rawData=U.newBuffer([]),G.prototype.externalData=U.emptyArray,G.prototype.dataLocation=0,G.prototype.doubleData=U.emptyArray,G.prototype.uint64Data=U.emptyArray,G.create=function(J){return new G(J)},G.encode=function(J,X){if(X||(X=W.create()),J.dims!=null&&J.dims.length){X.uint32(10).fork();for(var V=0;V<J.dims.length;++V)X.int64(J.dims[V]);X.ldelim()}if(J.dataType!=null&&Object.hasOwnProperty.call(J,"dataType")&&X.uint32(16).int32(J.dataType),J.segment!=null&&Object.hasOwnProperty.call(J,"segment")&&Z.onnx.TensorProto.Segment.encode(J.segment,X.uint32(26).fork()).ldelim(),J.floatData!=null&&J.floatData.length){X.uint32(34).fork();for(var V=0;V<J.floatData.length;++V)X.float(J.floatData[V]);X.ldelim()}if(J.int32Data!=null&&J.int32Data.length){X.uint32(42).fork();for(var V=0;V<J.int32Data.length;++V)X.int32(J.int32Data[V]);X.ldelim()}if(J.stringData!=null&&J.stringData.length)for(var V=0;V<J.stringData.length;++V)X.uint32(50).bytes(J.stringData[V]);if(J.int64Data!=null&&J.int64Data.length){X.uint32(58).fork();for(var V=0;V<J.int64Data.length;++V)X.int64(J.int64Data[V]);X.ldelim()}if(J.name!=null&&Object.hasOwnProperty.call(J,"name")&&X.uint32(66).string(J.name),J.rawData!=null&&Object.hasOwnProperty.call(J,"rawData")&&X.uint32(74).bytes(J.rawData),J.doubleData!=null&&J.doubleData.length){X.uint32(82).fork();for(var V=0;V<J.doubleData.length;++V)X.double(J.doubleData[V]);X.ldelim()}if(J.uint64Data!=null&&J.uint64Data.length){X.uint32(90).fork();for(var V=0;V<J.uint64Data.length;++V)X.uint64(J.uint64Data[V]);X.ldelim()}if(J.docString!=null&&Object.hasOwnProperty.call(J,"docString")&&X.uint32(98).string(J.docString),J.externalData!=null&&J.externalData.length)for(var V=0;V<J.externalData.length;++V)Z.onnx.StringStringEntryProto.encode(J.externalData[V],X.uint32(106).fork()).ldelim();return J.dataLocation!=null&&Object.hasOwnProperty.call(J,"dataLocation")&&X.uint32(112).int32(J.dataLocation),X},G.encodeDelimited=function(J,X){return this.encode(J,X).ldelim()},G.decode=function(J,X){J instanceof K||(J=K.create(J));for(var V=X===void 0?J.len:J.pos+X,R=new Z.onnx.TensorProto;J.pos<V;){var z=J.uint32();switch(z>>>3){case 1:{if(R.dims&&R.dims.length||(R.dims=[]),(z&7)===2)for(var Y=J.uint32()+J.pos;J.pos<Y;)R.dims.push(J.int64());else R.dims.push(J.int64());break}case 2:{R.dataType=J.int32();break}case 3:{R.segment=Z.onnx.TensorProto.Segment.decode(J,J.uint32());break}case 4:{if(R.floatData&&R.floatData.length||(R.floatData=[]),(z&7)===2)for(var Y=J.uint32()+J.pos;J.pos<Y;)R.floatData.push(J.float());else R.floatData.push(J.float());break}case 5:{if(R.int32Data&&R.int32Data.length||(R.int32Data=[]),(z&7)===2)for(var Y=J.uint32()+J.pos;J.pos<Y;)R.int32Data.push(J.int32());else R.int32Data.push(J.int32());break}case 6:{R.stringData&&R.stringData.length||(R.stringData=[]),R.stringData.push(J.bytes());break}case 7:{if(R.int64Data&&R.int64Data.length||(R.int64Data=[]),(z&7)===2)for(var Y=J.uint32()+J.pos;J.pos<Y;)R.int64Data.push(J.int64());else R.int64Data.push(J.int64());break}case 8:{R.name=J.string();break}case 12:{R.docString=J.string();break}case 9:{R.rawData=J.bytes();break}case 13:{R.externalData&&R.externalData.length||(R.externalData=[]),R.externalData.push(Z.onnx.StringStringEntryProto.decode(J,J.uint32()));break}case 14:{R.dataLocation=J.int32();break}case 10:{if(R.doubleData&&R.doubleData.length||(R.doubleData=[]),(z&7)===2)for(var Y=J.uint32()+J.pos;J.pos<Y;)R.doubleData.push(J.double());else R.doubleData.push(J.double());break}case 11:{if(R.uint64Data&&R.uint64Data.length||(R.uint64Data=[]),(z&7)===2)for(var Y=J.uint32()+J.pos;J.pos<Y;)R.uint64Data.push(J.uint64());else R.uint64Data.push(J.uint64());break}default:J.skipType(z&7);break}}return R},G.decodeDelimited=function(J){return J instanceof K||(J=new K(J)),this.decode(J,J.uint32())},G.verify=function(J){if(typeof J!="object"||J===null)return"object expected";if(J.dims!=null&&J.hasOwnProperty("dims")){if(!Array.isArray(J.dims))return"dims: array expected";for(var X=0;X<J.dims.length;++X)if(!U.isInteger(J.dims[X])&&!(J.dims[X]&&U.isInteger(J.dims[X].low)&&U.isInteger(J.dims[X].high)))return"dims: integer|Long[] expected"}if(J.dataType!=null&&J.hasOwnProperty("dataType")&&!U.isInteger(J.dataType))return"dataType: integer expected";if(J.segment!=null&&J.hasOwnProperty("segment")){var V=Z.onnx.TensorProto.Segment.verify(J.segment);if(V)return"segment."+V}if(J.floatData!=null&&J.hasOwnProperty("floatData")){if(!Array.isArray(J.floatData))return"floatData: array expected";for(var X=0;X<J.floatData.length;++X)if(typeof J.floatData[X]!="number")return"floatData: number[] expected"}if(J.int32Data!=null&&J.hasOwnProperty("int32Data")){if(!Array.isArray(J.int32Data))return"int32Data: array expected";for(var X=0;X<J.int32Data.length;++X)if(!U.isInteger(J.int32Data[X]))return"int32Data: integer[] expected"}if(J.stringData!=null&&J.hasOwnProperty("stringData")){if(!Array.isArray(J.stringData))return"stringData: array expected";for(var X=0;X<J.stringData.length;++X)if(!(J.stringData[X]&&typeof J.stringData[X].length=="number"||U.isString(J.stringData[X])))return"stringData: buffer[] expected"}if(J.int64Data!=null&&J.hasOwnProperty("int64Data")){if(!Array.isArray(J.int64Data))return"int64Data: array expected";for(var X=0;X<J.int64Data.length;++X)if(!U.isInteger(J.int64Data[X])&&!(J.int64Data[X]&&U.isInteger(J.int64Data[X].low)&&U.isInteger(J.int64Data[X].high)))return"int64Data: integer|Long[] expected"}if(J.name!=null&&J.hasOwnProperty("name")&&!U.isString(J.name))return"name: string expected";if(J.docString!=null&&J.hasOwnProperty("docString")&&!U.isString(J.docString))return"docString: string expected";if(J.rawData!=null&&J.hasOwnProperty("rawData")&&!(J.rawData&&typeof J.rawData.length=="number"||U.isString(J.rawData)))return"rawData: buffer expected";if(J.externalData!=null&&J.hasOwnProperty("externalData")){if(!Array.isArray(J.externalData))return"externalData: array expected";for(var X=0;X<J.externalData.length;++X){var V=Z.onnx.StringStringEntryProto.verify(J.externalData[X]);if(V)return"externalData."+V}}if(J.dataLocation!=null&&J.hasOwnProperty("dataLocation"))switch(J.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:break}if(J.doubleData!=null&&J.hasOwnProperty("doubleData")){if(!Array.isArray(J.doubleData))return"doubleData: array expected";for(var X=0;X<J.doubleData.length;++X)if(typeof J.doubleData[X]!="number")return"doubleData: number[] expected"}if(J.uint64Data!=null&&J.hasOwnProperty("uint64Data")){if(!Array.isArray(J.uint64Data))return"uint64Data: array expected";for(var X=0;X<J.uint64Data.length;++X)if(!U.isInteger(J.uint64Data[X])&&!(J.uint64Data[X]&&U.isInteger(J.uint64Data[X].low)&&U.isInteger(J.uint64Data[X].high)))return"uint64Data: integer|Long[] expected"}return null},G.fromObject=function(J){if(J instanceof Z.onnx.TensorProto)return J;var X=new Z.onnx.TensorProto;if(J.dims){if(!Array.isArray(J.dims))throw TypeError(".onnx.TensorProto.dims: array expected");X.dims=[];for(var V=0;V<J.dims.length;++V)U.Long?(X.dims[V]=U.Long.fromValue(J.dims[V])).unsigned=!1:typeof J.dims[V]=="string"?X.dims[V]=parseInt(J.dims[V],10):typeof J.dims[V]=="number"?X.dims[V]=J.dims[V]:typeof J.dims[V]=="object"&&(X.dims[V]=new U.LongBits(J.dims[V].low>>>0,J.dims[V].high>>>0).toNumber())}if(J.dataType!=null&&(X.dataType=J.dataType|0),J.segment!=null){if(typeof J.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");X.segment=Z.onnx.TensorProto.Segment.fromObject(J.segment)}if(J.floatData){if(!Array.isArray(J.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");X.floatData=[];for(var V=0;V<J.floatData.length;++V)X.floatData[V]=Number(J.floatData[V])}if(J.int32Data){if(!Array.isArray(J.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");X.int32Data=[];for(var V=0;V<J.int32Data.length;++V)X.int32Data[V]=J.int32Data[V]|0}if(J.stringData){if(!Array.isArray(J.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");X.stringData=[];for(var V=0;V<J.stringData.length;++V)typeof J.stringData[V]=="string"?U.base64.decode(J.stringData[V],X.stringData[V]=U.newBuffer(U.base64.length(J.stringData[V])),0):J.stringData[V].length>=0&&(X.stringData[V]=J.stringData[V])}if(J.int64Data){if(!Array.isArray(J.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");X.int64Data=[];for(var V=0;V<J.int64Data.length;++V)U.Long?(X.int64Data[V]=U.Long.fromValue(J.int64Data[V])).unsigned=!1:typeof J.int64Data[V]=="string"?X.int64Data[V]=parseInt(J.int64Data[V],10):typeof J.int64Data[V]=="number"?X.int64Data[V]=J.int64Data[V]:typeof J.int64Data[V]=="object"&&(X.int64Data[V]=new U.LongBits(J.int64Data[V].low>>>0,J.int64Data[V].high>>>0).toNumber())}if(J.name!=null&&(X.name=String(J.name)),J.docString!=null&&(X.docString=String(J.docString)),J.rawData!=null&&(typeof J.rawData=="string"?U.base64.decode(J.rawData,X.rawData=U.newBuffer(U.base64.length(J.rawData)),0):J.rawData.length>=0&&(X.rawData=J.rawData)),J.externalData){if(!Array.isArray(J.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");X.externalData=[];for(var V=0;V<J.externalData.length;++V){if(typeof J.externalData[V]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");X.externalData[V]=Z.onnx.StringStringEntryProto.fromObject(J.externalData[V])}}switch(J.dataLocation){default:if(typeof J.dataLocation=="number"){X.dataLocation=J.dataLocation;break}break;case"DEFAULT":case 0:X.dataLocation=0;break;case"EXTERNAL":case 1:X.dataLocation=1;break}if(J.doubleData){if(!Array.isArray(J.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");X.doubleData=[];for(var V=0;V<J.doubleData.length;++V)X.doubleData[V]=Number(J.doubleData[V])}if(J.uint64Data){if(!Array.isArray(J.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");X.uint64Data=[];for(var V=0;V<J.uint64Data.length;++V)U.Long?(X.uint64Data[V]=U.Long.fromValue(J.uint64Data[V])).unsigned=!0:typeof J.uint64Data[V]=="string"?X.uint64Data[V]=parseInt(J.uint64Data[V],10):typeof J.uint64Data[V]=="number"?X.uint64Data[V]=J.uint64Data[V]:typeof J.uint64Data[V]=="object"&&(X.uint64Data[V]=new U.LongBits(J.uint64Data[V].low>>>0,J.uint64Data[V].high>>>0).toNumber(!0))}return X},G.toObject=function(J,X){X||(X={});var V={};if((X.arrays||X.defaults)&&(V.dims=[],V.floatData=[],V.int32Data=[],V.stringData=[],V.int64Data=[],V.doubleData=[],V.uint64Data=[],V.externalData=[]),X.defaults&&(V.dataType=0,V.segment=null,V.name="",X.bytes===String?V.rawData="":(V.rawData=[],X.bytes!==Array&&(V.rawData=U.newBuffer(V.rawData))),V.docString="",V.dataLocation=X.enums===String?"DEFAULT":0),J.dims&&J.dims.length){V.dims=[];for(var R=0;R<J.dims.length;++R)typeof J.dims[R]=="number"?V.dims[R]=X.longs===String?String(J.dims[R]):J.dims[R]:V.dims[R]=X.longs===String?U.Long.prototype.toString.call(J.dims[R]):X.longs===Number?new U.LongBits(J.dims[R].low>>>0,J.dims[R].high>>>0).toNumber():J.dims[R]}if(J.dataType!=null&&J.hasOwnProperty("dataType")&&(V.dataType=J.dataType),J.segment!=null&&J.hasOwnProperty("segment")&&(V.segment=Z.onnx.TensorProto.Segment.toObject(J.segment,X)),J.floatData&&J.floatData.length){V.floatData=[];for(var R=0;R<J.floatData.length;++R)V.floatData[R]=X.json&&!isFinite(J.floatData[R])?String(J.floatData[R]):J.floatData[R]}if(J.int32Data&&J.int32Data.length){V.int32Data=[];for(var R=0;R<J.int32Data.length;++R)V.int32Data[R]=J.int32Data[R]}if(J.stringData&&J.stringData.length){V.stringData=[];for(var R=0;R<J.stringData.length;++R)V.stringData[R]=X.bytes===String?U.base64.encode(J.stringData[R],0,J.stringData[R].length):X.bytes===Array?Array.prototype.slice.call(J.stringData[R]):J.stringData[R]}if(J.int64Data&&J.int64Data.length){V.int64Data=[];for(var R=0;R<J.int64Data.length;++R)typeof J.int64Data[R]=="number"?V.int64Data[R]=X.longs===String?String(J.int64Data[R]):J.int64Data[R]:V.int64Data[R]=X.longs===String?U.Long.prototype.toString.call(J.int64Data[R]):X.longs===Number?new U.LongBits(J.int64Data[R].low>>>0,J.int64Data[R].high>>>0).toNumber():J.int64Data[R]}if(J.name!=null&&J.hasOwnProperty("name")&&(V.name=J.name),J.rawData!=null&&J.hasOwnProperty("rawData")&&(V.rawData=X.bytes===String?U.base64.encode(J.rawData,0,J.rawData.length):X.bytes===Array?Array.prototype.slice.call(J.rawData):J.rawData),J.doubleData&&J.doubleData.length){V.doubleData=[];for(var R=0;R<J.doubleData.length;++R)V.doubleData[R]=X.json&&!isFinite(J.doubleData[R])?String(J.doubleData[R]):J.doubleData[R]}if(J.uint64Data&&J.uint64Data.length){V.uint64Data=[];for(var R=0;R<J.uint64Data.length;++R)typeof J.uint64Data[R]=="number"?V.uint64Data[R]=X.longs===String?String(J.uint64Data[R]):J.uint64Data[R]:V.uint64Data[R]=X.longs===String?U.Long.prototype.toString.call(J.uint64Data[R]):X.longs===Number?new U.LongBits(J.uint64Data[R].low>>>0,J.uint64Data[R].high>>>0).toNumber(!0):J.uint64Data[R]}if(J.docString!=null&&J.hasOwnProperty("docString")&&(V.docString=J.docString),J.externalData&&J.externalData.length){V.externalData=[];for(var R=0;R<J.externalData.length;++R)V.externalData[R]=Z.onnx.StringStringEntryProto.toObject(J.externalData[R],X)}return J.dataLocation!=null&&J.hasOwnProperty("dataLocation")&&(V.dataLocation=X.enums===String?Z.onnx.TensorProto.DataLocation[J.dataLocation]===void 0?J.dataLocation:Z.onnx.TensorProto.DataLocation[J.dataLocation]:J.dataLocation),V},G.prototype.toJSON=function(){return this.constructor.toObject(this,j.util.toJSONOptions)},G.getTypeUrl=function(J){return J===void 0&&(J="type.googleapis.com"),J+"/onnx.TensorProto"},G.DataType=function(){var J={},X=Object.create(J);return X[J[0]="UNDEFINED"]=0,X[J[1]="FLOAT"]=1,X[J[2]="UINT8"]=2,X[J[3]="INT8"]=3,X[J[4]="UINT16"]=4,X[J[5]="INT16"]=5,X[J[6]="INT32"]=6,X[J[7]="INT64"]=7,X[J[8]="STRING"]=8,X[J[9]="BOOL"]=9,X[J[10]="FLOAT16"]=10,X[J[11]="DOUBLE"]=11,X[J[12]="UINT32"]=12,X[J[13]="UINT64"]=13,X[J[14]="COMPLEX64"]=14,X[J[15]="COMPLEX128"]=15,X[J[16]="BFLOAT16"]=16,X[J[17]="FLOAT8E4M3FN"]=17,X[J[18]="FLOAT8E4M3FNUZ"]=18,X[J[19]="FLOAT8E5M2"]=19,X[J[20]="FLOAT8E5M2FNUZ"]=20,X}(),G.Segment=function(){function J(X){if(X)for(var V=Object.keys(X),R=0;R<V.length;++R)X[V[R]]!=null&&(this[V[R]]=X[V[R]])}return J.prototype.begin=U.Long?U.Long.fromBits(0,0,!1):0,J.prototype.end=U.Long?U.Long.fromBits(0,0,!1):0,J.create=function(X){return new J(X)},J.encode=function(X,V){return V||(V=W.create()),X.begin!=null&&Object.hasOwnProperty.call(X,"begin")&&V.uint32(8).int64(X.begin),X.end!=null&&Object.hasOwnProperty.call(X,"end")&&V.uint32(16).int64(X.end),V},J.encodeDelimited=function(X,V){return this.encode(X,V).ldelim()},J.decode=function(X,V){X instanceof K||(X=K.create(X));for(var R=V===void 0?X.len:X.pos+V,z=new Z.onnx.TensorProto.Segment;X.pos<R;){var Y=X.uint32();switch(Y>>>3){case 1:{z.begin=X.int64();break}case 2:{z.end=X.int64();break}default:X.skipType(Y&7);break}}return z},J.decodeDelimited=function(X){return X instanceof K||(X=new K(X)),this.decode(X,X.uint32())},J.verify=function(X){return typeof X!="object"||X===null?"object expected":X.begin!=null&&X.hasOwnProperty("begin")&&!U.isInteger(X.begin)&&!(X.begin&&U.isInteger(X.begin.low)&&U.isInteger(X.begin.high))?"begin: integer|Long expected":X.end!=null&&X.hasOwnProperty("end")&&!U.isInteger(X.end)&&!(X.end&&U.isInteger(X.end.low)&&U.isInteger(X.end.high))?"end: integer|Long expected":null},J.fromObject=function(X){if(X instanceof Z.onnx.TensorProto.Segment)return X;var V=new Z.onnx.TensorProto.Segment;return X.begin!=null&&(U.Long?(V.begin=U.Long.fromValue(X.begin)).unsigned=!1:typeof X.begin=="string"?V.begin=parseInt(X.begin,10):typeof X.begin=="number"?V.begin=X.begin:typeof X.begin=="object"&&(V.begin=new U.LongBits(X.begin.low>>>0,X.begin.high>>>0).toNumber())),X.end!=null&&(U.Long?(V.end=U.Long.fromValue(X.end)).unsigned=!1:typeof X.end=="string"?V.end=parseInt(X.end,10):typeof X.end=="number"?V.end=X.end:typeof X.end=="object"&&(V.end=new U.LongBits(X.end.low>>>0,X.end.high>>>0).toNumber())),V},J.toObject=function(X,V){V||(V={});var R={};if(V.defaults){if(U.Long){var z=new U.Long(0,0,!1);R.begin=V.longs===String?z.toString():V.longs===Number?z.toNumber():z}else R.begin=V.longs===String?"0":0;if(U.Long){var z=new U.Long(0,0,!1);R.end=V.longs===String?z.toString():V.longs===Number?z.toNumber():z}else R.end=V.longs===String?"0":0}return X.begin!=null&&X.hasOwnProperty("begin")&&(typeof X.begin=="number"?R.begin=V.longs===String?String(X.begin):X.begin:R.begin=V.longs===String?U.Long.prototype.toString.call(X.begin):V.longs===Number?new U.LongBits(X.begin.low>>>0,X.begin.high>>>0).toNumber():X.begin),X.end!=null&&X.hasOwnProperty("end")&&(typeof X.end=="number"?R.end=V.longs===String?String(X.end):X.end:R.end=V.longs===String?U.Long.prototype.toString.call(X.end):V.longs===Number?new U.LongBits(X.end.low>>>0,X.end.high>>>0).toNumber():X.end),R},J.prototype.toJSON=function(){return this.constructor.toObject(this,j.util.toJSONOptions)},J.getTypeUrl=function(X){return X===void 0&&(X="type.googleapis.com"),X+"/onnx.TensorProto.Segment"},J}(),G.DataLocation=function(){var J={},X=Object.create(J);return X[J[0]="DEFAULT"]=0,X[J[1]="EXTERNAL"]=1,X}(),G}(),q.SparseTensorProto=function(){function G(J){if(this.dims=[],J)for(var X=Object.keys(J),V=0;V<X.length;++V)J[X[V]]!=null&&(this[X[V]]=J[X[V]])}return G.prototype.values=null,G.prototype.indices=null,G.prototype.dims=U.emptyArray,G.create=function(J){return new G(J)},G.encode=function(J,X){if(X||(X=W.create()),J.values!=null&&Object.hasOwnProperty.call(J,"values")&&Z.onnx.TensorProto.encode(J.values,X.uint32(10).fork()).ldelim(),J.indices!=null&&Object.hasOwnProperty.call(J,"indices")&&Z.onnx.TensorProto.encode(J.indices,X.uint32(18).fork()).ldelim(),J.dims!=null&&J.dims.length){X.uint32(26).fork();for(var V=0;V<J.dims.length;++V)X.int64(J.dims[V]);X.ldelim()}return X},G.encodeDelimited=function(J,X){return this.encode(J,X).ldelim()},G.decode=function(J,X){J instanceof K||(J=K.create(J));for(var V=X===void 0?J.len:J.pos+X,R=new Z.onnx.SparseTensorProto;J.pos<V;){var z=J.uint32();switch(z>>>3){case 1:{R.values=Z.onnx.TensorProto.decode(J,J.uint32());break}case 2:{R.indices=Z.onnx.TensorProto.decode(J,J.uint32());break}case 3:{if(R.dims&&R.dims.length||(R.dims=[]),(z&7)===2)for(var Y=J.uint32()+J.pos;J.pos<Y;)R.dims.push(J.int64());else R.dims.push(J.int64());break}default:J.skipType(z&7);break}}return R},G.decodeDelimited=function(J){return J instanceof K||(J=new K(J)),this.decode(J,J.uint32())},G.verify=function(J){if(typeof J!="object"||J===null)return"object expected";if(J.values!=null&&J.hasOwnProperty("values")){var X=Z.onnx.TensorProto.verify(J.values);if(X)return"values."+X}if(J.indices!=null&&J.hasOwnProperty("indices")){var X=Z.onnx.TensorProto.verify(J.indices);if(X)return"indices."+X}if(J.dims!=null&&J.hasOwnProperty("dims")){if(!Array.isArray(J.dims))return"dims: array expected";for(var V=0;V<J.dims.length;++V)if(!U.isInteger(J.dims[V])&&!(J.dims[V]&&U.isInteger(J.dims[V].low)&&U.isInteger(J.dims[V].high)))return"dims: integer|Long[] expected"}return null},G.fromObject=function(J){if(J instanceof Z.onnx.SparseTensorProto)return J;var X=new Z.onnx.SparseTensorProto;if(J.values!=null){if(typeof J.values!="object")throw TypeError(".onnx.SparseTensorProto.values: object expected");X.values=Z.onnx.TensorProto.fromObject(J.values)}if(J.indices!=null){if(typeof J.indices!="object")throw TypeError(".onnx.SparseTensorProto.indices: object expected");X.indices=Z.onnx.TensorProto.fromObject(J.indices)}if(J.dims){if(!Array.isArray(J.dims))throw TypeError(".onnx.SparseTensorProto.dims: array expected");X.dims=[];for(var V=0;V<J.dims.length;++V)U.Long?(X.dims[V]=U.Long.fromValue(J.dims[V])).unsigned=!1:typeof J.dims[V]=="string"?X.dims[V]=parseInt(J.dims[V],10):typeof J.dims[V]=="number"?X.dims[V]=J.dims[V]:typeof J.dims[V]=="object"&&(X.dims[V]=new U.LongBits(J.dims[V].low>>>0,J.dims[V].high>>>0).toNumber())}return X},G.toObject=function(J,X){X||(X={});var V={};if((X.arrays||X.defaults)&&(V.dims=[]),X.defaults&&(V.values=null,V.indices=null),J.values!=null&&J.hasOwnProperty("values")&&(V.values=Z.onnx.TensorProto.toObject(J.values,X)),J.indices!=null&&J.hasOwnProperty("indices")&&(V.indices=Z.onnx.TensorProto.toObject(J.indices,X)),J.dims&&J.dims.length){V.dims=[];for(var R=0;R<J.dims.length;++R)typeof J.dims[R]=="number"?V.dims[R]=X.longs===String?String(J.dims[R]):J.dims[R]:V.dims[R]=X.longs===String?U.Long.prototype.toString.call(J.dims[R]):X.longs===Number?new U.LongBits(J.dims[R].low>>>0,J.dims[R].high>>>0).toNumber():J.dims[R]}return V},G.prototype.toJSON=function(){return this.constructor.toObject(this,j.util.toJSONOptions)},G.getTypeUrl=function(J){return J===void 0&&(J="type.googleapis.com"),J+"/onnx.SparseTensorProto"},G}(),q.TensorShapeProto=function(){function G(J){if(this.dim=[],J)for(var X=Object.keys(J),V=0;V<X.length;++V)J[X[V]]!=null&&(this[X[V]]=J[X[V]])}return G.prototype.dim=U.emptyArray,G.create=function(J){return new G(J)},G.encode=function(J,X){if(X||(X=W.create()),J.dim!=null&&J.dim.length)for(var V=0;V<J.dim.length;++V)Z.onnx.TensorShapeProto.Dimension.encode(J.dim[V],X.uint32(10).fork()).ldelim();return X},G.encodeDelimited=function(J,X){return this.encode(J,X).ldelim()},G.decode=function(J,X){J instanceof K||(J=K.create(J));for(var V=X===void 0?J.len:J.pos+X,R=new Z.onnx.TensorShapeProto;J.pos<V;){var z=J.uint32();switch(z>>>3){case 1:{R.dim&&R.dim.length||(R.dim=[]),R.dim.push(Z.onnx.TensorShapeProto.Dimension.decode(J,J.uint32()));break}default:J.skipType(z&7);break}}return R},G.decodeDelimited=function(J){return J instanceof K||(J=new K(J)),this.decode(J,J.uint32())},G.verify=function(J){if(typeof J!="object"||J===null)return"object expected";if(J.dim!=null&&J.hasOwnProperty("dim")){if(!Array.isArray(J.dim))return"dim: array expected";for(var X=0;X<J.dim.length;++X){var V=Z.onnx.TensorShapeProto.Dimension.verify(J.dim[X]);if(V)return"dim."+V}}return null},G.fromObject=function(J){if(J instanceof Z.onnx.TensorShapeProto)return J;var X=new Z.onnx.TensorShapeProto;if(J.dim){if(!Array.isArray(J.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");X.dim=[];for(var V=0;V<J.dim.length;++V){if(typeof J.dim[V]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");X.dim[V]=Z.onnx.TensorShapeProto.Dimension.fromObject(J.dim[V])}}return X},G.toObject=function(J,X){X||(X={});var V={};if((X.arrays||X.defaults)&&(V.dim=[]),J.dim&&J.dim.length){V.dim=[];for(var R=0;R<J.dim.length;++R)V.dim[R]=Z.onnx.TensorShapeProto.Dimension.toObject(J.dim[R],X)}return V},G.prototype.toJSON=function(){return this.constructor.toObject(this,j.util.toJSONOptions)},G.getTypeUrl=function(J){return J===void 0&&(J="type.googleapis.com"),J+"/onnx.TensorShapeProto"},G.Dimension=function(){function J(V){if(V)for(var R=Object.keys(V),z=0;z<R.length;++z)V[R[z]]!=null&&(this[R[z]]=V[R[z]])}J.prototype.dimValue=null,J.prototype.dimParam=null,J.prototype.denotation="";var X;return Object.defineProperty(J.prototype,"value",{get:U.oneOfGetter(X=["dimValue","dimParam"]),set:U.oneOfSetter(X)}),J.create=function(V){return new J(V)},J.encode=function(V,R){return R||(R=W.create()),V.dimValue!=null&&Object.hasOwnProperty.call(V,"dimValue")&&R.uint32(8).int64(V.dimValue),V.dimParam!=null&&Object.hasOwnProperty.call(V,"dimParam")&&R.uint32(18).string(V.dimParam),V.denotation!=null&&Object.hasOwnProperty.call(V,"denotation")&&R.uint32(26).string(V.denotation),R},J.encodeDelimited=function(V,R){return this.encode(V,R).ldelim()},J.decode=function(V,R){V instanceof K||(V=K.create(V));for(var z=R===void 0?V.len:V.pos+R,Y=new Z.onnx.TensorShapeProto.Dimension;V.pos<z;){var B=V.uint32();switch(B>>>3){case 1:{Y.dimValue=V.int64();break}case 2:{Y.dimParam=V.string();break}case 3:{Y.denotation=V.string();break}default:V.skipType(B&7);break}}return Y},J.decodeDelimited=function(V){return V instanceof K||(V=new K(V)),this.decode(V,V.uint32())},J.verify=function(V){if(typeof V!="object"||V===null)return"object expected";var R={};if(V.dimValue!=null&&V.hasOwnProperty("dimValue")&&(R.value=1,!U.isInteger(V.dimValue)&&!(V.dimValue&&U.isInteger(V.dimValue.low)&&U.isInteger(V.dimValue.high))))return"dimValue: integer|Long expected";if(V.dimParam!=null&&V.hasOwnProperty("dimParam")){if(R.value===1)return"value: multiple values";if(R.value=1,!U.isString(V.dimParam))return"dimParam: string expected"}return V.denotation!=null&&V.hasOwnProperty("denotation")&&!U.isString(V.denotation)?"denotation: string expected":null},J.fromObject=function(V){if(V instanceof Z.onnx.TensorShapeProto.Dimension)return V;var R=new Z.onnx.TensorShapeProto.Dimension;return V.dimValue!=null&&(U.Long?(R.dimValue=U.Long.fromValue(V.dimValue)).unsigned=!1:typeof V.dimValue=="string"?R.dimValue=parseInt(V.dimValue,10):typeof V.dimValue=="number"?R.dimValue=V.dimValue:typeof V.dimValue=="object"&&(R.dimValue=new U.LongBits(V.dimValue.low>>>0,V.dimValue.high>>>0).toNumber())),V.dimParam!=null&&(R.dimParam=String(V.dimParam)),V.denotation!=null&&(R.denotation=String(V.denotation)),R},J.toObject=function(V,R){R||(R={});var z={};return R.defaults&&(z.denotation=""),V.dimValue!=null&&V.hasOwnProperty("dimValue")&&(typeof V.dimValue=="number"?z.dimValue=R.longs===String?String(V.dimValue):V.dimValue:z.dimValue=R.longs===String?U.Long.prototype.toString.call(V.dimValue):R.longs===Number?new U.LongBits(V.dimValue.low>>>0,V.dimValue.high>>>0).toNumber():V.dimValue,R.oneofs&&(z.value="dimValue")),V.dimParam!=null&&V.hasOwnProperty("dimParam")&&(z.dimParam=V.dimParam,R.oneofs&&(z.value="dimParam")),V.denotation!=null&&V.hasOwnProperty("denotation")&&(z.denotation=V.denotation),z},J.prototype.toJSON=function(){return this.constructor.toObject(this,j.util.toJSONOptions)},J.getTypeUrl=function(V){return V===void 0&&(V="type.googleapis.com"),V+"/onnx.TensorShapeProto.Dimension"},J}(),G}(),q.TypeProto=function(){function G(X){if(X)for(var V=Object.keys(X),R=0;R<V.length;++R)X[V[R]]!=null&&(this[V[R]]=X[V[R]])}G.prototype.tensorType=null,G.prototype.sequenceType=null,G.prototype.mapType=null,G.prototype.optionalType=null,G.prototype.sparseTensorType=null,G.prototype.denotation="";var J;return Object.defineProperty(G.prototype,"value",{get:U.oneOfGetter(J=["tensorType","sequenceType","mapType","optionalType","sparseTensorType"]),set:U.oneOfSetter(J)}),G.create=function(X){return new G(X)},G.encode=function(X,V){return V||(V=W.create()),X.tensorType!=null&&Object.hasOwnProperty.call(X,"tensorType")&&Z.onnx.TypeProto.Tensor.encode(X.tensorType,V.uint32(10).fork()).ldelim(),X.sequenceType!=null&&Object.hasOwnProperty.call(X,"sequenceType")&&Z.onnx.TypeProto.Sequence.encode(X.sequenceType,V.uint32(34).fork()).ldelim(),X.mapType!=null&&Object.hasOwnProperty.call(X,"mapType")&&Z.onnx.TypeProto.Map.encode(X.mapType,V.uint32(42).fork()).ldelim(),X.denotation!=null&&Object.hasOwnProperty.call(X,"denotation")&&V.uint32(50).string(X.denotation),X.sparseTensorType!=null&&Object.hasOwnProperty.call(X,"sparseTensorType")&&Z.onnx.TypeProto.SparseTensor.encode(X.sparseTensorType,V.uint32(66).fork()).ldelim(),X.optionalType!=null&&Object.hasOwnProperty.call(X,"optionalType")&&Z.onnx.TypeProto.Optional.encode(X.optionalType,V.uint32(74).fork()).ldelim(),V},G.encodeDelimited=function(X,V){return this.encode(X,V).ldelim()},G.decode=function(X,V){X instanceof K||(X=K.create(X));for(var R=V===void 0?X.len:X.pos+V,z=new Z.onnx.TypeProto;X.pos<R;){var Y=X.uint32();switch(Y>>>3){case 1:{z.tensorType=Z.onnx.TypeProto.Tensor.decode(X,X.uint32());break}case 4:{z.sequenceType=Z.onnx.TypeProto.Sequence.decode(X,X.uint32());break}case 5:{z.mapType=Z.onnx.TypeProto.Map.decode(X,X.uint32());break}case 9:{z.optionalType=Z.onnx.TypeProto.Optional.decode(X,X.uint32());break}case 8:{z.sparseTensorType=Z.onnx.TypeProto.SparseTensor.decode(X,X.uint32());break}case 6:{z.denotation=X.string();break}default:X.skipType(Y&7);break}}return z},G.decodeDelimited=function(X){return X instanceof K||(X=new K(X)),this.decode(X,X.uint32())},G.verify=function(X){if(typeof X!="object"||X===null)return"object expected";var V={};if(X.tensorType!=null&&X.hasOwnProperty("tensorType")){V.value=1;{var R=Z.onnx.TypeProto.Tensor.verify(X.tensorType);if(R)return"tensorType."+R}}if(X.sequenceType!=null&&X.hasOwnProperty("sequenceType")){if(V.value===1)return"value: multiple values";V.value=1;{var R=Z.onnx.TypeProto.Sequence.verify(X.sequenceType);if(R)return"sequenceType."+R}}if(X.mapType!=null&&X.hasOwnProperty("mapType")){if(V.value===1)return"value: multiple values";V.value=1;{var R=Z.onnx.TypeProto.Map.verify(X.mapType);if(R)return"mapType."+R}}if(X.optionalType!=null&&X.hasOwnProperty("optionalType")){if(V.value===1)return"value: multiple values";V.value=1;{var R=Z.onnx.TypeProto.Optional.verify(X.optionalType);if(R)return"optionalType."+R}}if(X.sparseTensorType!=null&&X.hasOwnProperty("sparseTensorType")){if(V.value===1)return"value: multiple values";V.value=1;{var R=Z.onnx.TypeProto.SparseTensor.verify(X.sparseTensorType);if(R)return"sparseTensorType."+R}}return X.denotation!=null&&X.hasOwnProperty("denotation")&&!U.isString(X.denotation)?"denotation: string expected":null},G.fromObject=function(X){if(X instanceof Z.onnx.TypeProto)return X;var V=new Z.onnx.TypeProto;if(X.tensorType!=null){if(typeof X.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");V.tensorType=Z.onnx.TypeProto.Tensor.fromObject(X.tensorType)}if(X.sequenceType!=null){if(typeof X.sequenceType!="object")throw TypeError(".onnx.TypeProto.sequenceType: object expected");V.sequenceType=Z.onnx.TypeProto.Sequence.fromObject(X.sequenceType)}if(X.mapType!=null){if(typeof X.mapType!="object")throw TypeError(".onnx.TypeProto.mapType: object expected");V.mapType=Z.onnx.TypeProto.Map.fromObject(X.mapType)}if(X.optionalType!=null){if(typeof X.optionalType!="object")throw TypeError(".onnx.TypeProto.optionalType: object expected");V.optionalType=Z.onnx.TypeProto.Optional.fromObject(X.optionalType)}if(X.sparseTensorType!=null){if(typeof X.sparseTensorType!="object")throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");V.sparseTensorType=Z.onnx.TypeProto.SparseTensor.fromObject(X.sparseTensorType)}return X.denotation!=null&&(V.denotation=String(X.denotation)),V},G.toObject=function(X,V){V||(V={});var R={};return V.defaults&&(R.denotation=""),X.tensorType!=null&&X.hasOwnProperty("tensorType")&&(R.tensorType=Z.onnx.TypeProto.Tensor.toObject(X.tensorType,V),V.oneofs&&(R.value="tensorType")),X.sequenceType!=null&&X.hasOwnProperty("sequenceType")&&(R.sequenceType=Z.onnx.TypeProto.Sequence.toObject(X.sequenceType,V),V.oneofs&&(R.value="sequenceType")),X.mapType!=null&&X.hasOwnProperty("mapType")&&(R.mapType=Z.onnx.TypeProto.Map.toObject(X.mapType,V),V.oneofs&&(R.value="mapType")),X.denotation!=null&&X.hasOwnProperty("denotation")&&(R.denotation=X.denotation),X.sparseTensorType!=null&&X.hasOwnProperty("sparseTensorType")&&(R.sparseTensorType=Z.onnx.TypeProto.SparseTensor.toObject(X.sparseTensorType,V),V.oneofs&&(R.value="sparseTensorType")),X.optionalType!=null&&X.hasOwnProperty("optionalType")&&(R.optionalType=Z.onnx.TypeProto.Optional.toObject(X.optionalType,V),V.oneofs&&(R.value="optionalType")),R},G.prototype.toJSON=function(){return this.constructor.toObject(this,j.util.toJSONOptions)},G.getTypeUrl=function(X){return X===void 0&&(X="type.googleapis.com"),X+"/onnx.TypeProto"},G.Tensor=function(){function X(V){if(V)for(var R=Object.keys(V),z=0;z<R.length;++z)V[R[z]]!=null&&(this[R[z]]=V[R[z]])}return X.prototype.elemType=0,X.prototype.shape=null,X.create=function(V){return new X(V)},X.encode=function(V,R){return R||(R=W.create()),V.elemType!=null&&Object.hasOwnProperty.call(V,"elemType")&&R.uint32(8).int32(V.elemType),V.shape!=null&&Object.hasOwnProperty.call(V,"shape")&&Z.onnx.TensorShapeProto.encode(V.shape,R.uint32(18).fork()).ldelim(),R},X.encodeDelimited=function(V,R){return this.encode(V,R).ldelim()},X.decode=function(V,R){V instanceof K||(V=K.create(V));for(var z=R===void 0?V.len:V.pos+R,Y=new Z.onnx.TypeProto.Tensor;V.pos<z;){var B=V.uint32();switch(B>>>3){case 1:{Y.elemType=V.int32();break}case 2:{Y.shape=Z.onnx.TensorShapeProto.decode(V,V.uint32());break}default:V.skipType(B&7);break}}return Y},X.decodeDelimited=function(V){return V instanceof K||(V=new K(V)),this.decode(V,V.uint32())},X.verify=function(V){if(typeof V!="object"||V===null)return"object expected";if(V.elemType!=null&&V.hasOwnProperty("elemType")&&!U.isInteger(V.elemType))return"elemType: integer expected";if(V.shape!=null&&V.hasOwnProperty("shape")){var R=Z.onnx.TensorShapeProto.verify(V.shape);if(R)return"shape."+R}return null},X.fromObject=function(V){if(V instanceof Z.onnx.TypeProto.Tensor)return V;var R=new Z.onnx.TypeProto.Tensor;if(V.elemType!=null&&(R.elemType=V.elemType|0),V.shape!=null){if(typeof V.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");R.shape=Z.onnx.TensorShapeProto.fromObject(V.shape)}return R},X.toObject=function(V,R){R||(R={});var z={};return R.defaults&&(z.elemType=0,z.shape=null),V.elemType!=null&&V.hasOwnProperty("elemType")&&(z.elemType=V.elemType),V.shape!=null&&V.hasOwnProperty("shape")&&(z.shape=Z.onnx.TensorShapeProto.toObject(V.shape,R)),z},X.prototype.toJSON=function(){return this.constructor.toObject(this,j.util.toJSONOptions)},X.getTypeUrl=function(V){return V===void 0&&(V="type.googleapis.com"),V+"/onnx.TypeProto.Tensor"},X}(),G.Sequence=function(){function X(V){if(V)for(var R=Object.keys(V),z=0;z<R.length;++z)V[R[z]]!=null&&(this[R[z]]=V[R[z]])}return X.prototype.elemType=null,X.create=function(V){return new X(V)},X.encode=function(V,R){return R||(R=W.create()),V.elemType!=null&&Object.hasOwnProperty.call(V,"elemType")&&Z.onnx.TypeProto.encode(V.elemType,R.uint32(10).fork()).ldelim(),R},X.encodeDelimited=function(V,R){return this.encode(V,R).ldelim()},X.decode=function(V,R){V instanceof K||(V=K.create(V));for(var z=R===void 0?V.len:V.pos+R,Y=new Z.onnx.TypeProto.Sequence;V.pos<z;){var B=V.uint32();switch(B>>>3){case 1:{Y.elemType=Z.onnx.TypeProto.decode(V,V.uint32());break}default:V.skipType(B&7);break}}return Y},X.decodeDelimited=function(V){return V instanceof K||(V=new K(V)),this.decode(V,V.uint32())},X.verify=function(V){if(typeof V!="object"||V===null)return"object expected";if(V.elemType!=null&&V.hasOwnProperty("elemType")){var R=Z.onnx.TypeProto.verify(V.elemType);if(R)return"elemType."+R}return null},X.fromObject=function(V){if(V instanceof Z.onnx.TypeProto.Sequence)return V;var R=new Z.onnx.TypeProto.Sequence;if(V.elemType!=null){if(typeof V.elemType!="object")throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");R.elemType=Z.onnx.TypeProto.fromObject(V.elemType)}return R},X.toObject=function(V,R){R||(R={});var z={};return R.defaults&&(z.elemType=null),V.elemType!=null&&V.hasOwnProperty("elemType")&&(z.elemType=Z.onnx.TypeProto.toObject(V.elemType,R)),z},X.prototype.toJSON=function(){return this.constructor.toObject(this,j.util.toJSONOptions)},X.getTypeUrl=function(V){return V===void 0&&(V="type.googleapis.com"),V+"/onnx.TypeProto.Sequence"},X}(),G.Map=function(){function X(V){if(V)for(var R=Object.keys(V),z=0;z<R.length;++z)V[R[z]]!=null&&(this[R[z]]=V[R[z]])}return X.prototype.keyType=0,X.prototype.valueType=null,X.create=function(V){return new X(V)},X.encode=function(V,R){return R||(R=W.create()),V.keyType!=null&&Object.hasOwnProperty.call(V,"keyType")&&R.uint32(8).int32(V.keyType),V.valueType!=null&&Object.hasOwnProperty.call(V,"valueType")&&Z.onnx.TypeProto.encode(V.valueType,R.uint32(18).fork()).ldelim(),R},X.encodeDelimited=function(V,R){return this.encode(V,R).ldelim()},X.decode=function(V,R){V instanceof K||(V=K.create(V));for(var z=R===void 0?V.len:V.pos+R,Y=new Z.onnx.TypeProto.Map;V.pos<z;){var B=V.uint32();switch(B>>>3){case 1:{Y.keyType=V.int32();break}case 2:{Y.valueType=Z.onnx.TypeProto.decode(V,V.uint32());break}default:V.skipType(B&7);break}}return Y},X.decodeDelimited=function(V){return V instanceof K||(V=new K(V)),this.decode(V,V.uint32())},X.verify=function(V){if(typeof V!="object"||V===null)return"object expected";if(V.keyType!=null&&V.hasOwnProperty("keyType")&&!U.isInteger(V.keyType))return"keyType: integer expected";if(V.valueType!=null&&V.hasOwnProperty("valueType")){var R=Z.onnx.TypeProto.verify(V.valueType);if(R)return"valueType."+R}return null},X.fromObject=function(V){if(V instanceof Z.onnx.TypeProto.Map)return V;var R=new Z.onnx.TypeProto.Map;if(V.keyType!=null&&(R.keyType=V.keyType|0),V.valueType!=null){if(typeof V.valueType!="object")throw TypeError(".onnx.TypeProto.Map.valueType: object expected");R.valueType=Z.onnx.TypeProto.fromObject(V.valueType)}return R},X.toObject=function(V,R){R||(R={});var z={};return R.defaults&&(z.keyType=0,z.valueType=null),V.keyType!=null&&V.hasOwnProperty("keyType")&&(z.keyType=V.keyType),V.valueType!=null&&V.hasOwnProperty("valueType")&&(z.valueType=Z.onnx.TypeProto.toObject(V.valueType,R)),z},X.prototype.toJSON=function(){return this.constructor.toObject(this,j.util.toJSONOptions)},X.getTypeUrl=function(V){return V===void 0&&(V="type.googleapis.com"),V+"/onnx.TypeProto.Map"},X}(),G.Optional=function(){function X(V){if(V)for(var R=Object.keys(V),z=0;z<R.length;++z)V[R[z]]!=null&&(this[R[z]]=V[R[z]])}return X.prototype.elemType=null,X.create=function(V){return new X(V)},X.encode=function(V,R){return R||(R=W.create()),V.elemType!=null&&Object.hasOwnProperty.call(V,"elemType")&&Z.onnx.TypeProto.encode(V.elemType,R.uint32(10).fork()).ldelim(),R},X.encodeDelimited=function(V,R){return this.encode(V,R).ldelim()},X.decode=function(V,R){V instanceof K||(V=K.create(V));for(var z=R===void 0?V.len:V.pos+R,Y=new Z.onnx.TypeProto.Optional;V.pos<z;){var B=V.uint32();switch(B>>>3){case 1:{Y.elemType=Z.onnx.TypeProto.decode(V,V.uint32());break}default:V.skipType(B&7);break}}return Y},X.decodeDelimited=function(V){return V instanceof K||(V=new K(V)),this.decode(V,V.uint32())},X.verify=function(V){if(typeof V!="object"||V===null)return"object expected";if(V.elemType!=null&&V.hasOwnProperty("elemType")){var R=Z.onnx.TypeProto.verify(V.elemType);if(R)return"elemType."+R}return null},X.fromObject=function(V){if(V instanceof Z.onnx.TypeProto.Optional)return V;var R=new Z.onnx.TypeProto.Optional;if(V.elemType!=null){if(typeof V.elemType!="object")throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");R.elemType=Z.onnx.TypeProto.fromObject(V.elemType)}return R},X.toObject=function(V,R){R||(R={});var z={};return R.defaults&&(z.elemType=null),V.elemType!=null&&V.hasOwnProperty("elemType")&&(z.elemType=Z.onnx.TypeProto.toObject(V.elemType,R)),z},X.prototype.toJSON=function(){return this.constructor.toObject(this,j.util.toJSONOptions)},X.getTypeUrl=function(V){return V===void 0&&(V="type.googleapis.com"),V+"/onnx.TypeProto.Optional"},X}(),G.SparseTensor=function(){function X(V){if(V)for(var R=Object.keys(V),z=0;z<R.length;++z)V[R[z]]!=null&&(this[R[z]]=V[R[z]])}return X.prototype.elemType=0,X.prototype.shape=null,X.create=function(V){return new X(V)},X.encode=function(V,R){return R||(R=W.create()),V.elemType!=null&&Object.hasOwnProperty.call(V,"elemType")&&R.uint32(8).int32(V.elemType),V.shape!=null&&Object.hasOwnProperty.call(V,"shape")&&Z.onnx.TensorShapeProto.encode(V.shape,R.uint32(18).fork()).ldelim(),R},X.encodeDelimited=function(V,R){return this.encode(V,R).ldelim()},X.decode=function(V,R){V instanceof K||(V=K.create(V));for(var z=R===void 0?V.len:V.pos+R,Y=new Z.onnx.TypeProto.SparseTensor;V.pos<z;){var B=V.uint32();switch(B>>>3){case 1:{Y.elemType=V.int32();break}case 2:{Y.shape=Z.onnx.TensorShapeProto.decode(V,V.uint32());break}default:V.skipType(B&7);break}}return Y},X.decodeDelimited=function(V){return V instanceof K||(V=new K(V)),this.decode(V,V.uint32())},X.verify=function(V){if(typeof V!="object"||V===null)return"object expected";if(V.elemType!=null&&V.hasOwnProperty("elemType")&&!U.isInteger(V.elemType))return"elemType: integer expected";if(V.shape!=null&&V.hasOwnProperty("shape")){var R=Z.onnx.TensorShapeProto.verify(V.shape);if(R)return"shape."+R}return null},X.fromObject=function(V){if(V instanceof Z.onnx.TypeProto.SparseTensor)return V;var R=new Z.onnx.TypeProto.SparseTensor;if(V.elemType!=null&&(R.elemType=V.elemType|0),V.shape!=null){if(typeof V.shape!="object")throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");R.shape=Z.onnx.TensorShapeProto.fromObject(V.shape)}return R},X.toObject=function(V,R){R||(R={});var z={};return R.defaults&&(z.elemType=0,z.shape=null),V.elemType!=null&&V.hasOwnProperty("elemType")&&(z.elemType=V.elemType),V.shape!=null&&V.hasOwnProperty("shape")&&(z.shape=Z.onnx.TensorShapeProto.toObject(V.shape,R)),z},X.prototype.toJSON=function(){return this.constructor.toObject(this,j.util.toJSONOptions)},X.getTypeUrl=function(V){return V===void 0&&(V="type.googleapis.com"),V+"/onnx.TypeProto.SparseTensor"},X}(),G}(),q.OperatorSetIdProto=function(){function G(J){if(J)for(var X=Object.keys(J),V=0;V<X.length;++V)J[X[V]]!=null&&(this[X[V]]=J[X[V]])}return G.prototype.domain="",G.prototype.version=U.Long?U.Long.fromBits(0,0,!1):0,G.create=function(J){return new G(J)},G.encode=function(J,X){return X||(X=W.create()),J.domain!=null&&Object.hasOwnProperty.call(J,"domain")&&X.uint32(10).string(J.domain),J.version!=null&&Object.hasOwnProperty.call(J,"version")&&X.uint32(16).int64(J.version),X},G.encodeDelimited=function(J,X){return this.encode(J,X).ldelim()},G.decode=function(J,X){J instanceof K||(J=K.create(J));for(var V=X===void 0?J.len:J.pos+X,R=new Z.onnx.OperatorSetIdProto;J.pos<V;){var z=J.uint32();switch(z>>>3){case 1:{R.domain=J.string();break}case 2:{R.version=J.int64();break}default:J.skipType(z&7);break}}return R},G.decodeDelimited=function(J){return J instanceof K||(J=new K(J)),this.decode(J,J.uint32())},G.verify=function(J){return typeof J!="object"||J===null?"object expected":J.domain!=null&&J.hasOwnProperty("domain")&&!U.isString(J.domain)?"domain: string expected":J.version!=null&&J.hasOwnProperty("version")&&!U.isInteger(J.version)&&!(J.version&&U.isInteger(J.version.low)&&U.isInteger(J.version.high))?"version: integer|Long expected":null},G.fromObject=function(J){if(J instanceof Z.onnx.OperatorSetIdProto)return J;var X=new Z.onnx.OperatorSetIdProto;return J.domain!=null&&(X.domain=String(J.domain)),J.version!=null&&(U.Long?(X.version=U.Long.fromValue(J.version)).unsigned=!1:typeof J.version=="string"?X.version=parseInt(J.version,10):typeof J.version=="number"?X.version=J.version:typeof J.version=="object"&&(X.version=new U.LongBits(J.version.low>>>0,J.version.high>>>0).toNumber())),X},G.toObject=function(J,X){X||(X={});var V={};if(X.defaults)if(V.domain="",U.Long){var R=new U.Long(0,0,!1);V.version=X.longs===String?R.toString():X.longs===Number?R.toNumber():R}else V.version=X.longs===String?"0":0;return J.domain!=null&&J.hasOwnProperty("domain")&&(V.domain=J.domain),J.version!=null&&J.hasOwnProperty("version")&&(typeof J.version=="number"?V.version=X.longs===String?String(J.version):J.version:V.version=X.longs===String?U.Long.prototype.toString.call(J.version):X.longs===Number?new U.LongBits(J.version.low>>>0,J.version.high>>>0).toNumber():J.version),V},G.prototype.toJSON=function(){return this.constructor.toObject(this,j.util.toJSONOptions)},G.getTypeUrl=function(J){return J===void 0&&(J="type.googleapis.com"),J+"/onnx.OperatorSetIdProto"},G}(),q.OperatorStatus=function(){var G={},J=Object.create(G);return J[G[0]="EXPERIMENTAL"]=0,J[G[1]="STABLE"]=1,J}(),q.FunctionProto=function(){function G(J){if(this.input=[],this.output=[],this.attribute=[],this.attributeProto=[],this.node=[],this.opsetImport=[],J)for(var X=Object.keys(J),V=0;V<X.length;++V)J[X[V]]!=null&&(this[X[V]]=J[X[V]])}return G.prototype.name="",G.prototype.input=U.emptyArray,G.prototype.output=U.emptyArray,G.prototype.attribute=U.emptyArray,G.prototype.attributeProto=U.emptyArray,G.prototype.node=U.emptyArray,G.prototype.docString="",G.prototype.opsetImport=U.emptyArray,G.prototype.domain="",G.create=function(J){return new G(J)},G.encode=function(J,X){if(X||(X=W.create()),J.name!=null&&Object.hasOwnProperty.call(J,"name")&&X.uint32(10).string(J.name),J.input!=null&&J.input.length)for(var V=0;V<J.input.length;++V)X.uint32(34).string(J.input[V]);if(J.output!=null&&J.output.length)for(var V=0;V<J.output.length;++V)X.uint32(42).string(J.output[V]);if(J.attribute!=null&&J.attribute.length)for(var V=0;V<J.attribute.length;++V)X.uint32(50).string(J.attribute[V]);if(J.node!=null&&J.node.length)for(var V=0;V<J.node.length;++V)Z.onnx.NodeProto.encode(J.node[V],X.uint32(58).fork()).ldelim();if(J.docString!=null&&Object.hasOwnProperty.call(J,"docString")&&X.uint32(66).string(J.docString),J.opsetImport!=null&&J.opsetImport.length)for(var V=0;V<J.opsetImport.length;++V)Z.onnx.OperatorSetIdProto.encode(J.opsetImport[V],X.uint32(74).fork()).ldelim();if(J.domain!=null&&Object.hasOwnProperty.call(J,"domain")&&X.uint32(82).string(J.domain),J.attributeProto!=null&&J.attributeProto.length)for(var V=0;V<J.attributeProto.length;++V)Z.onnx.AttributeProto.encode(J.attributeProto[V],X.uint32(90).fork()).ldelim();return X},G.encodeDelimited=function(J,X){return this.encode(J,X).ldelim()},G.decode=function(J,X){J instanceof K||(J=K.create(J));for(var V=X===void 0?J.len:J.pos+X,R=new Z.onnx.FunctionProto;J.pos<V;){var z=J.uint32();switch(z>>>3){case 1:{R.name=J.string();break}case 4:{R.input&&R.input.length||(R.input=[]),R.input.push(J.string());break}case 5:{R.output&&R.output.length||(R.output=[]),R.output.push(J.string());break}case 6:{R.attribute&&R.attribute.length||(R.attribute=[]),R.attribute.push(J.string());break}case 11:{R.attributeProto&&R.attributeProto.length||(R.attributeProto=[]),R.attributeProto.push(Z.onnx.AttributeProto.decode(J,J.uint32()));break}case 7:{R.node&&R.node.length||(R.node=[]),R.node.push(Z.onnx.NodeProto.decode(J,J.uint32()));break}case 8:{R.docString=J.string();break}case 9:{R.opsetImport&&R.opsetImport.length||(R.opsetImport=[]),R.opsetImport.push(Z.onnx.OperatorSetIdProto.decode(J,J.uint32()));break}case 10:{R.domain=J.string();break}default:J.skipType(z&7);break}}return R},G.decodeDelimited=function(J){return J instanceof K||(J=new K(J)),this.decode(J,J.uint32())},G.verify=function(J){if(typeof J!="object"||J===null)return"object expected";if(J.name!=null&&J.hasOwnProperty("name")&&!U.isString(J.name))return"name: string expected";if(J.input!=null&&J.hasOwnProperty("input")){if(!Array.isArray(J.input))return"input: array expected";for(var X=0;X<J.input.length;++X)if(!U.isString(J.input[X]))return"input: string[] expected"}if(J.output!=null&&J.hasOwnProperty("output")){if(!Array.isArray(J.output))return"output: array expected";for(var X=0;X<J.output.length;++X)if(!U.isString(J.output[X]))return"output: string[] expected"}if(J.attribute!=null&&J.hasOwnProperty("attribute")){if(!Array.isArray(J.attribute))return"attribute: array expected";for(var X=0;X<J.attribute.length;++X)if(!U.isString(J.attribute[X]))return"attribute: string[] expected"}if(J.attributeProto!=null&&J.hasOwnProperty("attributeProto")){if(!Array.isArray(J.attributeProto))return"attributeProto: array expected";for(var X=0;X<J.attributeProto.length;++X){var V=Z.onnx.AttributeProto.verify(J.attributeProto[X]);if(V)return"attributeProto."+V}}if(J.node!=null&&J.hasOwnProperty("node")){if(!Array.isArray(J.node))return"node: array expected";for(var X=0;X<J.node.length;++X){var V=Z.onnx.NodeProto.verify(J.node[X]);if(V)return"node."+V}}if(J.docString!=null&&J.hasOwnProperty("docString")&&!U.isString(J.docString))return"docString: string expected";if(J.opsetImport!=null&&J.hasOwnProperty("opsetImport")){if(!Array.isArray(J.opsetImport))return"opsetImport: array expected";for(var X=0;X<J.opsetImport.length;++X){var V=Z.onnx.OperatorSetIdProto.verify(J.opsetImport[X]);if(V)return"opsetImport."+V}}return J.domain!=null&&J.hasOwnProperty("domain")&&!U.isString(J.domain)?"domain: string expected":null},G.fromObject=function(J){if(J instanceof Z.onnx.FunctionProto)return J;var X=new Z.onnx.FunctionProto;if(J.name!=null&&(X.name=String(J.name)),J.input){if(!Array.isArray(J.input))throw TypeError(".onnx.FunctionProto.input: array expected");X.input=[];for(var V=0;V<J.input.length;++V)X.input[V]=String(J.input[V])}if(J.output){if(!Array.isArray(J.output))throw TypeError(".onnx.FunctionProto.output: array expected");X.output=[];for(var V=0;V<J.output.length;++V)X.output[V]=String(J.output[V])}if(J.attribute){if(!Array.isArray(J.attribute))throw TypeError(".onnx.FunctionProto.attribute: array expected");X.attribute=[];for(var V=0;V<J.attribute.length;++V)X.attribute[V]=String(J.attribute[V])}if(J.attributeProto){if(!Array.isArray(J.attributeProto))throw TypeError(".onnx.FunctionProto.attributeProto: array expected");X.attributeProto=[];for(var V=0;V<J.attributeProto.length;++V){if(typeof J.attributeProto[V]!="object")throw TypeError(".onnx.FunctionProto.attributeProto: object expected");X.attributeProto[V]=Z.onnx.AttributeProto.fromObject(J.attributeProto[V])}}if(J.node){if(!Array.isArray(J.node))throw TypeError(".onnx.FunctionProto.node: array expected");X.node=[];for(var V=0;V<J.node.length;++V){if(typeof J.node[V]!="object")throw TypeError(".onnx.FunctionProto.node: object expected");X.node[V]=Z.onnx.NodeProto.fromObject(J.node[V])}}if(J.docString!=null&&(X.docString=String(J.docString)),J.opsetImport){if(!Array.isArray(J.opsetImport))throw TypeError(".onnx.FunctionProto.opsetImport: array expected");X.opsetImport=[];for(var V=0;V<J.opsetImport.length;++V){if(typeof J.opsetImport[V]!="object")throw TypeError(".onnx.FunctionProto.opsetImport: object expected");X.opsetImport[V]=Z.onnx.OperatorSetIdProto.fromObject(J.opsetImport[V])}}return J.domain!=null&&(X.domain=String(J.domain)),X},G.toObject=function(J,X){X||(X={});var V={};if((X.arrays||X.defaults)&&(V.input=[],V.output=[],V.attribute=[],V.node=[],V.opsetImport=[],V.attributeProto=[]),X.defaults&&(V.name="",V.docString="",V.domain=""),J.name!=null&&J.hasOwnProperty("name")&&(V.name=J.name),J.input&&J.input.length){V.input=[];for(var R=0;R<J.input.length;++R)V.input[R]=J.input[R]}if(J.output&&J.output.length){V.output=[];for(var R=0;R<J.output.length;++R)V.output[R]=J.output[R]}if(J.attribute&&J.attribute.length){V.attribute=[];for(var R=0;R<J.attribute.length;++R)V.attribute[R]=J.attribute[R]}if(J.node&&J.node.length){V.node=[];for(var R=0;R<J.node.length;++R)V.node[R]=Z.onnx.NodeProto.toObject(J.node[R],X)}if(J.docString!=null&&J.hasOwnProperty("docString")&&(V.docString=J.docString),J.opsetImport&&J.opsetImport.length){V.opsetImport=[];for(var R=0;R<J.opsetImport.length;++R)V.opsetImport[R]=Z.onnx.OperatorSetIdProto.toObject(J.opsetImport[R],X)}if(J.domain!=null&&J.hasOwnProperty("domain")&&(V.domain=J.domain),J.attributeProto&&J.attributeProto.length){V.attributeProto=[];for(var R=0;R<J.attributeProto.length;++R)V.attributeProto[R]=Z.onnx.AttributeProto.toObject(J.attributeProto[R],X)}return V},G.prototype.toJSON=function(){return this.constructor.toObject(this,j.util.toJSONOptions)},G.getTypeUrl=function(J){return J===void 0&&(J="type.googleapis.com"),J+"/onnx.FunctionProto"},G}(),q}(),H.exports=Z}),V1,x4,Q8,R3,t2,i1,G3,u,L6,R5,h4,b4,Q1=E(()=>{H7(),a2(),V1=Z4(l4()),K4(),x4=class{static arraysEqual(Q,H){if(Q.length!==H.length)return!1;for(let j=0;j<Q.length;j++)if(Q[j]!==H[j])return!1;return!0}},Q8=class{static preprocessInputShapes(Q,H){let j=Q.length===1?[1,Q[0]]:Q,K=H.length===1?[H[0],1]:H;return[j,K]}static postprocessOutputShape(Q,H,j){H===1&&Q.splice(Q.length-2,1),j===1&&Q.pop()}static calcMatMulShape(Q,H){return Q[1]!==H[0]?void 0:[Q[0],H[1]]}},R3=class Q{static calcShape(H,j,K=!1){let W=H.length,U=j.length;if(W===0)return j;if(U===0)return H;let Z=Math.max(H.length,j.length),q=new Array(Z);if(K){if(W<2||U<2)return;let G=Q8.calcMatMulShape([H[W-2],H[W-1]],[j[U-2],j[U-1]]);if(G===void 0)return;[q[Z-2],q[Z-1]]=G}for(let G=K?3:1;G<=Z;G++){let J=W-G<0?1:H[W-G],X=U-G<0?1:j[U-G];if(J!==X&&J>1&&X>1)return;q[Z-G]=Math.max(J,X)}return q}static index(H,j){let K=new Array(j.length);return Q.fillIndex(H,j,K),K}static fillIndex(H,j,K){let W=H.length-j.length;for(let U=0;U<j.length;U++)K[U]=H[W+U]%j[U]}static calc(H,j,K,W,U){let Z=Q.calcShape(H.dims,j.dims);if(Z){if(W&&!u.areEqual(Z,H.dims))return;let q=u.size(Z),G=W?H:new o1(Z,U||H.type);if(Z.length===0)G.set([],K(H.get([]),j.get([])));else{let J=new Array(Z.length),X=new Array(H.dims.length),V=new Array(j.dims.length),R=0,z=0,Y=!1,B=!1;H.dims.length===0&&(R=H.get([]),Y=!0),j.dims.length===0&&(z=j.get([]),B=!0);let k;for(let w=0;w<q;w++){k=w;for(let A=Z.length-1;A>=0;A--)J[A]=k%Z[A],k=Math.floor(k/Z[A]);Y||(Q.fillIndex(J,H.dims,X),R=H.get(X)),B||(Q.fillIndex(J,j.dims,V),z=j.get(V)),G.set(J,K(R,z))}}return G}}static isValidBroadcast(H,j){let K=H.length,W=j.length;if(K>W)return!1;for(let U=1;U<=K;U++)if(H[K-U]!==1&&H[K-U]!==j[W-U])return!1;return!0}static getBroadcastDims(H,j){let K=H.length,W=[];for(let U=0;U<K;U++){let Z=K-1-U,q=H[Z]||1;(j[j.length-1-U]||1)>1&&q===1&&W.unshift(Z)}return W}},t2=class{static getShapeOfGemmResult(Q,H,j,K,W){if(Q.length!==2||j.length!==2)throw new Error("shape need to be of size 2");let U,Z,q;H?(U=Q[1],Z=Q[0]):(U=Q[0],Z=Q[1]);let G=-1;if(K?(q=j[0],G=1):(q=j[1],G=0),j[G]!==Z)throw new Error("dimension mismatch");if(U<=0||q<=0||Z<=0)throw new Error("invalid shape specified");if(W&&!R3.isValidBroadcast(W,[U,q]))throw new Error("gemm: invalid bias shape for broadcast");return[U,q,Z]}},i1=class Q{static tensorDataTypeFromProto(H){switch(H){case V1.onnx.TensorProto.DataType.INT8:return"int8";case V1.onnx.TensorProto.DataType.UINT8:return"uint8";case V1.onnx.TensorProto.DataType.BOOL:return"bool";case V1.onnx.TensorProto.DataType.INT16:return"int16";case V1.onnx.TensorProto.DataType.UINT16:return"uint16";case V1.onnx.TensorProto.DataType.INT32:return"int32";case V1.onnx.TensorProto.DataType.UINT32:return"uint32";case V1.onnx.TensorProto.DataType.FLOAT:return"float32";case V1.onnx.TensorProto.DataType.DOUBLE:return"float64";case V1.onnx.TensorProto.DataType.STRING:return"string";case V1.onnx.TensorProto.DataType.INT64:return"int32";case V1.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${V1.onnx.TensorProto.DataType[H]}`)}}static tensorDataTypeStringToEnum(H){switch(H){case"int8":return V1.onnx.TensorProto.DataType.INT8;case"uint8":return V1.onnx.TensorProto.DataType.UINT8;case"bool":return V1.onnx.TensorProto.DataType.BOOL;case"int16":return V1.onnx.TensorProto.DataType.INT16;case"uint16":return V1.onnx.TensorProto.DataType.UINT16;case"int32":return V1.onnx.TensorProto.DataType.INT32;case"uint32":return V1.onnx.TensorProto.DataType.UINT32;case"float32":return V1.onnx.TensorProto.DataType.FLOAT;case"float64":return V1.onnx.TensorProto.DataType.DOUBLE;case"string":return V1.onnx.TensorProto.DataType.STRING;case"int64":return V1.onnx.TensorProto.DataType.INT64;case"uint64":return V1.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${H}`)}}static tensorDimsFromProto(H){return H.map((j)=>_3.isLong(j)?j.toNumber():j)}static tensorValueTypeFromProto(H){return{tensorType:Q.tensorDataTypeFromProto(H.elemType),shape:{dims:Q.tensorDimsFromProto(H.shape.dim.map((j)=>j.dimValue))}}}static tensorDimsFromORTFormat(H){let j=[];for(let K=0;K<H.dimsLength();K++)j.push(G3.longToNumber(H.dims(K)));return j}static tensorAttributesFromORTFormat(H){let j=[];for(let K=0;K<H.attributesLength();K++)j.push(H.attributes(K));return j}},G3=class{static longToNumber(Q,H){return _3.isLong(Q)?Q.toNumber():Q instanceof $.Long?_3.fromValue({low:Q.low,high:Q.high,unsigned:H??!1}).toNumber():Q}static isLong(Q){return _3.isLong(Q)||Q instanceof $.Long}},u=class Q{static size(H){return Q.getSizeFromDimensionRange(H,0,H.length)}static sizeFromDimension(H,j){if(j<0||j>H.length)throw new Error(`invalid dimension of ${j} for sizeFromDimension as Tensor has ${H.length} dimensions.`);return Q.getSizeFromDimensionRange(H,j,H.length)}static sizeToDimension(H,j){if(j<0||j>H.length)throw new Error(`invalid dimension of ${j} for sizeToDimension as Tensor has ${H.length} dimensions.`);return Q.getSizeFromDimensionRange(H,0,j)}static getSizeFromDimensionRange(H,j,K){let W=1;for(let U=j;U<K;U++){if(H[U]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");W*=H[U]}return W}static computeStrides(H){let j=H.length;if(j===0)return[];if(j===1)return[1];let K=new Array(j);K[j-1]=1,K[j-2]=H[j-1];for(let W=j-3;W>=0;--W)K[W]=K[W+1]*H[W+1];return K}static transpose(H){return H.slice().reverse()}static indicesToOffset(H,j,K){K===void 0&&(K=H.length);let W=0;for(let U=0;U<K;++U)W+=j[U]*H[U];return W}static offsetToIndices(H,j){let K=j.length;if(K===0)return[];if(K===1)return[H*j[0]];let W=new Array(j.length);for(let U=0;U<W.length-1;++U)W[U]=Math.floor(H/j[U]),H-=W[U]*j[U];return W[W.length-1]=H,W}static normalizeAxis(H,j){if(H<-j&&H>=j)throw new Error("unsupported axis for this operation.");return H<0?H+j:H}static normalizeAxes(H,j){return H.map((K)=>this.normalizeAxis(K,j))}static incrementIndex(H,j,K){if(j.length===0||H.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(K===void 0)K=j.length;else if(K<=0||K>j.length)throw new Error("Incorrect axis to increment on");for(let W=K-1;W>=0&&(H[W]++,!(H[W]<j[W]));--W)H[W]=0}static calculateReshapedDims(H,j){if(j.length===0){if(H.length===0||Q.size(H)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}let K=j.length,W=new Array(K),U=-1,Z=1;for(let G=0;G<K;G++){if(j[G]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(j[G]===-1){if(U!==-1)throw new Error("at most one dimension in shape hints can be -1");U=G}else{if(j[G]===0){if(G>=H.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");W[G]=H[G]}else W[G]=j[G];Z*=W[G]}}let q=Q.size(H);if(U!==-1){if(q%Z!==0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${H}] Output shape: [${j}]`);W[U]=q/Z}else if(Z!==q)throw new Error("reshapedDims and originalDims don't have matching sizes");return W}static sortBasedOnPerm(H,j){return j?j.map((K)=>H[K]):H.slice().reverse()}static padShape(H,j){let K=H.length;return H.map((W,U)=>W+j[U]+j[U+K])}static areEqual(H,j){return H.length!==j.length?!1:H.every((K,W)=>K===j[W])}static validateDimsAndCalcSize(H){if(H.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let j=1;for(let K of H){if(!Number.isInteger(K))throw new TypeError(`Invalid shape: ${K} is not an integer`);if(K<0||K>2147483647)throw new TypeError(`Invalid shape: length ${K} is not allowed`);j*=K}return j}static flattenShape(H,j){j<0&&(j+=H.length);let K=H.reduce((U,Z)=>U*Z,1),W=H.slice(j).reduce((U,Z)=>U*Z,1);return[K/W,W]}static squeezeShape(H,j){let K=new Array;j=Q.normalizeAxes(j,H.length);for(let W=0;W<H.length;W++){let U=j.indexOf(W)>=0;if(U&&H[W]!==1)throw new Error("squeeze an axis of size different than 1");(j.length===0&&H[W]>1||j.length>0&&!U)&&K.push(H[W])}return K}static unsqueezeShape(H,j){let K=new Array(H.length+j.length);K.fill(0);for(let U=0;U<j.length;U++){let Z=Q.normalizeAxis(j[U],K.length);if(Z>=K.length)throw new Error("'axes' has an out of range axis");if(K[Z]!==0)throw new Error("'axes' has a duplicate axis");K[Z]=1}let W=0;for(let U=0;U<K.length;U++)K[U]===0&&(K[U]=H[W++]);if(W!==H.length)throw new Error("the unsqueezed dimension could not be established");return K}},L6=class Q{static splitShape(H,j,K,W){if(K.length===0){if(!W)throw new Error("need to know number of outputs when the 'split' attribute is not specified");Q.determineSplit(H[j],W,K)}let U=[],Z=[0];for(let q=0;q<K.length;++q){q!==0&&Z.push(Z[q-1]+K[q-1]);let G=H.slice();G[j]=K[q],U.push(G)}return[U,Z]}static determineSplit(H,j,K){if(H%j!==0)throw new Error("cannot split tensor to equal sized parts");for(let W=0;W<j;++W)K.push(H/j)}},R5=class Q{static adjustPoolAttributes(H,j,K,W,U,Z){if(!H&&K.length!==j.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(H)for(let q=0;q<j.length-2;q++)q>=K.length?K.push(j[q+2]):K[q]=j[q+2];for(let q=0;q<K.length;q++)if(q<W.length){if(W[q]<0)throw new Error("strides should be greater than or equal to 1")}else W.push(1);for(let q=0;q<K.length;q++)if(q<U.length){if(U[q]<0)throw new Error("dilations should be greater than or equal to 1")}else U.push(1);for(let q=0;q<K.length*2;q++)if(q<Z.length){if(Z[q]<0)throw new Error("pad should be greater than or equal to 1")}else Z.push(0);for(let q=0;q<K.length;q++){if(K[q]<=0)throw new Error("kernel shapes need to be greater than 0");if(Z[q]>=K[q]||Z[q+K.length]>=K[q])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(H,j,K,W,U,Z){if(Z){if(U.length!==2*(H.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(j.length!==H.length-2)throw new Error("length of strides should be the length of data dimensions");if(W.length!==H.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let q=0;q<H.length-2;q++)Q.adjustPadAndReturnShape(H[q+2],j[q],K[q],W[q],U,q,q+H.length-2,Z)}}static computePoolOutputShape(H,j,K,W,U,Z,q){if(j.length<=0)throw new Error("input shape must be of size greater than 0");let G=[j[0],j[1]];return Q.computeShapeHelper(H,j,G,K,W,U,Z,q),G}static computeConvOutputShape(H,j,K,W,U,Z,q){if(H.length<=0||j.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let G=[H[0],j[0]];return Q.computeShapeHelper(!1,H,G,K,W,U,Z,q),G}static computeShapeHelper(H,j,K,W,U,Z,q,G){if(H)for(let J=0;J<j.length-2;J++)K.push(1);else for(let J=0;J<j.length-2;J++)K.push(Q.adjustPadAndReturnShape(j[J+2],W[J],U[J],Z[J],q,J,J+j.length-2,G))}static adjustPadAndReturnShape(H,j,K,W,U,Z,q,G){let J=K*(W-1)+1;if(G&&G!=="NOTSET")switch(G){case"VALID":return U[Z]=0,U[q]=0,Math.floor((H-J)/j+1);case"SAME_LOWER":case"SAME_UPPER":if(K!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let X=((H+j-1)/j-1)*j+W-H;return U[Z]=Math.floor(G==="SAME_LOWER"?(X+1)/2:X/2),U[q]=X-U[Z],Math.floor((H+X-W)/j+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((H+U[Z]+U[q]-J)/j+1)}},h4=-340282346638528860000000000000000000000,b4=340282346638528860000000000000000000000}),J8,o,q5,o1,K4=E(()=>{J8=Z4(nZ()),a2(),B5(),o=Z4(l4()),Q1(),q5=H1.experimental.fbs,o1=class Q{constructor(H,j,K,W,U,Z=J8.Guid.create()){this.dims=H,this.type=j,this.dataProvider=K,this.asyncDataProvider=W,this.cache=U,this.dataId=Z,this.size=u.validateDimsAndCalcSize(H);let q=this.size,G=K===void 0&&W===void 0&&U===void 0;if(U!==void 0&&U.length!==q)throw new RangeError("Input dims doesn't match data length.");if(j==="string"){if(U!==void 0&&(!Array.isArray(U)||!U.every((J)=>typeof J=="string")))throw new TypeError("cache should be a string array");G&&(this.cache=new Array(q))}else{if(U!==void 0){let J=A2(j);if(!(U instanceof J))throw new TypeError(`cache should be type ${J.name}`)}if(G){let J=new ArrayBuffer(q*$H(j));this.cache=LH(J,j)}}}get data(){if(this.cache===void 0){let H=this.dataProvider(this.dataId);if(H.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=H}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(H){return this.data[u.indicesToOffset(H,this.strides)]}set(H,j){this.data[u.indicesToOffset(H,this.strides)]=j}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=u.computeStrides(this.dims)),this._strides}static fromProto(H){if(!H)throw new Error("cannot construct Value from an empty tensor");let j=i1.tensorDataTypeFromProto(H.dataType),K=i1.tensorDimsFromProto(H.dims),W=new Q(K,j);if(j==="string")H.stringData.forEach((U,Z)=>{W.data[Z]=N6(U)});else if(H.rawData&&typeof H.rawData.byteLength=="number"&&H.rawData.byteLength>0){let U=W.data,Z=new DataView(H.rawData.buffer,H.rawData.byteOffset,H.rawData.byteLength),q=f7(H.dataType),G=H.rawData.byteLength/q;if(H.rawData.byteLength%q!==0)throw new Error("invalid buffer length");if(U.length!==G)throw new Error("buffer length mismatch");for(let J=0;J<G;J++){let X=l7(Z,H.dataType,J*q);U[J]=X}}else{let U;switch(H.dataType){case o.onnx.TensorProto.DataType.FLOAT:U=H.floatData;break;case o.onnx.TensorProto.DataType.INT32:case o.onnx.TensorProto.DataType.INT16:case o.onnx.TensorProto.DataType.UINT16:case o.onnx.TensorProto.DataType.INT8:case o.onnx.TensorProto.DataType.UINT8:case o.onnx.TensorProto.DataType.BOOL:U=H.int32Data;break;case o.onnx.TensorProto.DataType.INT64:U=H.int64Data;break;case o.onnx.TensorProto.DataType.DOUBLE:U=H.doubleData;break;case o.onnx.TensorProto.DataType.UINT32:case o.onnx.TensorProto.DataType.UINT64:U=H.uint64Data;break;default:throw new Error("unspecific error")}if(U==null)throw new Error("failed to populate data from a tensorproto value");let Z=W.data;if(Z.length!==U.length)throw new Error("array length mismatch");for(let q=0;q<U.length;q++){let G=U[q];_3.isLong(G)?Z[q]=M6(G,H.dataType):Z[q]=G}}return W}static fromData(H,j,K){return new Q(j,K,void 0,void 0,H)}static fromOrtTensor(H){if(!H)throw new Error("cannot construct Value from an empty tensor");let j=i1.tensorDimsFromORTFormat(H),K=i1.tensorDataTypeFromProto(H.dataType()),W=new Q(j,K);if(K==="string")for(let U=0;U<H.stringDataLength();U++)W.data[U]=H.stringData(U);else if(H.rawDataArray()&&typeof H.rawDataLength()=="number"&&H.rawDataLength()>0){let U=W.data,Z=new DataView(H.rawDataArray().buffer,H.rawDataArray().byteOffset,H.rawDataLength()),q=f7(H.dataType()),G=H.rawDataLength()/q;if(H.rawDataLength()%q!==0)throw new Error("invalid buffer length");if(U.length!==G)throw new Error("buffer length mismatch");for(let J=0;J<G;J++){let X=l7(Z,H.dataType(),J*q);U[J]=X}}return W}}}),e2,Q0,W1=E(()=>{e2={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},Q0={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"}}),t=E(()=>{}),F3=E(()=>{Q1()}),U4=E(()=>{F3()}),b5,H8,J0,Rj=E(()=>{W1(),t(),F3(),U4(),b5={name:"pack",inputNames:["A"],inputTypes:[1]},H8=(Q,H)=>{let j=r(Q.session.backend.glContext.version),K=H.dims,W=K.length,U=H.dims.length,Z=P3(U),q=n6("rc",U),G=IH(U,q,K[K.length-2],K[K.length-1]),J;W===0?J=[1,1]:W===1?J=[K[0],1]:J=[K[U-1],K[U-2]];let X=PH(U,J,q),V=EH(K,q),R=`
        void main() {
          ${Z} rc = getOutputCoords();

          if(${X}) {
            ${j.output} = vec4(0);
          } else {
            ${G}

            ${j.output} = vec4(${V});
          }
        }
      `;return{...b5,hasMain:!0,output:{dims:H.dims,type:H.type,textureType:2},shaderSource:R}},J0=(Q,H)=>({...b5,get:()=>H8(Q,H)})}),Z8,j8,H0,zj=E(()=>{Q1(),W1(),t(),U4(),Z8=(Q)=>({name:"Reshape (packed)",inputTypes:[2],inputNames:["A"],cacheHint:`${Q}`}),j8=(Q,H,j,K)=>{let W=H.dims,U=K,Z="";for(let J=0;J<4;J++){let X="";switch(J){case 0:X="outputCoords = rc;";break;case 1:X="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:X="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:X="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}Z+=`
        ${X}
        ${J>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${J}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${J>0?"}":""}
      `}let q=r(Q.session.backend.glContext.version),G=`
      ${OH(W)}
      ${gH(U)}
      ${c4()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${U[2]};
        int cols = ${U[1]};

        ${Z}
        ${q.output} = result;
      }
    `;return{...j,output:{dims:U,type:H.type,textureType:2},shaderSource:G,hasMain:!0}},H0=(Q,H,j)=>{let K=Z8(j);return{...K,get:()=>j8(Q,H,K,j)}}}),v6,Nj=E(()=>{W1(),t(),v6=(Q,H)=>{let j=H.shape,K=r(Q.session.backend.glContext.version),W=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${K.texture2D}(X,TexCoords).r;
      ${K.output} = encodeAsUint8(value);
    }`,U={name:"Uint8Encode",inputTypes:[0],inputNames:["X"],output:{dims:j,type:H.tensor.type,textureType:3},shaderSource:W,hasMain:!0};return Q.executeProgram(U,[H.tensor])}}),m5,V8,Z0,Mj=E(()=>{W1(),t(),F3(),U4(),m5={name:"unpack",inputNames:["A"],inputTypes:[2]},V8=(Q,H)=>{let j=H.dims.length,K=n6("rc",j),W=K.slice(-2),U=P3(j),Z=c4(),q=H.dims.length===0?"":yH(j,K),G=j<=1?"rc":`vec2(${W.join(",")})`,J=r(Q.session.backend.glContext.version),X=`
    ${Z}
    void main() {
      ${U} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${q});

       ${J.output} = vec4(getChannel(packedInput, ${G}), 0, 0, 0);
     }
   `;return{...m5,hasMain:!0,output:{dims:H.dims,type:H.type,textureType:0},shaderSource:X}},Z0=(Q,H)=>({...m5,get:()=>V8(Q,H)})}),j0,w6,V0,z5=E(()=>{V3(),j0=class{constructor(Q,H=1){if(H===1)this.internalFormat=Q.R32F,this.format=Q.RED,this.textureType=Q.FLOAT,this.channelSize=H;else if(H===4)this.internalFormat=Q.RGBA32F,this.format=Q.RGBA,this.textureType=Q.FLOAT,this.channelSize=H;else throw new Error(`Invalid number of channels: ${H}`)}encode(Q,H){let j,K;return Q.constructor!==Float32Array&&(C1.warning("Encoder","data was not of type Float32; creating new Float32Array"),K=new Float32Array(Q)),H*this.channelSize>Q.length?(C1.warning("Encoder","Source data too small. Allocating larger array"),K=Q,j=this.allocate(H*this.channelSize),K.forEach((W,U)=>j[U]=W)):(K=Q,j=K),j}allocate(Q){return new Float32Array(Q*4)}decode(Q,H){return this.channelSize===1?Q.filter((j,K)=>K%4===0).subarray(0,H):Q.subarray(0,H)}},w6=class{constructor(Q,H=1,j){if(H!==1&&H!==4)throw new Error(`Invalid number of channels: ${H}`);this.internalFormat=Q.RGBA,this.format=Q.RGBA,this.channelSize=H,this.textureType=j||Q.FLOAT}encode(Q,H){let j=Q;return this.channelSize===1&&(C1.verbose("Encoder","Exploding into a larger array"),j=this.allocate(H),Q.forEach((K,W)=>j[W*4]=K)),j}allocate(Q){return new Float32Array(Q*4)}decode(Q,H){return this.channelSize===1?Q.filter((j,K)=>K%4===0).subarray(0,H):Q.subarray(0,H)}},V0=class{constructor(Q,H=1){if(this.channelSize=4,H===1)this.internalFormat=Q.ALPHA,this.format=Q.ALPHA,this.textureType=Q.UNSIGNED_BYTE,this.channelSize=H;else if(H===4)this.internalFormat=Q.RGBA,this.format=Q.RGBA,this.textureType=Q.UNSIGNED_BYTE,this.channelSize=H;else throw new Error(`Invalid number of channels: ${H}`)}encode(Q,H){return new Uint8Array(Q.buffer,Q.byteOffset,Q.byteLength)}allocate(Q){return new Uint8Array(Q*this.channelSize)}decode(Q,H){if(Q instanceof Uint8Array)return Q.subarray(0,H);throw new Error(`Invalid array type: ${Q.constructor}`)}}}),g4,X0,T6,Yj=E(()=>{Q1(),t(),g4=(Q,H,j)=>{let K=j===0||j===1?1:4,W=j===2,U=j===1||j===2,Z=j===4?H.length-1:void 0,q=j===4?H.map((G,J)=>J===H.length-1?G*4:G):void 0;return T6(Q,H,K,q,{isPacked:W,reverseWH:U,breakAxis:Z})},X0=(Q,H,j)=>{let K=g4(Q,H,j);return[K.width,K.height]},T6=(Q,H,j=1,K,W)=>{let U=!!(W&&W.isPacked),[Z,q]=Q.computeTextureWH(U&&K||H,W),G=H.length,J=H.slice(0);if(G===0&&(J=[1]),j===1)K=H;else if(U){if(j!==4)throw new Error("a packed texture must be 4-channel");K=H,G>0&&(J[G-1]=Math.ceil(J[G-1]/2)),G>1&&(J[G-2]=Math.ceil(J[G-2]/2))}else if(!K)throw new Error("Unpacked shape is needed when using channels > 1");return{width:Z,height:q,channels:j,isPacked:U,shape:J,strides:u.computeStrides(J),unpackedShape:K,reversedWH:W&&W.reverseWH}}}),X8,K0,Cj=E(()=>{V3(),K4(),Q1(),Rj(),zj(),Nj(),Mj(),z5(),Yj(),t(),X8=(Q,H)=>{let j=H.map((W)=>`${W.unpackedShape.join(",")};${W.width}x${W.height}`).join("_"),K=Q.name;return Q.cacheHint&&(K+="["+Q.cacheHint+"]"),K+=":"+j,K},K0=class{constructor(Q){this.session=Q,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(Q,H){return X0(this.session.layoutStrategy,Q,H)}executeProgram(Q,H){if(H.length<Q.inputNames.length)throw new Error(`Input size mustn't be less than ${Q.inputNames.length}.`);if(Q.inputNames.length!==Q.inputTypes.length)throw new Error("input names size does not match input types");let j=[];for(let G=0;G<Q.inputNames.length;++G)j[G]=this.getOrCreateTextureData(H[G],Q.inputTypes[G]);let K=X8(Q,j),W=this.session.programManager.getArtifact(K),U=W?W.programInfo:typeof Q.get=="function"?Q.get():Q,Z=g4(this.session.layoutStrategy,U.output.dims,U.output.textureType),q=this.createTextureData(Z,U.output.type);return W||(W=this.session.programManager.build(U,j,q),this.session.programManager.setArtifact(K,W)),this.runProgram(W,j,q),q}run(Q,H){return this.executeProgram(Q,H).tensor}runProgram(Q,H,j){for(let K=0;K<H.length;++K)if(!!H[K].isPacked!=(Q.programInfo.inputTypes[K]===2))throw new Error(`input[${K}] property packed inconsistent`);if(!!j.isPacked!=(Q.programInfo.output.textureType===2))throw new Error("output property packed inconsistent");this.session.programManager.run(Q,H,j)}getOrCreateTextureData(Q,H){let j=this.getTextureData(Q.dataId,H===2);if(!j&&(j=this.getTextureData(Q.dataId,H!==2),j))return H===2?this.pack(j):this.unpack(j);if(!j){let K=g4(this.session.layoutStrategy,Q.dims,H);if(H===4){let W=Q.dims;if(W.length===4){let U=[W[0],Math.ceil(W[1]*W[2]*W[3]/4)],Z=g4(this.session.layoutStrategy,U,H),q=Q.numberData;if(W[1]*W[2]*W[3]%4!==0){let G=W[0],J=W[1]*W[2]*W[3],X=Math.ceil(J*1/4)*4,V=G*X;q=new Float32Array(V);for(let R=0;R<G;++R){let z=R*J,Y=R*X+R%1*J;q.set(Q.numberData.subarray(z,z+J),Y)}}return this.createTextureData(Z,Q.type,q,Q,1)}}if(H===2){let W=T6(this.session.layoutStrategy,Q.dims,1,[],{reverseWH:!0}),U=this.createTextureData(W,Q.type,Q.numberData,Q,1);j=this.pack(U)}else j=this.createTextureData(K,Q.type,Q.numberData,Q,1)}return j}createTextureDataFromLayoutBindTensor(Q,H,j,K){return this.createTextureData(Q,H,j,K,1)}createTextureData(Q,H,j,K,W){C1.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(Q)}]`);let U=this.session.textureManager.createTextureFromLayout(H,Q,j,W);return this.createTextureDataFromTexture(Q,H,U,K)}reshapeUnpacked(Q,H){let j=this.getOrCreateTextureData(Q,0),K={channels:j.channels,height:j.height,width:j.width,shape:H.length!==0?H:[1],strides:u.computeStrides(H),unpackedShape:H};return this.createTextureDataFromTexture(K,Q.type,j.texture).tensor}reshapePacked(Q,H){let j=this.getOrCreateTextureData(Q,2);if(xH(Q.dims,H)){let q={channels:j.channels,height:j.height,width:j.width,shape:H.length!==0?H:[1],strides:u.computeStrides(H),unpackedShape:H,isPacked:!0};return this.createTextureDataFromTexture(q,Q.type,j.texture).tensor}let K=s7(Q.dims),W=s7(H),U=this.reshapePacked(Q,K),Z=this.run(H0(this,U,W),[U]);return this.reshapePacked(Z,H)}cast(Q,H){let j=this.getOrCreateTextureData(Q,0);return this.createTextureDataFromTexture(j,H,j.texture).tensor}createTextureDataFromTexture(Q,H,j,K,W){let U={...Q,tensor:K||new o1(Q.unpackedShape,H,(Z)=>this.readTexture(U),async(Z)=>this.readTextureAsync(U),void 0,W),texture:j};return this.setTextureData(U.tensor.dataId,U,Q.isPacked),U}getTextureData(Q,H=!1){return this.session.isInitializer(Q)?this.session.getTextureData(Q,H):H?this.packedTextureDataCache.get(Q):this.unpackedTextureDataCache.get(Q)}setTextureData(Q,H,j=!1){this.session.isInitializer(Q)?this.session.setTextureData(Q,H,j):(j?this.packedTextureDataCache:this.unpackedTextureDataCache).set(Q,H)}isTextureLayoutCached(Q,H=!1){return!!this.getTextureData(Q.dataId,H)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((Q)=>this.session.textureManager.releaseTexture(Q)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((Q)=>this.session.textureManager.releaseTexture(Q)),this.unpackedTextureDataCache=new Map}readTexture(Q){return Q.isPacked?this.readTexture(this.unpack(Q)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(Q,Q.tensor.type,Q.channels):this.session.textureManager.readUint8TextureAsFloat(v6(this,Q))}async readTextureAsync(Q){return Q.isPacked?this.readTextureAsync(this.unpack(Q)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(Q,Q.tensor.type,Q.channels):this.session.textureManager.readUint8TextureAsFloat(v6(this,Q))}pack(Q){return this.executeProgram(J0(this,Q.tensor),[Q.tensor])}unpack(Q){return this.executeProgram(Z0(this,Q.tensor),[Q.tensor])}}}),K8,K1,_1=E(()=>{K8=class{constructor(Q){Object.assign(this,Q)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map((Q)=>`${this[Q]}`).join(";")),this.key}},K1=(Q)=>new K8(Q)}),c5,U0,q0,U8,q8,Bj=E(()=>{_1(),W1(),t(),c5={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[0,0,0,0,0]},U0=(Q,H,j)=>(q8(H),[Q.run({...c5,cacheHint:j.cacheKey,get:()=>U8(Q,H,j)},H)]),q0=(Q)=>{let H=Q.attributes.getFloat("epsilon",0.00001),j=Q.attributes.getFloat("momentum",0.9),K=Q.attributes.getInt("spatial",1);return K1({epsilon:H,momentum:j,spatial:K})},U8=(Q,H,j)=>{let K=r(Q.session.backend.glContext.version),W=H[0].dims.length,[U,Z]=Q.calculateTextureWidthAndHeight(H[1].dims,0),q=`
  float process(int[${W}] indices) {
    vec2 position = offsetToCoords(indices[1], ${U}, ${Z});
    float scale = getColorAsFloat(${K.texture2D}(Scale, position));
    float mean = getColorAsFloat(${K.texture2D}(Mean, position));
    float variance = getColorAsFloat(${K.texture2D}(Variance, position));
    float b = getColorAsFloat(${K.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${j.epsilon})) ) + b;
  }`;return{...c5,output:{dims:H[0].dims,type:H[0].type,textureType:0},shaderSource:q}},q8=(Q)=>{if(!Q||Q.length!==5)throw new Error("BatchNormalization requires 5 inputs.");let H=Q[0],j=Q[1],K=Q[2],W=Q[3],U=Q[4];if(H.dims.length<3||j.dims.length!==1||K.dims.length!==1||W.dims.length!==1||U.dims.length!==1)throw new Error("invalid input shape.");if(j.dims[0]!==H.dims[1]||K.dims[0]!==H.dims[1]||W.dims[0]!==H.dims[1]||U.dims[0]!==H.dims[1])throw new Error("invalid input shape.");if(H.type!=="float32"&&H.type!=="float64"||j.type!=="float32"&&j.type!=="float64"||K.type!=="float32"&&K.type!=="float64"||W.type!=="float32"&&W.type!=="float64"||U.type!=="float32"&&U.type!=="float64")throw new Error("invalid input tensor types.")}}),W0,q4,y,D6,G0,E3=E(()=>{W0=class{constructor(Q,H,j,K){this.glContext=Q,this.programInfo=H,this.inputTextureLayouts=j,this.outputTextureLayout=K}},q4=class{constructor(Q){this.context=Q}},y=class{constructor(Q,H){this.routineBody=Q,this.dependencies=H}},D6=class{constructor(Q,H,j){this.name=Q,j?this.dependencies=j:this.dependencies=[],H&&(this.routineBody=H)}addDependency(Q){Q&&this.dependencies.push(Q)}},G0=class{static returnOrderedNodes(Q){if(!Q||Q.length===0)return[];if(Q.length===1)return Q;let H=new Set,j=new Set,K=new Array;return this.createOrderedNodes(Q,H,j,K),K}static createOrderedNodes(Q,H,j,K){for(let W=0;W<Q.length;++W)this.dfsTraverse(Q[W],H,j,K)}static dfsTraverse(Q,H,j,K){if(!Q||j.has(Q.name))return;if(H.has(Q.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");H.add(Q.name);let W=Q.dependencies;if(W&&W.length>0)for(let U=0;U<W.length;++U)this.dfsTraverse(W[U],H,j,K);K.push(Q),j.add(Q.name),H.delete(Q.name)}}}),u1,W8,R0,z0,N0,M0,Y0,C0,B0,F0,k0,A0,S0,$0,Fj=E(()=>{Q1(),E3(),W1(),t(),u1=(Q,H,j,K=H[0].type,W)=>{let U=Q.session.pack?2:0;return{name:j.name,inputNames:["A","B"],inputTypes:[U,U],cacheHint:W,get:()=>W8(Q,H,j,K)}},W8=(Q,H,j,K=H[0].type)=>{let W=Q.session.pack?2:0,U=!u.areEqual(H[0].dims,H[1].dims),Z=H[0].dims,q=Q.session.pack;if(U){let X=R3.calcShape(H[0].dims,H[1].dims,!1);if(!X)throw new Error("Can't perform binary op on the given tensors");Z=X;let V=Z.length,R=H[0].dims.length!==0?H[0].dims.length:1,z=H[1].dims.length!==0?H[1].dims.length:1,Y=H[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",B=H[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",k=r(Q.session.backend.glContext.version),w=q?`
      ${j.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${j.name}(a, b);
        ${k.output} = result;
      }`:`
      ${j.body}
      float process(int indices[${V}]) {
        int aindices[${R}];
        int bindices[${z}];
        ${Y}
        ${B}
        return ${j.name}(_A(aindices), _B(bindices));
      }`;return{name:j.name,inputNames:["A","B"],inputTypes:[W,W],output:{dims:Z,type:K,textureType:W},shaderSource:w,hasMain:q}}let G=r(Q.session.backend.glContext.version),J=`
    ${j.body}
    void main() {
      vec4 v1 = ${G.texture2D}(A, TexCoords);
      vec4 v2 = ${G.texture2D}(B, TexCoords);
      vec4 result = ${j.name}(v1, v2);
      ${G.output} = result;
    }
    `;return{name:j.name,inputNames:["A","B"],inputTypes:[W,W],output:{dims:H[0].dims,type:K,textureType:W},shaderSource:J,hasMain:!0}},R0=(Q,H)=>[Q.run(u1(Q,H,dH()),H)],z0=(Q,H)=>[Q.run(u1(Q,H,lH(),"bool"),H)],N0=(Q,H)=>[Q.run(u1(Q,H,pH()),H)],M0=(Q,H)=>[Q.run(u1(Q,H,mH(),"bool"),H)],Y0=(Q,H)=>[Q.run(u1(Q,H,cH(),"bool"),H)],C0=(Q,H)=>[Q.run(u1(Q,H,fH(),"bool"),H)],B0=(Q,H)=>[Q.run(u1(Q,H,hH()),H)],F0=(Q,H)=>[Q.run(u1(Q,H,uH(),"bool"),H)],k0=(Q,H)=>[Q.run(u1(Q,H,iH()),H)],A0=(Q,H)=>[Q.run(u1(Q,H,oH()),H)],S0=(Q,H)=>[Q.run(u1(Q,H,bH()),H)],$0=(Q,H)=>[Q.run(u1(Q,H,sH(),"bool"),H)]}),L0,v0,G8,kj=E(()=>{Q1(),L0=(Q,H,j)=>(G8(H),[Q.cast(H[0],j)]),v0=(Q)=>i1.tensorDataTypeFromProto(Q.attributes.getInt("to")),G8=(Q)=>{if(!Q||Q.length!==1)throw new Error("Cast requires 1 input.");if(Q[0].type==="string")throw new Error("Invalid input type.")}}),R8,z8,w0,$4,Aj=E(()=>{W1(),t(),F3(),U4(),R8=(Q,H)=>({name:"Concat (packed)",inputNames:Array.from({length:Q},(j,K)=>`X${K}`),inputTypes:Array(Q).fill(2),cacheHint:H}),z8=(Q,H,j,K)=>{let W=j[0].dims.slice();if(K>=W.length||K<-1*W.length)throw new Error("axis specified for concat doesn't match input dimensionality");K<0&&(K=W.length+K);let U=W.slice(0);for(let h=1;h<j.length;h++){let $1=j[h].dims.slice();for(let L1=0;L1<W.length;L1++)if(L1===K)U[K]+=$1[L1];else if(W[L1]!==$1[L1])throw new Error("non concat dimensions must match")}let Z=U.length,q=n6("coords",Z),G=P3(Z),J=c4(),X=j.map((h)=>h.dims),V=H4(Z),R=new Array(X.length-1);R[0]=X[0][K];for(let h=1;h<R.length;h++)R[h]=R[h-1]+X[h][K];let z=V[K],Y=V.slice(-2),B=V.join(),k=`if (${z} < ${R[0]}) {
        return getChannel(
            getX0(${B}), vec2(${Y.join()}));
        }`;for(let h=1;h<R.length;h++){let $1=R[h-1];k+=`
            if (${z} < ${R[h]}  && ${z} >= ${R[h-1]}) {
              return getChannel(
                getX${h}(${$4(V,z,$1)}),
                vec2(${$4(Y,z,$1)}));
            }`}let w=R.length,A=R[R.length-1];k+=`
            return getChannel(
              getX${w}(${$4(V,z,A)}),
              vec2(${$4(Y,z,A)}));`;let D=r(Q.session.backend.glContext.version),I=`
          ${J}
          float getValue(${V.map((h)=>"int "+h)}) {
            ${k}
          }

          void main() {
            ${G} coords = getOutputCoords();
            int lastDim = coords.${V[Z-1]};
            coords.${V[Z-1]} = coords.${V[Z-2]};
            coords.${V[Z-2]} = lastDim;

            vec4 result = vec4(getValue(${q}), 0., 0., 0.);

            ${q[Z-1]} = ${q[Z-1]} + 1;
            if (${q[Z-1]} < ${U[Z-1]}) {
              result.g = getValue(${q});
            }

            ${q[Z-2]} = ${q[Z-2]} + 1;
            if (${q[Z-2]} < ${U[Z-2]}) {
              result.a = getValue(${q});
            }

            ${q[Z-1]} = ${q[Z-1]} - 1;
            if (${q[Z-2]} < ${U[Z-2]} &&
                ${q[Z-1]} < ${U[Z-1]}) {
              result.b = getValue(${q});
            }
            ${D.output} = result;
          }
        `;return{...H,output:{dims:U,type:j[0].type,textureType:2},shaderSource:I,hasMain:!0}},w0=(Q,H,j)=>{let K=R8(H.length,j.cacheKey);return{...K,get:()=>z8(Q,K,H,j.axis)}},$4=(Q,H,j)=>{let K=Q.indexOf(H);return Q.map((W,U)=>U===K?`${W} - ${j}`:W).join()}}),T0,N8,M8,Y8,f5,C8,B8,F8,D0,k8,Sj=E(()=>{_1(),t(),Aj(),T0=(Q,H,j)=>(k8(H),Q.session.pack&&H[0].dims.length>1?[Q.run(w0(Q,H,j),H)]:[Q.run(Y8(Q,H,j),H)]),N8=(Q,H)=>({name:"Concat",inputNames:Array.from({length:Q},(j,K)=>`X${K}`),inputTypes:Array(Q).fill(0),cacheHint:H}),M8=(Q,H,j,K)=>{let W=j[0].dims.slice();if(K>=W.length||K<-1*W.length)throw new Error("axis specified for concat doesn't match input dimensionality");K<0&&(K=W.length+K);let U=W.slice(0);for(let z=1;z<j.length;z++){let Y=j[z].dims.slice();for(let B=0;B<W.length;B++)if(B===K)U[K]+=Y[B];else if(W[B]!==Y[B])throw new Error("non concat dimensions must match")}let Z=U.length,q=new Array(j.length),G=0;for(let z=0;z<q.length;++z)G+=j[z].dims[K],q[z]=G;let J="";j.length<5?J=f5(q):J=C8(q);let X=B8(j.length,Z),V=F8(q),R=`
        ${X}
        ${V}
        ${J}
        float process(int indices[${Z}]) {
          int textureIndex = getTextureWhereDataResides (indices[${K}]);

          if(textureIndex != 0) {
            indices[${K}] = indices[${K}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return{...H,output:{dims:U,type:j[0].type,textureType:0},shaderSource:R}},Y8=(Q,H,j)=>{let K=N8(H.length,j.cacheKey);return{...K,get:()=>M8(Q,K,H,j.axis)}},f5=(Q)=>`int getTextureWhereDataResides(int index) {
      ${Q.map((H,j)=>`if(index<${H}) {return ${j};}
`).join("")}
    }`,C8=(Q)=>f5(Q),B8=(Q,H)=>{let j=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${H}]) {`];for(let K=0;K<Q;++K)K===0?j.push(`	if (textureIndex == ${K}) { return _X${K}(indices); }`):K===Q-1?j.push(`	else { return _X${K}(indices); }`):j.push(`	else if (textureIndex == ${K}) { return _X${K}(indices); }`);return j.push("	}"),j.join(`
`)},F8=(Q)=>{let H=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let j=0;j<Q.length;++j)j===0?H.push(`	if (index == ${j}) { return ${Q[j]}; }`):j===Q.length-1?H.push(`	else { return ${Q[j]}; }`):H.push(`	else if (index == ${j}) { return ${Q[j]}; }`);return H.push("	}"),H.join(`
`)},D0=(Q)=>K1({axis:Q.attributes.getInt("axis")}),k8=(Q)=>{if(!Q||Q.length<1)throw new Error("too few inputs");let H=Q[0].type,j=Q[0].dims.length;if(H==="string")throw new Error("string tensor is not supported yet");for(let K of Q){if(K.type!==H)throw new Error("input tensors should be one type");if(K.dims.length!==j)throw new Error("input tensors should have the same shape")}}}),A8,Y1,_0,P0,E0,I0,_6,x0,O0,S8,g0,y0,d0,p0,h0,b0,P6,m0,c0,f0,l0,u0,s0,i0,o0,a0,n0,r0,t0=E(()=>{_1(),Q1(),E3(),W1(),t(),A8=(Q,H,j,K)=>{let W=Q.session.pack?2:0,U=r(Q.session.backend.glContext.version);return{...H,output:{dims:j.dims,type:j.type,textureType:W},shaderSource:`
     ${K.body}
     void main() {
       vec4 v = ${U.texture2D}(A, TexCoords);
       v = ${K.name}_(v);
       ${U.output} = v;
     }
     `,hasMain:!0}},Y1=(Q,H,j,K)=>{let W=Q.session.pack?2:0,U={name:j.name,inputTypes:[W],inputNames:["A"],cacheHint:K};return{...U,get:()=>A8(Q,U,H,j)}},_0=(Q,H)=>[Q.run(Y1(Q,H[0],nH()),H)],P0=(Q,H)=>[Q.run(Y1(Q,H[0],rH()),H)],E0=(Q,H)=>[Q.run(Y1(Q,H[0],tH()),H)],I0=(Q,H)=>[Q.run(Y1(Q,H[0],eH()),H)],_6=(Q,H,j)=>[Q.run(Y1(Q,H[0],S2(j.min,j.max),j.cacheKey),H)],x0=(Q)=>K1({min:Q.attributes.getFloat("min",h4),max:Q.attributes.getFloat("max",b4)}),O0=(Q,H)=>{let j=S8(Q,H);return _6(Q,[H[0]],j)},S8=(Q,H)=>{if(H.length>=3&&(!Q.session.isInitializer(H[1].dataId)||!Q.session.isInitializer(H[2].dataId)))throw new Error("dynamic clip attributes are not allowed");let j=H.length>=3?H[1].numberData[0]:h4,K=H.length>=3?H[2].numberData[0]:b4;return K1({min:j,max:K})},g0=(Q,H)=>[Q.run(Y1(Q,H[0],QZ()),H)],y0=(Q,H)=>[Q.run(Y1(Q,H[0],JZ()),H)],d0=(Q,H,j)=>[Q.run(Y1(Q,H[0],HZ(j.alpha),j.cacheKey),H)],p0=(Q)=>K1({alpha:Q.attributes.getFloat("alpha",1)}),h0=(Q,H)=>[Q.run(Y1(Q,H[0],ZZ()),H)],b0=(Q,H)=>[Q.run(Y1(Q,H[0],jZ()),H)],P6=(Q,H)=>[Q.run(Y1(Q,H[0],VZ()),H)],m0=(Q,H,j)=>[Q.run(Y1(Q,H[0],XZ(j.alpha),j.cacheKey),H)],c0=(Q)=>K1({alpha:Q.attributes.getFloat("alpha",0.01)}),f0=(Q,H)=>[Q.run(Y1(Q,H[0],KZ()),H)],l0=(Q,H)=>[Q.run(Y1(Q,H[0],UZ()),H)],u0=(Q,H)=>[Q.run(Y1(Q,H[0],qZ()),H)],s0=(Q,H)=>[Q.run(Y1(Q,H[0],$2()),H)],i0=(Q,H)=>[Q.run(Y1(Q,H[0],L2()),H)],o0=(Q,H)=>[Q.run(Y1(Q,H[0],WZ()),H)],a0=(Q,H)=>[Q.run(Y1(Q,H[0],GZ()),H)],n0=(Q,H)=>[Q.run(Y1(Q,H[0],RZ()),H)],r0=(Q,H)=>[Q.run(Y1(Q,H[0],zZ()),H)]}),F5,W4=E(()=>{Q1(),t0(),F5=(Q)=>{let H=Q.getString("activation","");if(H==="Clip"){let[j,K]=Q.getFloats("activation_params",[h4,b4]);return{activation:H,clipMax:K,clipMin:j,activationCacheKey:`${H}:${j},${K}`}}return{activation:H,activationCacheKey:H}}}),$8,L8,e0,$j=E(()=>{V3(),W1(),t(),V7(),W4(),$8=(Q,H)=>({name:"GroupedConv",inputNames:Q?["X","W","Bias"]:["X","W"],inputTypes:Q?[0,0,0]:[0,0],cacheHint:H}),L8=(Q,H,j,K)=>{let W=H.length>2?"value += getBias(output_channel);":"",U=H[0].dims.slice(),Z=H[1].dims.slice(),q=Z[0]/K.group;C1.verbose("GroupedConv",`autpPad:${K.autoPad}, dilations:${K.dilations}, group:${K.group}, kernelShape:${K.kernelShape}, pads:${K.pads}, strides:${K.strides}`);let G=y4(U,Z,K.dilations,K.pads,K.strides),J=r(Q.session.backend.glContext.version),{activationFunction:X,applyActivation:V}=f4(K),R=`
  const ivec2 strides = ivec2(${K.strides[0]}, ${K.strides[1]});
  const ivec2 pads = ivec2(${K.pads[0]}, ${K.pads[1]});
  ${X}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${q};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${Z[1]}; wInChannel++) {
      int input_channel = group_id * ${Z[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${Z[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${K.dilations[0]};

        if (xHeight < 0 || xHeight >= ${U[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${Z[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${K.dilations[1]};
          if (xWidth < 0 || xWidth >= ${U[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${W}
    ${V}
    ${J.output} = vec4(value, .0, .0, .0);
  }
`;return{...j,output:{dims:G,type:H[0].type,textureType:0},shaderSource:R,hasMain:!0}},e0=(Q,H,j)=>{let K=$8(H.length>2,j.cacheKey);return{...K,get:()=>L8(Q,H,K,j)}}}),v8,w8,QQ,Lj=E(()=>{W1(),t(),U4(),v8=(Q)=>({name:"Im2Col (packed)",inputNames:["A"],inputTypes:[2],cacheHint:Q}),w8=(Q,H,j,K,W,U)=>{let Z=j.dims,q=K.dims,G=2,J=3,X=W.length,V=[q[1]*q[2]*q[3],W[2]*W[3]],R=q[2]*q[3],z=c4(),Y=r(Q.session.backend.glContext.version),B="";for(let w=0;w<=1;w++)for(let A=0;A<=1;A++)B+=`
            blockIndex = rc.x + ${A};
            pos = rc.y + ${w};

            if(blockIndex < ${V[1]} && pos < ${V[0]}) {
              offsetY = int(blockIndex / (${W[X-1]})) * ${U.strides[0]} -
                ${U.pads[0]};
              d0 = offsetY + ${U.dilations[0]} * (imod(pos, ${R}) / ${q[2]});

              if(d0 < ${Z[G]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${W[X-1]}) * ${U.strides[1]} -
                  ${U.pads[1]};
                d1 = offsetX + ${U.dilations[1]} * imod(imod(pos, ${R}), ${q[2]});

                if(d1 < ${Z[J]} && d1 >= 0) {

                  ch = int(float(pos)/ ${R}.);
                    innerDims = vec2(d0, d1);
                    result[${w*2+A}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;let k=`
      ${z}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${B}
          ${Y.output} = result;
      }
            `;return{...H,output:{dims:V,type:j.type,textureType:2},shaderSource:k,hasMain:!0}},QQ=(Q,H,j,K,W)=>{let U=v8(W.cacheKey);return{...U,get:()=>w8(Q,U,H,j,K,W)}}}),JQ,HQ,ZQ,T8,Z7=E(()=>{Q1(),t(),F3(),W4(),jQ(),JQ=(Q,H,j)=>(T8(H),Q.session.pack?[Q.run(j7(Q,H,j),H)]:[Q.run(v2(H,j),H)]),HQ=(Q)=>F5(Q.attributes),ZQ=(Q,H)=>({name:"MatMul",inputNames:Q?["A","B","Bias"]:["A","B"],inputTypes:Q?[0,0,0]:[0,0],cacheHint:H}),T8=(Q)=>{if(!Q||Q.length!==2)throw new Error("MatMul requires 2 inputs.");if(Q[0].dims[Q[0].dims.length-1]!==Q[1].dims[Q[1].dims.length-2])throw new Error("shared dimension does not match.");if(Q[0].type!=="float32"&&Q[0].type!=="float64"||Q[1].type!=="float32"&&Q[1].type!=="float64")throw new Error("inputs should be float type");if(Q[0].type!==Q[1].type)throw new Error("inputs types should match")}}),D8,_8,j7,jQ=E(()=>{Q1(),W1(),t(),F3(),W4(),Z7(),D8=(Q,H)=>({name:"MatMul (packed)",inputNames:Q?["A","B","Bias"]:["A","B"],inputTypes:Q?[2,2,2]:[2,2],cacheHint:H}),_8=(Q,H,j,K)=>{let W=j.length>2,U=W?"value += getBiasForMatmul();":"",Z=j[0].dims,q=j[1].dims,G=R3.calcShape(Z,q,!0),J=!u.areEqual(j[0].dims,j[1].dims);if(!G)throw new Error("Can't use matmul on the given tensors");let X=Z[Z.length-1],V=Math.ceil(X/2),R=Z.length,z=q.length,Y=r(Q.session.backend.glContext.version),B=P3(G.length),k=G.length,w=H4(),{activationFunction:A,applyActivation:D}=f4(K),I=W?`${w2(B,w,j[2].dims,G,!0)}`:"",h=J?`${MZ(B,w,j,G)}`:"",$1=J?"getAAtOutCoordsMatmul(i)":`getA(${YZ(w,R)})`,L1=J?"getBAtOutCoordsMatmul(i)":`getB(${CZ(w,z)})`,x1=J?"":`${B} rc =
          getOutputCoords(); int lastDim = rc.${w[k-1]}; rc.${w[k-1]} =
          rc.${w[k-2]}; rc.${w[k-2]} = lastDim;
      `,G1=`
            ${h}
            ${I}
            ${A}
            void main() {
              ${x1}

              vec4 value = vec4(0);
              for (int i = 0; i < ${V}; i++) {
                vec4 a = ${$1};
                vec4 b = ${L1};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${U}
              ${D}
              ${Y.output} = value;
            }`;return{...H,output:{dims:G,type:j[0].type,textureType:2},shaderSource:G1,hasMain:!0}},j7=(Q,H,j)=>{let K=D8(H.length>2,j.activationCacheKey);return{...K,get:()=>_8(Q,K,H,j)}}}),VQ,vj=E(()=>{V7(),Lj(),jQ(),VQ=(Q,H,j)=>{let K=H[0].dims,W=H[1].dims,U=y4(K,W,j.dilations,j.pads,j.strides),Z=Q.run(QQ(Q,H[0],H[1],U,j),[H[0]]),q=Q.reshapePacked(H[1],[W[0],W[1]*W[2]*W[3]]),G=H.length===3?[q,Z,H[2]]:[q,Z],J=Q.run(j7(Q,G,j),G);return Q.reshapePacked(J,U)}}),P8,E8,XQ,E6,KQ=E(()=>{t(),P8=(Q)=>({name:"Im2Col",inputNames:["X"],inputTypes:[0],cacheHint:Q}),E8=(Q,H,j,K,W,U)=>{let Z=j.dims,q=K.dims,G=W.length,J=E6(Z,q,W,4),X=`
        const int XC = ${Z[1]};
        const int XH = ${Z[2]};
        const int XW = ${Z[3]};
        const int KH = ${U.kernelShape[0]};
        const int KW = ${U.kernelShape[1]};
        const int dilationH = ${U.dilations[0]};
        const int dilationW = ${U.dilations[1]};
        const int strideH = ${U.strides[0]};
        const int strideW = ${U.strides[1]};
        const int padH = ${U.pads[0]};
        const int padW = ${U.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${G}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${Z.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return{...H,output:{dims:J,type:j.type,textureType:4},shaderSource:X}},XQ=(Q,H,j,K,W)=>{let U=P8(W.cacheKey);return{...U,get:()=>E8(Q,U,H,j,K,W)}},E6=(Q,H,j,K=4)=>[j[0],j[2],j[3],Math.ceil(Q[1]*H[2]*H[3]/K)]}),I8,x8,UQ,wj=E(()=>{Q1(),W1(),t(),W4(),KQ(),I8=(Q,H)=>({name:"ConvDotProduct",inputNames:Q?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:Q?[0,4,0]:[0,4],cacheKey:H.activationCacheKey}),x8=(Q,H,j,K,W)=>{let U=j[0].dims,Z=j[1].dims,q=[Z[0],Math.ceil(U[1]*Z[2]*Z[3]/4)],G=E6(U,Z,K),[J,X]=Q.calculateTextureWidthAndHeight(q,4),V=u.computeStrides(G),[R,z]=Q.calculateTextureWidthAndHeight(G,4),Y=K.length,B=j.length<3?"0.0":"_B(b)",k=Math.ceil(U[1]*Z[2]*Z[3]/4),{activationFunction:w,applyActivation:A}=f4(W),D=r(Q.session.backend.glContext.version),I=`
${w}
float process(int indices[${Y}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${V[0]} + im2col[1] * ${V[1]} + im2col[2] * ${V[2]};
  int kernelOffset = indices[1] * ${q[1]};
  float value = ${B};
  for (int i = 0; i < ${k}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${R}, ${z});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${J}, ${X});
    value += dot(${D.texture2D}(Im2Col, im2colCoords), ${D.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${A}
  return value;
}`;return{...H,output:{dims:K,type:j[0].type,textureType:0},shaderSource:I}},UQ=(Q,H,j,K)=>{let W=I8(H.length>2,K);return{...W,get:()=>x8(Q,W,H,j,K)}}}),y4,I6,O8,g8,y8,d8,x6,p8,V7=E(()=>{_1(),Q1(),$j(),vj(),wj(),W4(),KQ(),Z7(),y4=(Q,H,j,K,W)=>{let U=Q[0],Z=Q.slice(2),q=Z.length,G=H[0],J=H.slice(2).map((V,R)=>V+(V-1)*(j[R]-1)),X=Z.map((V,R)=>V+K[R]+K[R+q]).map((V,R)=>Math.floor((V-J[R]+W[R])/W[R]));return[U,G].concat(...X)},I6=(Q,H,j)=>(p8(H,j),O8(Q,H,j)),O8=(Q,H,j)=>{let K=d8(j,H),W=Q.session.pack,U=K.kernelShape[0]===1&&K.kernelShape[1]===1;return K.group>1?[Q.run(e0(Q,H,K),H)]:U&&W?[g8(Q,H,K)]:W&&H[0].dims.length===4&&H[0].dims[0]===1&&!U?[VQ(Q,H,K)]:[y8(Q,H,K)]},g8=(Q,H,j)=>{let K=H[0].dims,W=H[1].dims,U=y4(K,W,j.dilations,j.pads,j.strides),Z=Q.reshapeUnpacked(H[0],[K[1],K[2]*K[3]]),q=Q.reshapeUnpacked(H[1],[W[0],W[1]]),G=H.length>2?[q,Z,H[2]]:[q,Z],J=Q.run(v2(G,j),G);return Q.reshapeUnpacked(J,U)},y8=(Q,H,j)=>{let K=H[0].dims,W=H[1].dims,U=y4(K,W,j.dilations,j.pads,j.strides),Z=Q.run(XQ(Q,H[0],H[1],U,j),[H[0]]),q=H.length===3?[Z,H[1],H[2]]:[Z,H[1]];return Q.run(UQ(Q,H,U,j),q)},d8=(Q,H)=>{let j=Q.kernelShape.slice();if(Q.kernelShape.length===0)for(let U=2;U<H[1].dims.length;++U)j.push(H[1].dims[U]);let K=Q.pads.slice();R5.adjustPadsBasedOnAutoPad(H[0].dims,Q.strides,Q.dilations,j,K,Q.autoPad);let W=Object.assign({},Q);return Object.assign(W,{kernelShape:j,pads:K,cacheKey:Q.cacheKey}),W},x6=(Q)=>{let H=Q.attributes,j=F5(H),K=H.getString("auto_pad","NOTSET"),W=H.getInts("dilations",[1,1]),U=H.getInt("group",1),Z=H.getInts("kernel_shape",[]),q=H.getInts("pads",[0,0,0,0]),G=H.getInts("strides",[1,1]);return K1({autoPad:K,dilations:W,group:U,kernelShape:Z,pads:q,strides:G,...j})},p8=(Q,H)=>{if(!Q||Q.length!==2&&Q.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(Q[0].dims.length!==4||Q[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let j=Q[0].dims[1],K=Q[1].dims[1]*H.group;if(j!==K)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(Q.length===3&&(Q[2].dims.length!==1||Q[1].dims[0]!==Q[2].dims[0]))throw new Error("invalid bias");let W=Q[0].dims.length-2;if(H.dilations.length!==W)throw new Error(`dilations should be ${W}D`);if(H.strides.length!==W)throw new Error(`strides should be ${W}D`);if(H.pads.length!==W*2)throw new Error(`pads should be ${W*2}D`);if(H.kernelShape.length!==0&&H.kernelShape.length!==Q[1].dims.length-2)throw new Error("invalid kernel shape");if(Q[0].type!=="float32"||Q[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(Q.length===3&&Q[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}}),h8,b8,m8,qQ,c8,f8,l8,u8,s8,i8,WQ,o8,Tj=E(()=>{_1(),W1(),t(),W4(),h8=(Q,H,j,K,W,U)=>(Q-1)*H+j+(K-1)*W+1-U,b8=(Q,H,j,K,W)=>{let U=Math.floor(Q/2);H==="SAME_UPPER"?(j[K]=U,j[W]=Q-U):H==="SAME_LOWER"&&(j[K]=Q-U,j[W]=U)},m8=(Q,H,j,K,W,U,Z,q)=>{let G=Q.length-2,J=q.length===0;for(let X=0;X<G;++X){let V=J?Q[X+2]*U[X]:q[X],R=h8(Q[X+2],U[X],W[X],H[X],j[X],V);b8(R,K,W,X,X+G),J&&q.push(U[X]*(Q[X+2]-1)+Z[X]+(H[X]-1)*j[X]+1-W[X]-W[X+G])}},qQ=(Q,H,j)=>(o8(H,j),c8(Q,H,j)),c8=(Q,H,j)=>{let K=i8(j,H);return[s8(Q,H,K)]},f8=(Q,H)=>({name:"ConvTranspose",inputNames:Q?["X","W","B"]:["X","W"],inputTypes:Q?[0,0,0]:[0,0],cacheHint:H}),l8=(Q,H,j,K)=>{let W=H.length>2?"getB(output_channel)":"0.0",U=H[0].dims,Z=H[1].dims,q=Z[1],G=Z[0]/K.group,J=[H[0].dims[0],H[1].dims[1]*K.group,...K.outputShape],X=r(Q.session.backend.glContext.version),{activationFunction:V,applyActivation:R}=f4(K),z=`
  const ivec2 strides = ivec2(${K.strides[0]}, ${K.strides[1]});
  const ivec2 pads = ivec2(${K.pads[0]}, ${K.pads[1]});
  ${V}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${q};
    int wOutChannel = output_channel - group_id * ${q};

    float value = ${W};
    for (int inChannelOffset = 0; inChannelOffset < ${G}; inChannelOffset++) {
      int input_channel = group_id * ${G} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${Z[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${Z[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${K.dilations[0]}, wHOff * ${K.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${U[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${U[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${R}
    ${X.output} = vec4(value, .0, .0, .0);
  }
`;return{...j,output:{dims:J,type:H[0].type,textureType:0},shaderSource:z,hasMain:!0}},u8=(Q,H,j)=>{let K=f8(H.length>2,j.cacheKey);return{...K,get:()=>l8(Q,H,K,j)}},s8=(Q,H,j)=>Q.run(u8(Q,H,j),H),i8=(Q,H)=>{let j=Q.kernelShape.slice();if(Q.kernelShape.length===0)for(let q=2;q<H[1].dims.length;++q)j.push(H[1].dims[q]);let K=Q.pads.slice(),W=Q.outputShape.slice(),U=H[0].dims;m8(U,j,Q.dilations,Q.autoPad,K,Q.strides,Q.outputPadding,W);let Z=Object.assign({},Q);return Object.assign(Z,{kernelShape:j,pads:K,outputShape:W,cacheKey:Q.cacheKey}),Z},WQ=(Q)=>{let H=Q.attributes,j=F5(H),K=H.getString("auto_pad","NOTSET"),W=H.getInts("dilations",[1,1]),U=H.getInt("group",1),Z=H.getInts("kernel_shape",[]),q=H.getInts("output_padding",[0,0]),G=H.getInts("output_shape",[]),J=H.getInts("pads",[0,0,0,0]),X=H.getInts("strides",[1,1]);return K1({autoPad:K,dilations:W,group:U,kernelShape:Z,outputPadding:q,outputShape:G,pads:J,strides:X,...j})},o8=(Q,H)=>{if(!Q||Q.length!==2&&Q.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(Q[0].dims.length!==4||Q[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let j=Q[0].dims[1],K=Q[1].dims[0];if(j!==K)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let W=Q[1].dims[1]*H.group;if(Q.length===3&&(Q[2].dims.length!==1||Q[2].dims[0]!==W))throw new Error("invalid bias");let U=Q[0].dims.length-2;if(H.dilations.length!==U)throw new Error(`dilations should be ${U}D`);if(H.strides.length!==U)throw new Error(`strides should be ${U}D`);if(H.pads.length!==U*2)throw new Error(`pads should be ${U*2}D`);if(H.outputPadding.length!==U)throw new Error(`output_padding should be ${U}D`);if(H.kernelShape.length!==0&&H.kernelShape.length!==Q[1].dims.length-2)throw new Error("invalid kernel shape");if(H.outputShape.length!==0&&H.outputShape.length!==Q[0].dims.length-2)throw new Error("invalid output shape");if(Q[0].type!=="float32"||Q[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(Q.length===3&&Q[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}}),l5,m4,GQ,a8,u5,n8,r8,t8,X7=E(()=>{_1(),Q1(),t(),l5={name:"Transpose",inputNames:["A"],inputTypes:[0]},m4=(Q,H,j)=>(t8(H),[Q.run({...l5,cacheHint:j.cacheKey,get:()=>a8(Q,H[0],j.perm)},H)]),GQ=(Q)=>K1({perm:Q.attributes.getInts("perm",[])}),a8=(Q,H,j)=>{let K=H.dims;j=u5(K,j);let W=n8(K,j),U=K.length,Z=`
      ${r8("perm",j,U)}
      float process(int indices[${U}]) {
        int a[${U}];
        perm(a, indices);
        return _A(a);
      }`;return{...l5,output:{dims:W,type:H.type,textureType:0},shaderSource:Z}},u5=(Q,H)=>(H&&H.length!==Q.length&&(H=[...Q.keys()].reverse()),H),n8=(Q,H)=>(H=u5(Q,H),u.sortBasedOnPerm(Q,H)),r8=(Q,H,j)=>{let K=[];K.push(`void ${Q}(out int a[${j}], int src[${j}]) {`);for(let W=0;W<j;++W)K.push(`	a[${H[W]}]=src[${W}];`);return K.push("	}"),K.join(`
`)},t8=(Q)=>{if(!Q||Q.length!==1)throw new Error("Transpose requires 1 input.");if(Q[0].type!=="float32"&&Q[0].type!=="float64")throw new Error("input should be float tensor")}}),RQ,zQ,e8,Dj=E(()=>{X7(),RQ=(Q,H,j)=>{e8(H);let K=j.blocksize,W=K*K,U=j.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],Z=j.mode==="DCR"?[H[0].dims[0],K,K,H[0].dims[1]/W,H[0].dims[2],H[0].dims[3]]:[H[0].dims[0],H[0].dims[1]/W,K,K,H[0].dims[2],H[0].dims[3]],q=Q.reshapeUnpacked(H[0],Z),G={perm:U,cacheKey:`${U}`},[J]=m4(Q,[q],G),X=[H[0].dims[0],H[0].dims[1]/W,H[0].dims[2]*K,H[0].dims[3]*K];return[Q.reshapeUnpacked(J,X)]},zQ=(Q)=>{let H=Q.attributes.getInt("blocksize");if(H<1)throw new Error(`blocksize must be >= 1, but got : ${H} for DepthToSpace`);let j=Q.attributes.getString("mode","DCR");if(j!=="DCR"&&j!=="CRD")throw new Error(`unrecognized mode: ${j} for DepthToSpace`);return{mode:j,blocksize:H}},e8=(Q)=>{if(Q.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${Q.length}`);if(Q[0].type==="string"||Q[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}}),NQ,MQ,Q9,_j=E(()=>{Q1(),NQ=(Q,H,j)=>{Q9(H,j);let K=u.flattenShape(H[0].dims,j);return[Q.reshapeUnpacked(H[0],K)]},MQ=(Q)=>Q.attributes.getInt("axis",1),Q9=(Q,H)=>{if(!Q||Q.length!==1)throw new Error("Flatten requires 1 input.");let j=Q[0].dims.length;if(j===0)throw new Error("scalar tensor is not supported.");if(H<-j||H>j)throw new Error("Invalid axis");if(Q[0].type==="string")throw new Error("string tensor is not supported.")}}),u4,k5=E(()=>{u4=["float32","float64","int32","int16","int8","uint16","uint32","uint8"]}),YQ,CQ,J9,H9,Z9,j9,Pj=E(()=>{_1(),k5(),Q1(),t(),YQ=(Q,H,j)=>(j9(H,j.axis),[Q.run(Z9(Q,H,j),H)]),CQ=(Q)=>K1({axis:Q.attributes.getInt("axis",0)}),J9={name:"Gather",inputNames:["A","B"],inputTypes:[0,0]},H9=(Q,H,j,K)=>{let W=j[0].dims.slice(),U=j[1].dims.slice(),Z=new Array(W.length+U.length-1);K=u.normalizeAxis(K,W.length);let q=[];for(let R=0;R<Z.length;R++)R<K?(Z[R]=W[R],q.push(`inputIdx[${R}] = outputIdx[${R}];`)):R<K+U.length?(Z[R]=U[R-K],q.push(`indexDataIdx[${R-K}] = outputIdx[${R}];`)):(Z[R]=W[R-U.length+1],q.push(`inputIdx[${R-U.length+1}] = outputIdx[${R}];`));let G=Z.length||1,J=W.length,X=U.length||1,V=`
      float process(int outputIdx[${G}]) {
        int inputIdx[${J}];
        int indexDataIdx[${X}];
        indexDataIdx[0] = 0;
        ${q.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${K}] = idx < 0 ? idx + ${W[K]} : idx;
        return _A(inputIdx);
      }`;return{...H,output:{dims:Z,type:j[0].type,textureType:0},shaderSource:V}},Z9=(Q,H,j)=>{let K={...J9,cacheHint:j.cacheKey};return{...K,get:()=>H9(Q,K,H,j.axis)}},j9=(Q,H)=>{if(!Q||Q.length!==2)throw new Error("Gather requires 2 inputs.");let j=Q[0].dims.length;if(j<1)throw new Error("Invalid input shape.");if(H<-j||H>j-1)throw new Error("Invalid axis.");if(u4.indexOf(Q[0].type)===-1)throw new Error("Invaid input type.");if(Q[1].type!=="int32"&&Q[1].type!=="int16")throw new Error("Invaid input type.")}}),O6,s5,BQ,FQ,V9,X9,K9,Ej=E(()=>{_1(),Q1(),t(),O6=(Q,H,j)=>(K9(H,j),[Q.run(V9(H,j),H)]),s5=(Q,H)=>{let j=Q.attributes.getInt("transA",0)!==0,K=Q.attributes.getInt("transB",0)!==0,W=Q.attributes.getFloat("alpha",1),U=Q.attributes.getFloat("beta",1);return K1({transA:j,transB:K,alpha:W,beta:U,isOptionalC:H})},BQ=(Q)=>s5(Q,!1),FQ=(Q)=>s5(Q,!0),V9=(Q,H)=>{let j={name:"Gemm",inputNames:Q.length===3?["A","B","C"]:["A","B"],inputTypes:Q.length===3?[0,0,0]:[0,0],key:H.cacheKey};return{...j,get:()=>X9(j,Q,H)}},X9=(Q,H,j)=>{let K=H[0].dims.slice(),W=H[1].dims.slice(),[U,Z]=t2.getShapeOfGemmResult(K,j.transA,W,j.transB,H.length===3?H[2].dims:void 0),q=[U,Z];if(!q)throw new Error("Can't use gemm on the given tensors");let G=K[K.length-1],J="";j.transA&&(G=K[0]),j.transA&&j.transB?J="value += _A_T(a) * _B_T(b);":j.transA&&!j.transB?J="value += _A_T(a) * _B(b);":!j.transA&&j.transB?J="value += _A(a) * _B_T(b);":!j.transA&&!j.transB&&(J="value += _A(a) * _B(b);");let X=q.length,V=H.length===3?`int c[${H[2].dims.length}];`:"",R=H.length===3?"bcastIndices_C(indices, c);":"",z=H.length===3?"value += beta * _C(c);":"",Y=`
      float process(int indices[${X}]) {
          int a[${X}];
          int b[${X}];
          ${V}

          copyVec(indices, a);
          copyVec(indices, b);
          ${R}

          float value = 0.0;
          for (int k=0; k<${G}; ++k) {
              a[${X-1}] = k;
              b[${X-2}] = k;
              ${J}
          }

          value = value * alpha;
          ${z}
          return value;
      }`;return{...Q,output:{dims:q,type:H[0].type,textureType:0},variables:[{name:"alpha",type:"float",data:j.alpha},{name:"beta",type:"float",data:j.beta}],shaderSource:Y}},K9=(Q,H)=>{if(!Q)throw new Error("Input is missing");if(H.isOptionalC&&(Q.length<2||Q.length>3))throw new Error("Invaid input shape.");if(!H.isOptionalC&&Q.length!==3)throw new Error("Gemm requires 3 inputs");if(Q.length===3&&Q[2].dims.length!==1&&Q[2].dims.length!==2)throw new Error("Invalid input shape of C");if(Q[0].type!=="float32"&&Q[0].type!=="float64"||Q[1].type!=="float32"&&Q[1].type!=="float64"||Q.length===3&&Q[2].type!=="float32"&&Q[2].type!=="float64")throw new Error("Invalid input type.");if(Q[0].type!==Q[1].type||Q.length===3&&Q[0].type!==Q[2].type)throw new Error("Input types are mismatched")}}),kQ,AQ,U9,q9,W9,G9,R9,Ij=E(()=>{_1(),t(),kQ=(Q,H,j)=>(R9(H),[Q.run(W9(Q,H,j),H)]),AQ=(Q)=>{let H=Q.attributes.getFloat("scale"),j=Q.attributes.getFloats("bias");return K1({scale:H,bias:j})},U9={name:"ImageScaler",inputNames:["X"],inputTypes:[0]},q9=(Q,H,j,K)=>{let W=j[0].dims.slice(),U=W.length,Z=`
      ${G9(K.bias.length)}
      float process(int indices[${U}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return{...H,output:{dims:W,type:j[0].type,textureType:0},variables:[{name:"bias",type:"float",arrayLength:K.bias.length,data:K.bias},{name:"scale",type:"float",data:K.scale}],shaderSource:Z}},W9=(Q,H,j)=>{let K={...U9,cacheHint:j.cacheKey};return{...K,get:()=>q9(Q,K,H,j)}},G9=(Q)=>{let H=[`float getBias(float bias[${Q}], int channel) {`];for(let j=0;j<Q;++j)j===0?H.push(`	if (channel == ${j}) { return bias[${j}]; }`):j===Q-1?H.push(`	else { return bias[${j}]; }`):H.push(`	else if (channel == ${j}) { return bias[${j}]; }`);return H.push("	}"),H.join(`
`)},R9=(Q)=>{if(!Q||Q.length!==1)throw new Error("ImageScaler requires 1 input.");if(Q[0].dims.length!==4)throw new Error("Invalid input shape.");if(Q[0].type!=="float32"&&Q[0].type!=="float64")throw new Error("Invalid input type.")}}),SQ,$Q,i5,z9,N9,M9,Y9,C9,B9,xj=E(()=>{W1(),t(),SQ=(Q,H,j)=>{B9(H);let K=Q.run(N9(H[0]),H);return[Q.run(C9(Q,H[0],j,K.dims),[H[0],K,H[1],H[2]])]},$Q=(Q)=>Q.attributes.getFloat("epsilon",0.00001),i5={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[0]},z9=(Q,H)=>{let j=H.dims.slice(),K=j[1],W=j[2]*j[3],U=[j[0],K],Z=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${j[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${j[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${W});
        temp = 0.0;
        for(int a2=0; a2<${j[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${j[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${W});

        return v;
      }`;return{...Q,output:{dims:U,type:H.type,textureType:4},shaderSource:Z}},N9=(Q)=>({...i5,get:()=>z9(i5,Q)}),M9={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[0,4,0,0]},Y9=(Q,H,j,K,W)=>{let U=r(Q.session.backend.glContext.version),[Z,q]=Q.calculateTextureWidthAndHeight(W,4),[G,J]=[Z/4,q],X=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${G}, ${J});
        return ${U.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return{...H,output:{dims:j.dims,type:j.type,textureType:0},variables:[{name:"epsilon",type:"float",data:K}],shaderSource:X}},C9=(Q,H,j,K)=>{let W={...M9,cacheHint:`${j}`};return{...W,get:()=>Y9(Q,W,H,j,K)}},B9=(Q)=>{if(!Q||Q.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");let H=Q[0],j=Q[1],K=Q[2];if(H.dims.length<3||j.dims.length!==1||K.dims.length!==1)throw new Error("Invalid input shape.");if(j.dims[0]!==H.dims[1]||K.dims[0]!==H.dims[1])throw new Error("Input shapes are mismatched.");if(H.type!=="float32"&&H.type!=="float64"||j.type!=="float32"&&j.type!=="float64"||K.type!=="float32"&&K.type!=="float64")throw new Error("Invalid input type.");if(Q[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}}),LQ,vQ,K7,F9,Oj=E(()=>{_1(),t(),LQ=(Q,H,j)=>(F9(H),[Q.run(FZ(H,j),H)]),vQ=(Q)=>{let H=Q.attributes.getFloat("alpha",0.0001),j=Q.attributes.getFloat("beta",0.75),K=Q.attributes.getFloat("bias",1),W=Q.attributes.getInt("size");return K1({alpha:H,beta:j,bias:K,size:W})},K7={name:"LRN",inputNames:["X"],inputTypes:[0]},F9=(Q)=>{if(!Q||Q.length!==1)throw new Error("LRN requires 1 input.");if(Q[0].dims.length!==4)throw new Error('currently only support LRN for input with "NCHW" format');if(Q[0].type!=="float32")throw new Error("input should be float type")}}),k9,g6,wQ,TQ,DQ,A9,S9,$9,L9,v9,w9,T9,D9,gj=E(()=>{_1(),Q1(),W1(),t(),k9={name:"Pad",inputNames:["A"],inputTypes:[0]},g6=(Q,H,j)=>($9(H),[Q.run({...k9,cacheHint:j.cacheKey,get:()=>S9(Q,H[0],j)},H)]),wQ=(Q)=>{let H=Q.attributes.getString("mode","constant"),j=Q.attributes.getFloat("value",0),K=Q.attributes.getInts("pads");return K1({mode:H,value:j,pads:K})},TQ=(Q,H,j)=>{L9(H);let K=A9(Q,H,j);return g6(Q,[H[0]],K)},DQ=(Q)=>Q.attributes.getString("mode","constant"),A9=(Q,H,j)=>{if(!Q.session.isInitializer(H[1].dataId)||H.length>=3&&!Q.session.isInitializer(H[2].dataId))throw new Error("dynamic pad attributes are not allowed");let K=Array.from(H[1].integerData),W=H.length>=3?H[2].floatData[0]:0;return K1({mode:j,pads:K,value:W})},S9=(Q,H,j)=>{let K=u.padShape(H.dims.slice(),j.pads),W=K.length,U=`
      ${v9(Q,H,j)}
      float process(int[${W}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[0],output:{dims:K,type:H.type,textureType:0},shaderSource:U}},$9=(Q)=>{if(!Q||Q.length!==1)throw new Error("Pad requires 1 input");if(Q[0].type!=="float32"&&Q[0].type!=="float64")throw new Error("Invalid input type.")},L9=(Q)=>{if(!Q||Q.length!==2&&Q.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(Q[1].type!=="int32")throw new Error("Invalid input type.");if(Q.length>=3&&Q[2].type==="string")throw new Error("Invalid input type.")},v9=(Q,H,j)=>{let K=r(Q.session.backend.glContext.version),[W,U]=Q.calculateTextureWidthAndHeight(H.dims,0),Z=u.computeStrides(H.dims);switch(j.mode){case"constant":return w9(K,H.dims,Z,W,U,j.pads,j.value);case"reflect":return T9(K,H.dims,Z,W,U,j.pads);case"edge":return D9(K,H.dims,Z,W,U,j.pads);default:throw new Error("Invalid mode")}},w9=(Q,H,j,K,W,U,Z)=>{let q=H.length,G="";for(let J=q-1;J>=0;--J)G+=`
        k = m[${J}] - ${U[J]};
        if (k < 0)  return constant;
        if (k >= ${H[J]}) return constant;
        offset += k * ${j[J]};
        `;return`
      float padA(int m[${q}]) {
        const float constant = float(${Z});
        int offset = 0;
        int k = 0;
        ${G}
        vec2 coords = offsetToCoords(offset, ${K}, ${W});
        float value = getColorAsFloat(${Q.texture2D}(A, coords));
        return value;
      }
      `},T9=(Q,H,j,K,W,U)=>{let Z=H.length,q="";for(let G=Z-1;G>=0;--G)q+=`
        k = m[${G}] - ${U[G]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(H[G]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${H[G]}) { k = _2n_1 - k; }
        }
        offset += k * ${j[G]};
        `;return`
      float padA(int m[${Z}]) {
        int offset = 0;
        int k = 0;
        ${q}
        vec2 coords = offsetToCoords(offset, ${K}, ${W});
        float value = getColorAsFloat(${Q.texture2D}(A, coords));
        return value;
      }
      `},D9=(Q,H,j,K,W,U)=>{let Z=H.length,q="";for(let G=Z-1;G>=0;--G)q+=`
        k = m[${G}] - ${U[G]};
        if (k < 0)  k = 0;
        if (k >= ${H[G]}) k = ${H[G]-1};
        offset += k * ${j[G]};
      `;return`
      float padA(int m[${Z}]) {
        int offset = 0;
        int k = 0;
        ${q}
        vec2 coords = offsetToCoords(offset, ${K}, ${W});
        float value = getColorAsFloat(${Q.texture2D}(A, coords));
        return value;
      }
      `}}),_Q,PQ,o5,EQ,IQ,xQ,OQ,a5,n5,_9,r5,gQ,L4,t5,v4,P9,yj=E(()=>{_1(),Q1(),t(),_Q=(Q,H,j)=>{L4(H);let K={name:"AveragePool",inputNames:["X"],inputTypes:[0],cacheHint:j.cacheKey};return[Q.run({...K,get:()=>o5(H,K,!1,j)},H)]},PQ=(Q)=>{let H=Q.attributes.getString("auto_pad","NOTSET"),j=Q.attributes.getInt("ceil_mode",0),K=Q.attributes.getInt("count_include_pad",0)!==0,W=Q.attributes.getInts("kernel_shape"),U=Q.attributes.getInts("strides",[]),Z=Q.attributes.getInts("pads",[]);if(j!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return K1({autoPad:H,ceilMode:j,countIncludePad:K,kernelShape:W,strides:U,pads:Z})},o5=(Q,H,j,K)=>{let[W,U]=n5(Q,K,j),Z=u.size(W.kernelShape),q="value += _X(x);",G="";W.countIncludePad?G+=`value /= float(${Z});`:G+=`value /= float(${Z} - pad);`;let J=`
        ${t5(Q[0].dims,W,q,G,"0.0")}
      `;return{...H,output:{dims:U,type:Q[0].type,textureType:0},shaderSource:J}},EQ=(Q,H,j)=>{L4(H);let K={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[0],cacheHint:`${j.countIncludePad}`};return[Q.run({...K,get:()=>o5(H,K,!0,j)},H)]},IQ=(Q)=>{let H=Q.attributes.getInt("count_include_pad",0)!==0;return K1({autoPad:"",ceilMode:0,countIncludePad:H,kernelShape:[],strides:[],pads:[]})},xQ=(Q,H,j)=>{L4(H);let K={name:"MaxPool",inputNames:["X"],inputTypes:[0],cacheHint:j.cacheKey};return[Q.run({...K,get:()=>a5(H,K,!1,j)},H)]},OQ=(Q)=>{let H=Q.attributes.getString("auto_pad","NOTSET"),j=Q.attributes.getInt("ceil_mode",0),K=Q.attributes.getInts("kernel_shape"),W=Q.attributes.getInts("strides",[]),U=Q.attributes.getInts("pads",[]),Z=Q.attributes.getInt("storage_order",0),q=Q.attributes.getInts("dilations",[]);if(Z!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(j!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return K1({autoPad:H,ceilMode:j,countIncludePad:!1,kernelShape:K,strides:W,pads:U,storageOrder:Z,dilations:q})},a5=(Q,H,j,K)=>{let[W,U]=n5(Q,K,j),Z=`
      value = max(_X(x), value);
    `,q="",G=`
      ${t5(Q[0].dims,W,Z,q,"-1e5")}
    `;return{...H,output:{dims:U,type:Q[0].type,textureType:0},shaderSource:G}},n5=(Q,H,j)=>{let K=Q[0].dims.slice(),W=Object.hasOwnProperty.call(H,"dilations"),U=H.kernelShape.slice(),Z=H.strides.slice(),q=W?H.dilations.slice():[],G=H.pads.slice();R5.adjustPoolAttributes(j,K,U,Z,q,G);let J=R5.computePoolOutputShape(j,K,Z,q,U,G,H.autoPad),X=Object.assign({},H);return W?Object.assign(X,{kernelShape:U,strides:Z,pads:G,dilations:q,cacheKey:H.cacheKey}):Object.assign(X,{kernelShape:U,strides:Z,pads:G,cacheKey:H.cacheKey}),[X,J]},_9={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},r5={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[0]},gQ=(Q,H)=>(L4(H),[Q.run({...r5,get:()=>a5(H,r5,!0,_9)},H)]),L4=(Q)=>{if(!Q||Q.length!==1)throw new Error("Pool ops requires 1 input.");if(Q[0].type!=="float32"&&Q[0].type!=="float64")throw new Error("Invalid input type.")},t5=(Q,H,j,K,W)=>{let U=Q.length;if(H.kernelShape.length<=2){let Z=H.kernelShape[H.kernelShape.length-1],q=H.strides[H.strides.length-1],G=H.pads[H.pads.length/2-1],J=H.pads[H.pads.length-1],X=Q[U-1],V="",R="",z="";if(G+J!==0?V=`
          for (int i = 0; i < ${Z}; i++) {
            x[${U} - 1] = indices[${U} - 1] * ${q} - ${G} + i;
            if (x[${U} - 1] < 0 || x[${U} - 1] >= ${X}) {
              pad++;
              continue;
            }
            ${j}
          }`:V=`
          for (int i = 0; i < ${Z}; i++) {
            x[${U} - 1] = indices[${U} - 1] * ${q} - ${G} + i;
            ${j}
          }`,H.kernelShape.length===2){let Y=H.kernelShape[H.kernelShape.length-2],B=H.strides[H.strides.length-2],k=H.pads[H.pads.length/2-2],w=H.pads[H.pads.length-2],A=Q[U-2];k+w!==0?R=`
            for (int j = 0; j < ${Y}; j++) {
              x[${U} - 2] = indices[${U} - 2] * ${B} - ${k} + j;
              if (x[${U} - 2] < 0 || x[${U} - 2] >= ${A}) {
                pad+= ${Z};
                continue;
              }
          `:R=`
            for (int j = 0; j < ${Y}; j++) {
              x[${U} - 2] = indices[${U} - 2] * ${B} - ${k} + j;
            `,z=`
          }
        `}return`
        float process(int indices[${U}]) {
          int x[${U}];
          copyVec(indices, x);

          float value = ${W};
          int pad = 0;
          ${R}
          ${V}
          ${z}
          ${K}
          return value;
        }
      `}else{let Z=u.size(H.kernelShape),q=u.computeStrides(H.kernelShape),G=q.length,J=H.pads.length,X=P9(G),V=v4(Q,"inputDims"),R=v4(H.pads,"pads"),z=v4(q,"kernelStrides"),Y=v4(H.strides,"strides"),B=H.pads.reduce((w,A)=>w+A),k="";return B?k=`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${j}
          }`:k=`
          }
          ${j}
        `,`
        ${X}
        float process(int indices[${U}]) {
          int x[${U}];
          copyVec(indices, x);
          int offset[${G}];
          int pads[${J}];
          int inputDims[${U}];
          int kernelStrides[${G}];
          int strides[${G}];
          ${R}
          ${V}
          ${Y}
          ${z}

          float value = ${W};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${Z}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${U} - ${G}; j < ${U}; j++) {
              x[j] = indices[j] * strides[j - ${U} + ${G}]
                + offset[j - ${U} + ${G}] - pads[j - 2];
              ${k}
          }
          ${K}

          return value;
        }
      `}},v4=(Q,H)=>{let j="";for(let K=0;K<Q.length;K++)j+=`
      ${H}[${K}] = ${Q[K]};
    `;return j},P9=(Q)=>`
  void offsetToIndices(int offset, int[${Q}] strides, out int[${Q}] indices) {
    if (${Q} == 0) {
      return;
    }
    for (int i = 0; i < ${Q} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${Q} - 1] = offset;
  }`}),w3,D3,E9,I9,yQ,dQ,pQ,hQ,bQ,mQ,cQ,dj=E(()=>{_1(),k5(),Q1(),t(),w3=(Q,H,j,K,W)=>{I9(H);let U={name:K,inputNames:["A"],inputTypes:[0]};return[Q.run({...U,cacheHint:j.cacheKey,get:()=>E9(Q,H,j,K,W,U)},H)]},D3=(Q)=>{let H=Q.attributes.getInts("axes",[]),j=Q.attributes.getInt("keepdims",1)===1;return K1({axes:H,keepDims:j})},E9=(Q,H,j,K,W,U)=>{let Z=[],q=H[0].dims.length||1,G=[],J=u.normalizeAxes(j.axes,H[0].dims.length),X=W(H,J),V=X[1];for(let z=0;z<H[0].dims.length;z++)J.indexOf(z)>=0||J.length===0?(j.keepDims&&Z.push(1),V=`
          for(int j${z} = 0; j${z} < ${H[0].dims[z]}; j${z}++) {
            inputIdx[${z}] = j${z};
            ${V}
          }`):(G.push(`inputIdx[${z}] = outputIdx[${Z.length}];`),Z.push(H[0].dims[z]));let R=`
      float process(int outputIdx[${Z.length||1}]) {
        float value;                 // final result
        int inputIdx[${q}];      // addressing input data
        ${G.join(`
`)}
        ${X[0]}       // init ops for reduce max/min
        ${V}
        ${X[2]}       // final computation for reduce mean
        return value;
      }`;return{...U,output:{dims:Z,type:H[0].type,textureType:0},shaderSource:R}},I9=(Q)=>{if(!Q||Q.length!==1)throw new Error("Reduce op requires 1 input.");if(u4.indexOf(Q[0].type)===-1)throw new Error("Invalid input type.")},yQ=(Q,H,j)=>w3(Q,H,j,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),dQ=(Q,H,j)=>w3(Q,H,j,"ReduceMean",(K,W)=>{let U=1;for(let Z=0;Z<K[0].dims.length;Z++)(W.indexOf(Z)>=0||W.length===0)&&(U*=K[0].dims[Z]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${U}.;`]}),pQ=(Q,H,j)=>w3(Q,H,j,"ReduceMax",(K,W)=>{let U=[];for(let Z=0;Z<K[0].dims.length;Z++)(W.indexOf(Z)>=0||W.length===0)&&U.push(`inputIdx[${Z}] = 0;`);return[`${U.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),hQ=(Q,H,j)=>w3(Q,H,j,"ReduceMin",(K,W)=>{let U=[];for(let Z=0;Z<K[0].dims.length;Z++)(W.indexOf(Z)>=0||W.length===0)&&U.push(`inputIdx[${Z}] = 0;`);return[`${U.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),bQ=(Q,H,j)=>w3(Q,H,j,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),mQ=(Q,H,j)=>w3(Q,H,j,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),cQ=(Q,H,j)=>w3(Q,H,j,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])}),fQ,pj=E(()=>{Q1(),fQ=(Q,H)=>{let j=u.calculateReshapedDims(H[0].dims,H[1].integerData);return Q.session.pack?[Q.reshapePacked(H[0],j)]:[Q.reshapeUnpacked(H[0],j)]}}),e5,y6,lQ,uQ,d4,x9,d6,N5,sQ=E(()=>{_1(),W1(),t(),e5={name:"Upsample",inputNames:["X"],inputTypes:[0]},y6=(Q,H,j)=>(d6(H,j),[Q.run({...e5,cacheHint:j.cacheKey,get:()=>x9(Q,H,j)},H)]),lQ=(Q)=>d4(Q,7),uQ=(Q)=>d4(Q,9),d4=(Q,H)=>{let j=H>=10,K=Q.attributes.getString("mode","nearest");if(K!=="nearest"&&K!=="linear"&&(H<11||K!=="cubic"))throw new Error(`unrecognized mode: ${K}`);let W=[];H<9&&(W=Q.attributes.getFloats("scales"),N5(W,K,j));let U=Q.attributes.getFloat("extrapolation_value",0),Z=H>10?Q.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(Z)===-1)throw new Error(`coordinate_transform_mode '${Z}' is not supported`);let q=Z==="tf_crop_and_resize",G=q,J=K==="nearest"&&H>=11?Q.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(J)===-1)throw new Error(`nearest_mode '${J}' is not supported`);let X=Q.attributes.getFloat("cubic_coeff_a",-0.75),V=Q.attributes.getInt("exclude_outside",0)!==0;if(V&&K!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");let R=H<11?!0:K==="nearest"&&Z==="asymmetric"&&J==="floor",z=0,Y=0,B=0;return H>10?Q.inputs.length>2?(z=1,Y=2,B=3):(Y=1,B=2):H===9&&(Y=1),K1({opset:H,isResize:j,mode:K,scales:W,extrapolationValue:U,coordinateTransformMode:Z,useExtrapolation:G,needRoiInput:q,nearestMode:J,cubicCoefficientA:X,excludeOutside:V,useNearest2xOptimization:R,roiInputIdx:z,scalesInputIdx:Y,sizesInputIdx:B})},x9=(Q,H,j)=>{let K=r(Q.session.backend.glContext.version),[W,U]=Q.calculateTextureWidthAndHeight(H[0].dims,0),Z=H[0].dims.map((B,k)=>Math.floor(B*j.scales[k])),[q,G]=Q.calculateTextureWidthAndHeight(Z,0),J=Z.length,X=new Array(J),V=new Array(J),R=`
      int output_pitches[${J}];
      int input_pitches[${J}];
      `;for(let B=J-1;B>=0;B--)X[B]=B===J-1?1:X[B+1]*Z[B+1],V[B]=B===J-1?1:V[B+1]*H[0].dims[B+1],R+=`
        output_pitches[${B}] = ${X[B]};
        input_pitches[${B}] = ${V[B]};
        `;let z=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${W}, ${U});
        float value = getColorAsFloat(${K.texture2D}(X, coords));
        return value;
      }
      `,Y=j.mode==="nearest"?`
    ${z}
    float process(int indices[${J}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${q}, ${G});

      ${R}

      int d, m;
      for (int dim = 0; dim < ${J}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:J===4?`
    ${z}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${q}, ${G});

      ${R}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${H[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${z}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${q}, ${G});

      ${R}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${H[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return{...e5,output:{dims:Z,type:H[0].type,textureType:0},shaderSource:Y,variables:[{name:"scales",type:"int",arrayLength:j.scales.length,data:j.scales.map((B)=>Math.ceil(B))}]}},d6=(Q,H)=>{if(!Q||H.opset<9&&Q.length!==1||H.opset>=9&&H.opset<11&&Q.length!==2||H.opset>=11&&Q.length<2)throw new Error("invalid inputs.");if(H.scales.length>0&&Q[0].dims.length!==H.scales.length)throw new Error("Invalid input shape.");if(Q[0].type==="string")throw new Error("Invalid input tensor types.")},N5=(Q,H,j)=>{if(j){for(let K of Q)if(K<=0)throw new Error("Scale value should be greater than 0.")}else for(let K of Q)if(K<1)throw new Error("Scale value should be greater than or equal to 1.");if((H==="linear"||H==="cubic")&&Q.length!==2&&(Q.length!==4||Q[0]!==1||Q[1]!==1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${j?"Resize":"Upsample"} opeartor.`)}}),V5,p6,iQ,oQ,O9,g9,y9,d9,hj=E(()=>{W1(),t(),F3(),U4(),sQ(),V5={name:"Resize",inputNames:["A"],inputTypes:[2]},p6=(Q,H,j)=>(d6(H,j),[Q.run({...V5,cacheHint:j.cacheKey,get:()=>O9(Q,H,j)},H)]),iQ=(Q)=>d4(Q,10),oQ=(Q)=>d4(Q,11),O9=(Q,H,j)=>{let K=r(Q.session.backend.glContext.version),[W,U]=g9(H,j);if(W.every((A)=>A===1)&&j.coordinateTransformMode!=="tf_crop_and_resize")return{...V5,output:{dims:U,type:H[0].type,textureType:2},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${K.texture2D}(X, TexCoords);
                    ${K.output} = v;
                }`};let Z=U.length;if(Z<2)throw new Error(`output dimension should be at least 2, but got ${Z}`);let q=U[Z-2],G=U[Z-1],J=H[0].dims;if(Z!==J.length)throw new Error(`output dimension should match input ${J.length}, but got ${Z}`);let X=J[Z-2],V=J[Z-1],R=W[Z-2],z=W[Z-1],Y="";if(j.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${j.mode}'`);switch(j.coordinateTransformMode){case"asymmetric":Y=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":Y=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":Y=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${G}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${q}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${G}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${q}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":Y=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${G}.0 - 1.0, ${q}.0 - 1.0, ${G}.0 - 1.0,
                            ${q}.0 - 1.0);
                        vec4 original = vec4(${V}.0 - 1.0, ${X}.0 - 1.0, ${V}.0 - 1.0,
                            ${X}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${j.coordinateTransformMode}'`)}let B=P3(Z),k=c4(),w=`
            const vec2 inputWH = vec2(${X}.0, ${V}.0);
            const vec4 scaleWHWH = vec4(float(${R}), float(${z}), float(${R}), float(${z}));
            ${k}
            ${Y}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${B} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${q-1};
                bool hasNextCol = rc.z < ${G-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${K.output} = vec4(newValue);
            }
        `;return{...V5,output:{dims:U,type:H[0].type,textureType:2},hasMain:!0,shaderSource:w}},g9=(Q,H)=>{let j=Q[0].dims,K=H.scales,W;if(K.length===0){let Z=Q[H.scalesInputIdx];if(Z&&Z.size!==0){if(Q[H.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");K=y9(Z,H.mode,H.isResize)}else{let q=Q[H.sizesInputIdx];if(!q||q.size===0)throw new Error("Either scales or sizes MUST be provided as input.");W=Array.from(q.integerData),K=d9(W,j,H.mode,H.isResize)}}else if(Q[H.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");let U=W||j.map((Z,q)=>Math.floor(Z*K[q]));return[K,U]},y9=(Q,H,j)=>{let K=Array.from(Q.floatData);return N5(K,H,j),K},d9=(Q,H,j,K)=>{let W=H.length,U=new Array(W);for(let Z=0,q=W;Z<q;Z++)if(H[Z]===0){if(Q[Z]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");U[Z]=1}else U[Z]=Q[Z]/H[Z];return N5(U,j,K),U}}),aQ,p9,bj=E(()=>{K4(),aQ=(Q,H)=>(p9(H),[new o1([H[0].dims.length],"int32",void 0,void 0,new Int32Array(H[0].dims))]),p9=(Q)=>{if(!Q||Q.length!==1)throw new Error("Shape requires 1 input.")}}),X5,nQ,rQ,Q6,h9,tQ,b9,m9,mj=E(()=>{_1(),k5(),Q1(),t(),X5={name:"Slice",inputNames:["A"],inputTypes:[0]},nQ=(Q,H,j)=>(h9(H),[Q.run({...X5,cacheHint:j.cacheKey,get:()=>Q6(Q,H[0],j)},H)]),rQ=(Q)=>{let H=Q.attributes.getInts("starts"),j=Q.attributes.getInts("ends"),K=Q.attributes.getInts("axes",[]);return K1({starts:H,ends:j,axes:K})},Q6=(Q,H,j)=>{let K=j.axes.length===0?H.dims.slice(0).map((X,V)=>V):j.axes,W=u.normalizeAxes(K,H.dims.length),U=j.starts.map((X,V)=>X>H.dims[W[V]]-1?H.dims[W[V]]:u.normalizeAxis(X,H.dims[W[V]])),Z=j.ends.map((X,V)=>X>H.dims[W[V]]-1?H.dims[W[V]]:u.normalizeAxis(X,H.dims[W[V]])),q=H.dims.slice(),G=[];for(let X=0;X<W.length;X++)q[W[X]]=Z[X]-U[X],U[X]>0&&G.push(`outputIdx[${W[X]}] += ${U[X]};`);let J=`
      float process(int outputIdx[${q.length}]) {
        ${G.join(`
      `)}
        return _A(outputIdx);
      }`;return{...X5,output:{dims:q,type:H.type,textureType:0},shaderSource:J}},h9=(Q)=>{if(!Q||Q.length!==1)throw new Error("Slice requires 1 input.");if(u4.indexOf(Q[0].type)===-1)throw new Error("Invalid input type.")},tQ=(Q,H)=>{m9(H);let j=b9(Q,H);return[Q.run({...X5,cacheHint:j.cacheKey,get:()=>Q6(Q,H[0],j)},[H[0]])]},b9=(Q,H)=>{if(!Q.session.isInitializer(H[1].dataId)||!Q.session.isInitializer(H[2].dataId)||H.length>=4&&!Q.session.isInitializer(H[3].dataId)||H.length>=5&&!Q.session.isInitializer(H[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(H.length>=5&&H[4].integerData.some((Z)=>Z!==1))throw new Error("currently non-1 steps is not supported for Slice");let j=Array.from(H[1].integerData),K=Array.from(H[2].integerData),W=H.length>=4?Array.from(H[3].integerData):[],U=`${W};${j};${K}`;return{starts:j,ends:K,axes:W,cacheKey:U}},m9=(Q)=>{if(!Q||Q.length<3||Q.length>5)throw new Error("Invalid input number.");if(Q[1].type!=="int32"||Q[1].dims.length!==1)throw new Error("Invalid input type.");if(Q[2].type!=="int32"||Q[2].dims.length!==1)throw new Error("Invalid input type.");if(Q.length>=4&&(Q[3].type!=="int32"||Q[3].dims.length!==1))throw new Error("Invalid input type.");if(Q.length>=5&&(Q[4].type!=="int32"||Q[4].dims.length!==1))throw new Error("Invalid input type.")}}),J6,H6,Z6,eQ,QJ,JJ,HJ,j6,c9,f9,l9,V6,cj=E(()=>{_1(),Q1(),W1(),t(),X7(),J6={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[0]},H6={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[0,0]},Z6={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[0,0,0]},eQ=(Q,H,j)=>{V6(H);let K=H[0].dims.slice(),W=u.normalizeAxis(j.axis,K.length),U=u.sizeToDimension(K,W),Z=u.sizeFromDimension(K,W);return j6(Q,H,j,U,Z)},QJ=(Q)=>K1({axis:Q.attributes.getInt("axis",1)}),JJ=(Q)=>K1({axis:Q.attributes.getInt("axis",-1)}),HJ=(Q,H,j)=>{V6(H);let K=H[0].dims.slice(),W=u.normalizeAxis(j.axis,K.length),U=K.length,Z=W!==U-1,q=[],G=[],J=[],X;Z&&(G=Array.from({length:U}).map((Y,B)=>B),G[W]=U-1,G[U-1]=W,G.map((Y)=>q.push(K[Y])),X=K1({perm:G}),J=m4(Q,H,X));let V=Z?u.sizeToDimension(q,U-1):u.sizeToDimension(K,U-1),R=Z?u.sizeFromDimension(q,U-1):u.sizeFromDimension(K,U-1),z=j6(Q,Z?J:H,j,V,R);return Z?m4(Q,z,X):z},j6=(Q,H,j,K,W)=>{let U=c9(Q,H[0],K,W,[K]),Z=Q.run({...J6,cacheHint:j.cacheKey,get:()=>U},H),q=f9(Q,H[0],K,W,U.output.dims,[K]),G=Q.run({...H6,cacheHint:j.cacheKey,get:()=>q},[H[0],Z]),J=l9(Q,H[0],K,W,U.output.dims,q.output.dims);return[Q.run({...Z6,cacheHint:j.cacheKey,get:()=>J},[H[0],Z,G])]},c9=(Q,H,j,K,W)=>{let[U,Z]=Q.calculateTextureWidthAndHeight(H.dims,0),q=W.length;if(j<1||K<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(W.length!==1)throw new Error("Dimensionality of the output should be 1");if(W[0]!==j)throw new Error("Shape of the output should be equal to logical row count");let G=r(Q.session.backend.glContext.version),J=`
      float process(int[${q}] indices) {
        int logical_row_start_offset = indices[0] * ${K};

        float max = getColorAsFloat(${G.texture2D}(A, offsetToCoords(logical_row_start_offset, ${U},
        ${Z} )));
        for(int i=1; i<${K}; ++i)
        {
          float current = getColorAsFloat(${G.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${U}, ${Z})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return{...J6,output:{dims:W,type:H.type,textureType:0},shaderSource:J}},f9=(Q,H,j,K,W,U)=>{let[Z,q]=Q.calculateTextureWidthAndHeight(H.dims,0),G=U.length;if(j<1||K<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(U.length!==1)throw new Error("Dimensionality of the output should be 1");if(U[0]!==j)throw new Error("Shape of the output should be equal to logical row count");if(W.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(W[0]!==j)throw new Error("Shape of the intermediate results should be equal to logical row count");let J=r(Q.session.backend.glContext.version),X=`
      float process(int[${G}] indices) {
        int logical_row_start_offset = indices[0] * ${K};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${K}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${J.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${Z}, ${q}))) - max);
        }

        return norm_factor;
      }`;return{...H6,output:{dims:U,type:H.type,textureType:0},shaderSource:X}},l9=(Q,H,j,K,W,U)=>{let[Z,q]=Q.calculateTextureWidthAndHeight(H.dims,0),G=H.dims.length;if(j<1||K<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(W.length!==1||U.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(W[0]!==j||U[0]!==j)throw new Error("Shape of the intermediate results should be equal to logical row count");let J=`
      float process(int[${G}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${Z}, ${q});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${K};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return{...Z6,output:{dims:H.dims,type:H.type,textureType:0},shaderSource:J}},V6=(Q)=>{if(!Q||Q.length!==1)throw new Error("Softmax requires 1 input.");if(Q[0].type!=="float32"&&Q[0].type!=="float64")throw new Error("Invalid input type")}}),X6,ZJ,jJ,u9,s9,i9,fj=E(()=>{_1(),Q1(),t(),X6={name:"Split",inputNames:["A"],inputTypes:[0]},ZJ=(Q,H,j)=>{i9(H);let K=u.normalizeAxis(j.axis,H[0].dims.length),W=u9(Q,H,K,j),U=[];for(let Z=0;Z<W;++Z)U.push(Q.run({...X6,cacheHint:`${j.cacheKey};${Z}`,get:()=>s9(Q,H[0],j,K,Z)},H));return U},jJ=(Q)=>{let H=Q.attributes.getInt("axis",0),j=Q.attributes.getInts("split",[]),K=Q.outputs.length;return K1({axis:H,split:j,numOutputs:K})},u9=(Q,H,j,K)=>{let[,W]=L6.splitShape(H[0].dims,j,K.split,K.numOutputs);return W.length},s9=(Q,H,j,K,W)=>{let[U,Z]=L6.splitShape(H.dims,K,j.split,j.numOutputs),q=Z[W],G=U[W],J=`
      float process(int indices[${G.length}]) {
        indices[${K}] += ${q};
        return _A(indices);
      }
    `;return{...X6,cacheHint:`${j.cacheKey}:${W}`,output:{dims:G,type:H.type,textureType:0},shaderSource:J}},i9=(Q)=>{if(!Q||Q.length!==1)throw new Error("Split requires one input.");if(Q[0].type!=="int8"&&Q[0].type!=="uint8"&&Q[0].type!=="int16"&&Q[0].type!=="uint16"&&Q[0].type!=="int32"&&Q[0].type!=="uint32"&&Q[0].type!=="float32"&&Q[0].type!=="float64"&&Q[0].type!=="bool")throw new Error("Invalid input type.")}}),h6,VJ,XJ,o9,a9,lj=E(()=>{Q1(),h6=(Q,H,j)=>{o9(H);let K=u.squeezeShape(H[0].dims,j);return[Q.reshapeUnpacked(H[0],K)]},VJ=(Q,H)=>(a9(H),h6(Q,[H[0]],Array.from(H[1].integerData))),XJ=(Q)=>Q.attributes.getInts("axes"),o9=(Q)=>{if(!Q||Q.length!==1)throw new Error("Squeeze requires 1 input.");if(Q[0].type==="string")throw new Error("invalid input tensor types.")},a9=(Q)=>{if(!Q||Q.length!==2)throw new Error("Squeeze requires 2 inputs.");if(Q[1].type!=="int32")throw new Error("Invalid input type.")}}),KJ,n9,r9,uj=E(()=>{W1(),t(),KJ=(Q,H)=>{r9(H);let j={name:"Sum",inputNames:H.map((K,W)=>`X${W}`),inputTypes:new Array(H.length).fill(0)};return[Q.run({...j,get:()=>n9(Q,H,j)},H)]},n9=(Q,H,j)=>{let K=r(Q.session.backend.glContext.version),W=H[0].dims.slice(),U=`
      void main() {
        vec4 result = ${H.map((Z,q)=>`${K.texture2D}(X${q},TexCoords)`).join(" + ")};
        ${K.output} = result;
      }
    `;return{...j,output:{dims:W,type:H[0].type,textureType:0},hasMain:!0,shaderSource:U}},r9=(Q)=>{if(!Q||Q.length===0)throw new Error("Sum requires inputs.");let H=Q[0].dims.length;for(let j=1;j<Q.length;j++){if(H!==Q[j].dims.length)throw new Error("Input shapes are mismatched.");for(let K=0;K<H;K++)if(Q[0].dims[K]!==Q[j].dims[K])throw new Error("Input shapes are not matched.")}if(Q[0].type!=="float32"&&Q[0].type!=="float64")throw new Error("Invalid input type.");for(let j=1;j<Q.length;j++)if(Q[0].type!==Q[j].type)throw new Error("Input types are not matched.")}}),UJ,t9,e9,sj=E(()=>{k5(),t(),UJ=(Q,H)=>{e9(H);let j={name:"Tile",inputNames:["A"],inputTypes:[0]};return[Q.run({...j,get:()=>t9(Q,H,j)},H)]},t9=(Q,H,j)=>{let K=H[0].dims.slice(),W=new Array(K.length),U=[];for(let G=0;G<K.length;G++)W[G]=K[G]*H[1].numberData[G],U.push(`inputIdx[${G}] = int(mod(float(outputIdx[${G}]), ${K[G]}.));`);let Z=W.length,q=`
      float process(int outputIdx[${Z}]) {
        int inputIdx[${Z}];
        ${U.join(`
`)}
        return _A(inputIdx);
      }
    `;return{...j,output:{dims:W,type:H[0].type,textureType:0},shaderSource:q}},e9=(Q)=>{if(!Q||Q.length!==2)throw new Error("Tile requires 2 input.");if(Q[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(Q[1].dims[0]!==Q[0].dims.length)throw new Error("Invalid input shape.");if(u4.indexOf(Q[0].type)===-1)throw new Error("Invalid input type.");if(Q[1].type!=="int32"&&Q[1].type!=="int16")throw new Error("Invalid repeat type.")}}),b6,qJ,WJ,Q2,J2,ij=E(()=>{Q1(),b6=(Q,H,j)=>{Q2(H);let K=u.unsqueezeShape(H[0].dims,j);return[Q.reshapeUnpacked(H[0],K)]},qJ=(Q,H)=>(J2(H),b6(Q,[H[0]],Array.from(H[1].integerData))),WJ=(Q)=>Q.attributes.getInts("axes"),Q2=(Q)=>{if(!Q||Q.length!==1)throw new Error("Unsqueeze requires 1 input.");if(Q[0].type==="string")throw new Error("invalid input tensor types.")},J2=(Q)=>{if(!Q||Q.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(Q[1].type!=="int32")throw new Error("Invalid input type.")}}),GJ,oj=E(()=>{Bj(),Fj(),kj(),Sj(),V7(),Tj(),Dj(),_j(),Pj(),Ej(),Ij(),xj(),Oj(),Z7(),gj(),yj(),dj(),pj(),hj(),bj(),mj(),cj(),fj(),lj(),uj(),sj(),X7(),t0(),ij(),sQ(),GJ=[["Abs","","6+",_0],["Acos","","7+",P0],["Add","","7+",R0],["And","","7+",z0],["Asin","","7+",E0],["Atan","","7+",I0],["AveragePool","","7+",_Q,PQ],["BatchNormalization","","7+",U0,q0],["Cast","","6+",L0,v0],["Ceil","","6+",g0],["Clip","","6-10",_6,x0],["Clip","","11+",O0],["Concat","","4+",T0,D0],["Conv","","1+",I6,x6],["ConvTranspose","","1+",qQ,WQ],["Cos","","7+",y0],["Div","","7+",N0],["Dropout","","7+",P6],["DepthToSpace","","1+",RQ,zQ],["Equal","","7+",M0],["Elu","","6+",d0,p0],["Exp","","6+",h0],["Flatten","","1+",NQ,MQ],["Floor","","6+",b0],["FusedConv","com.microsoft","1+",I6,x6],["Gather","","1+",YQ,CQ],["Gemm","","7-10",O6,BQ],["Gemm","","11+",O6,FQ],["GlobalAveragePool","","1+",EQ,IQ],["GlobalMaxPool","","1+",gQ],["Greater","","7+",Y0],["Identity","","1+",P6],["ImageScaler","","1+",kQ,AQ],["InstanceNormalization","","6+",SQ,$Q],["LeakyRelu","","6+",m0,c0],["Less","","7+",C0],["LRN","","1+",LQ,vQ],["Log","","6+",f0],["MatMul","","1+",JQ,HQ],["MaxPool","","1+",xQ,OQ],["Mul","","7+",B0],["Neg","","6+",l0],["Not","","1+",u0],["Or","","7+",F0],["Pad","","2-10",g6,wQ],["Pad","","11+",TQ,DQ],["Pow","","7+",k0],["PRelu","","7+",A0],["ReduceLogSum","","1+",mQ,D3],["ReduceMax","","1+",pQ,D3],["ReduceMean","","1+",dQ,D3],["ReduceMin","","1+",hQ,D3],["ReduceProd","","1+",bQ,D3],["ReduceSum","","1-12",yQ,D3],["ReduceSumSquare","","1+",cQ,D3],["Relu","","6+",s0],["Reshape","","5+",fQ],["Resize","","10",p6,iQ],["Resize","","11+",p6,oQ],["Shape","","1+",aQ],["Sigmoid","","6+",i0],["Sin","","7+",o0],["Slice","","10+",tQ],["Slice","","1-9",nQ,rQ],["Softmax","","1-12",eQ,QJ],["Softmax","","13+",HJ,JJ],["Split","","2-12",ZJ,jJ],["Sqrt","","6+",a0],["Squeeze","","1-12",h6,XJ],["Squeeze","","13+",VJ],["Sub","","7+",S0],["Sum","","6+",KJ],["Tan","","7+",n0],["Tanh","","6+",r0],["Tile","","6+",UJ],["Transpose","","1+",m4,GQ],["Upsample","","7-8",y6,lQ],["Upsample","","9",y6,uQ],["Unsqueeze","","1-12",b6,WJ],["Unsqueeze","","13+",qJ],["Xor","","7+",$0]]}),m6,RJ,aj=E(()=>{m6=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm,RJ="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;"}),zJ,NJ=E(()=>{V3(),Q1(),zJ=class{constructor(Q){this.maxTextureSize=Q}computeTextureWH(Q,H){let j=this.computeTexture(Q,H);return H&&H.isPacked&&(j[0]/=2,j[1]/=2),H&&H.reverseWH?[j[1],j[0]]:j}computeTexture(Q,H){let j=H&&H.isPacked;if(Q.length===0)return j?[2,2]:[1,1];let K=this.maxTextureSize;if(H&&H.breakAxis!==void 0){let Z=H.breakAxis>=Q.length?1:Q.slice(H.breakAxis).reduce((G,J)=>G*J),q=H.breakAxis<=0?1:Q.slice(0,H.breakAxis).reduce((G,J)=>G*J);if(Z>K||q>K)C1.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${Q}, breakAxis:${H.breakAxis}`);else return[Z,q]}let W=Q.slice(0);j&&(K=K*2,W=W.map((Z,q)=>q>=W.length-2?W[q]%2===0?W[q]:W[q]+1:W[q]),W.length===1&&(W=[2,W[0]])),W.length!==2&&(W=E4(W).newShape);let U=$Z(W);return W.length<=1&&U<=K?[1,U]:W.length===2&&W[0]<=K&&W[1]<=K?W:W.length===3&&W[0]*W[1]<=K&&W[2]<=K?[W[0]*W[1],W[2]]:W.length===3&&W[0]<=K&&W[1]*W[2]<=K?[W[0],W[1]*W[2]]:W.length===4&&W[0]*W[1]*W[2]<=K&&W[3]<=K?[W[0]*W[1]*W[2],W[3]]:W.length===4&&W[0]<=K&&W[1]*W[2]*W[3]<=K?[W[0],W[1]*W[2]*W[3]]:j?i7(U/4).map((Z)=>Z*2):i7(U)}}}),MJ,nj=E(()=>{Q1(),E3(),W1(),NJ(),F3(),MJ=class extends q4{constructor(Q){super(Q)}getFunctions(){return{...this.offsetToCoords(),...this.coordsToOffset(),...this.toVec(),...this.valueFrom(),...this.getCommonUtilFuncs(),...this.getInputsSamplingSnippets(),...this.getOutputSamplingSnippet()}}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new y(`
      vec2 ${"offsetToCoords"}(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){return{coordsToOffset:new y(`
      int ${"coordsToOffset"}(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){let Q=this.context.outputTextureLayout;return Q.isPacked?this.getPackedOutputSamplingSnippet(Q):this.getUnpackedOutputSamplingSnippet(Q)}getPackedOutputSamplingSnippet(Q){let H=Q.unpackedShape,j=[Q.width,Q.height],K={},W="getOutputCoords";switch(H.length){case 0:K[W]=this.getOutputScalarCoords();break;case 1:K[W]=this.getOutputPacked1DCoords(H,j);break;case 2:K[W]=this.getOutputPacked2DCoords(H,j);break;case 3:K[W]=this.getOutputPacked3DCoords(H,j);break;default:K[W]=this.getOutputPackedNDCoords(H,j)}let U=`
      void setOutput(vec4 val) {
        ${r(this.context.glContext.version).output} = val;
      }
    `,Z="floatTextureSetRGBA";return K[Z]=new y(U),K}getUnpackedOutputSamplingSnippet(Q){let H=Q.unpackedShape,j=[Q.width,Q.height],K={},W="getOutputCoords";switch(H.length){case 0:K[W]=this.getOutputScalarCoords();break;case 1:K[W]=this.getOutputUnpacked1DCoords(H,j);break;case 2:K[W]=this.getOutputUnpacked2DCoords(H,j);break;case 3:K[W]=this.getOutputUnpacked3DCoords(H,j);break;case 4:K[W]=this.getOutputUnpacked4DCoords(H,j);break;case 5:K[W]=this.getOutputUnpacked5DCoords(H,j);break;case 6:K[W]=this.getOutputUnpacked6DCoords(H,j);break;default:throw new Error(`Unsupported output dimensionality: ${H.length}`)}let U=`
        void setOutput(float val) {
          ${r(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `,Z="floatTextureSetR";return K[Z]=new y(U),K}getOutputScalarCoords(){return new y(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(Q,H){let j=H,K="";return j[0]===1?(K=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${j[1]}.0);
          }
        `,new y(K)):j[1]===1?(K=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${j[0]}.0);
          }
        `,new y(K)):(K=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${j[0]}, ${j[1]}));
          return 2 * (resTexRC.y * ${j[0]} + resTexRC.x);
        }
      `,new y(K))}getOutputPacked2DCoords(Q,H){let j="";if(x4.arraysEqual(Q,H))return j=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${H[0]}, ${H[1]}));
        }
      `,new y(j);let K=H,W=Math.ceil(Q[1]/2);return j=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${K[0]}, ${K[1]}));

          int index = resTexRC.y * ${K[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${W}) * 2;
          int c = 2 * (index / ${W});

          return ivec2(r, c);
        }
      `,new y(j)}getOutputPacked3DCoords(Q,H){let j=[H[0],H[1]],K=Math.ceil(Q[2]/2),W=K*Math.ceil(Q[1]/2),U=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${j[0]}, ${j[1]}));
          int index = resTexRC.y * ${j[0]} + resTexRC.x;

          int b = index / ${W};
          index -= b * ${W};

          // reverse r and c order for packed texture
          int r = imod(index, ${K}) * 2;
          int c = 2 * (index / ${K});

          return ivec3(b, r, c);
        }
      `;return new y(U)}getOutputPackedNDCoords(Q,H){let j=[H[0],H[1]],K=Math.ceil(Q[Q.length-1]/2),W=K*Math.ceil(Q[Q.length-2]/2),U=W,Z="",q="b, r, c";for(let J=2;J<Q.length-1;J++)U*=Q[Q.length-J-1],Z=`
      int b${J} = index / ${U};
      index -= b${J} * ${U};
    `+Z,q=`b${J}, `+q;let G=`
      ivec${Q.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${j[0]}, ${j[1]}));
        int index = resTexRC.y * ${j[0]} + resTexRC.x;

        ${Z}

        int b = index / ${W};
        index -= b * ${W};

        // reverse r and c order for packed texture
        int r = imod(index, ${K}) * 2;
        int c = 2 * (index / ${K});

        return ivec${Q.length}(${q});
      }
    `;return new y(G)}getOutputUnpacked1DCoords(Q,H){let j=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${H[0]}, ${H[1]}));
          return resTexRC.y * ${H[0]} + resTexRC.x;
        }
      `;return new y(j)}getOutputUnpacked2DCoords(Q,H){let j=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${H[0]}, ${H[1]}));
          int index = resTexRC.y * ${H[0]} + resTexRC.x;
          int r = index / ${Q[1]};
          int c = index - r * ${Q[1]};
          return ivec2(r, c);
        }
      `;return new y(j)}getOutputUnpacked3DCoords(Q,H){let j="",K=Q.length,W=null;K<2&&(W=[]),W=new Array(K-1),W[K-2]=Q[K-1];for(let q=K-3;q>=0;--q)W[q]=W[q+1]*Q[q+1];let U=["r","c","d"],Z=W.map((q,G)=>{let J=`int ${U[G]} = index / ${q}`,X=G===W.length-1?`int ${U[G+1]} = index - ${U[G]} * ${q}`:`index -= ${U[G]} * ${q}`;return`${J}; ${X};`}).join("");return j=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${H[0]}, ${H[1]}));
          int index = resTexRC.y * ${H[0]} + resTexRC.x;
          ${Z}
          return ivec3(r, c, d);
        }
      `,new y(j)}getOutputUnpacked4DCoords(Q,H){let j="",K=Q.length,W=null;K<2&&(W=[]),W=new Array(K-1),W[K-2]=Q[K-1];for(let q=K-3;q>=0;--q)W[q]=W[q+1]*Q[q+1];let U=["r","c","d","d2"],Z=W.map((q,G)=>{let J=`int ${U[G]} = index / ${q}`,X=G===W.length-1?`int ${U[G+1]} = index - ${U[G]} * ${q}`:`index -= ${U[G]} * ${q}`;return`${J}; ${X};`}).join("");return j=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${H[0]}, ${H[1]}));
          int index = resTexRC.y * ${H[0]} + resTexRC.x;
          ${Z}
          return ivec4(r, c, d, d2);
        }
      `,new y(j)}getOutputUnpacked5DCoords(Q,H){let j="",K=Q.length,W=null;K<2&&(W=[]),W=new Array(K-1),W[K-2]=Q[K-1];for(let q=K-3;q>=0;--q)W[q]=W[q+1]*Q[q+1];let U=["r","c","d","d2","d3"],Z=W.map((q,G)=>{let J=`int ${U[G]} = index / ${q}`,X=G===W.length-1?`int ${U[G+1]} = index - ${U[G]} * ${q}`:`index -= ${U[G]} * ${q}`;return`${J}; ${X};`}).join("");return j=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${H[0]}, ${H[1]}));
          int index = resTexRC.y * ${H[0]} + resTexRC.x;
          ${Z}
          return ivec5(r, c, d, d2, d3);
        }
      `,new y(j)}getOutputUnpacked6DCoords(Q,H){let j="",K=Q.length,W=null;K<2&&(W=[]),W=new Array(K-1),W[K-2]=Q[K-1];for(let q=K-3;q>=0;--q)W[q]=W[q+1]*Q[q+1];let U=["r","c","d","d2","d3","d4"],Z=W.map((q,G)=>{let J=`int ${U[G]} = index / ${q}`,X=G===W.length-1?`int ${U[G+1]} = index - ${U[G]} * ${q}`:`index -= ${U[G]} * ${q}`;return`${J}; ${X};`}).join("");return j=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${H[0]}, ${H[1]}));
         int index = resTexRC.y * ${H[0]} + resTexRC.x;
         ${Z}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new y(j)}getCommonUtilFuncs(){let Q={},H="uvFromFlat";Q[H]=new y(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),H="packedUVfrom1D",Q[H]=new y(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),H="packedUVfrom2D",Q[H]=new y(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),H="packedUVfrom3D",Q[H]=new y(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),H="sampleTexture";let j=r(this.context.glContext.version);return Q[H]=new y(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${j.texture2D}(textureSampler, uv).r;
        }`),Q}getInputsSamplingSnippets(){let Q={},H=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((j,K)=>{let W=this.context.inputTextureLayouts[K],U=P5(j);W.isPacked?Q[U]=this.getPackedSamplerFromInput(U,j,W):Q[U]=this.getUnpackedSamplerFromInput(U,j,W);let Z=DH(j);W.unpackedShape.length<=H.unpackedShape.length&&(W.isPacked?Q[Z]=this.getPackedSamplerAtOutputCoords(Z,W,H,j):Q[Z]=this.getUnpackedSamplerAtOutputCoords(Z,W,H,j))}),Q}getPackedSamplerAtOutputCoords(Q,H,j,K){let W=H.unpackedShape,U=j.unpackedShape,Z=P5(K),q=W.length,G=U.length,J=R3.getBroadcastDims(W,U),X=P3(G),V=G-q,R,z=H4();q===0?R="":G<2&&J.length>=1?R="coords = 0;":R=J.map((I)=>`coords.${z[I+V]} = 0;`).join(`
`);let Y="";G<2&&q>0?Y="coords":Y=W.map((I,h)=>`coords.${z[h+V]}`).join(", ");let B="return outputValue;",k=u.size(W)===1,w=u.size(U)===1;if(q===1&&!k&&!w)B=`
        return vec4(outputValue.xy, outputValue.xy);
      `;else if(k&&!w)G===1?B=`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:B=`
          return vec4(outputValue.x);
        `;else if(J.length){let I=q-2,h=q-1;J.indexOf(I)>-1&&J.indexOf(h)>-1?B="return vec4(outputValue.x);":J.indexOf(I)>-1?B="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":J.indexOf(h)>-1&&(B="return vec4(outputValue.xx, outputValue.zz);")}let A=`
        int lastDim = coords.${z[G-1]};
        coords.${z[G-1]} = coords.${z[G-2]};
        coords.${z[G-2]} = lastDim;
      `,D=`
      vec4 ${Q}() {
        ${X} coords = getOutputCoords();
        ${A}
        ${R}
        vec4 outputValue = ${Z}(${Y});
        ${B}
      }
    `;return new y(D,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(Q,H,j,K){let W=[j.width,j.height],U=[H.width,H.height],Z=H.unpackedShape.length,q=j.unpackedShape.length,G=H.unpackedShape,J=j.unpackedShape,X=P5(K);if(Z===q&&x4.arraysEqual(U,W)){let A=`
          float ${Q}() {
            return sampleTexture(${K}, TexCoords);
          }
        `;return new y(A,["coordinates.sampleTexture"])}let V=P3(q),R=R3.getBroadcastDims(G,J),z=q-Z,Y,B=H4();Z===0?Y="":q<2&&R.length>=1?Y="coords = 0;":Y=R.map((A)=>`coords.${B[A+z]} = 0;`).join(`
`);let k="";q<2&&Z>0?k="coords":k=H.unpackedShape.map((A,D)=>`coords.${B[D+z]}`).join(", ");let w=`
        float ${Q}() {
          ${V} coords = getOutputCoords();
          ${Y}
          return ${X}(${k});
        }
      `;return new y(w,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(Q,H,j){switch(j.unpackedShape.length){case 0:return this.getPackedSamplerScalar(Q,H);case 1:return this.getPackedSampler1D(Q,H,j);case 2:return this.getPackedSampler2D(Q,H,j);case 3:return this.getPackedSampler3D(Q,H,j);default:return this.getPackedSamplerND(Q,H,j)}}getUnpackedSamplerFromInput(Q,H,j){let K=j.unpackedShape;switch(K.length){case 0:return this.getUnpackedSamplerScalar(Q,H,j);case 1:return this.getUnpackedSampler1D(Q,H,j);case 2:return this.getUnpackedSampler2D(Q,H,j);case 3:return this.getUnpackedSampler3D(Q,H,j);case 4:return this.getUnpackedSampler4D(Q,H,j);case 5:return this.getUnpackedSampler5D(Q,H,j);case 6:return this.getUnpackedSampler6D(Q,H,j);default:throw new Error(`Unsupported dimension ${K.length}-D`)}}getPackedSamplerScalar(Q,H){let j=r(this.context.glContext.version),K=`
          vec4 ${Q}() {
            return ${j.texture2D}(${H}, halfCR);
          }
        `;return new y(K)}getPackedSampler1D(Q,H,j){let K=[j.width,j.height],W=[K[1],K[0]],U=r(this.context.glContext.version),Z=`vec4 ${Q}(int index) {
      vec2 uv = packedUVfrom1D(
      ${W[0]}, ${W[1]}, index);
      return ${U.texture2D}(${H}, uv);
    }`;return new y(Z,["coordinates.packedUVfrom1D"])}getPackedSampler2D(Q,H,j){let K=j.unpackedShape,W=[j.width,j.height],U=r(this.context.glContext.version),Z=W[0],q=W[1];if(W!=null&&x4.arraysEqual(K,W)){let V=`vec4 ${Q}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${q}.0, ${Z}.0);
        return ${U.texture2D}(${H}, uv);
      }`;return new y(V)}let G=W,J=Math.ceil(K[1]/2),X=`vec4 ${Q}(int row, int col) {
      vec2 uv = packedUVfrom2D(${G[1]}, ${G[0]}, ${J}, row, col);
      return ${U.texture2D}(${H}, uv);
    }`;return new y(X,["coordinates.packedUVfrom2D"])}getPackedSampler3D(Q,H,j){let K=j.unpackedShape,W=[j.width,j.height],U=[W[0],W[1]],Z=r(this.context.glContext.version);if(K[0]===1){let R=K.slice(1),z=[1,2],Y=F4(K,R),B=["b","row","col"],k=JSON.parse(JSON.stringify(j));k.unpackedShape=Y;let w=this.getPackedSamplerFromInput(Q,H,k),A=`${w.routineBody}
      vec4 ${Q}(int b, int row, int col) {
        return ${Q}(${k4(B,z)});
      } `;return new y(A,w.dependencies)}let q=U[0],G=U[1],J=Math.ceil(K[2]/2),X=J*Math.ceil(K[1]/2),V=`vec4 ${Q}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${G}, ${q}, ${X}, ${J}, b, row, col);
      return ${Z.texture2D}(${H}, uv);}`;return new y(V,["coordinates.packedUVfrom3D"])}getPackedSamplerND(Q,H,j){let K=j.unpackedShape,W=K.length,U=[j.width,j.height],Z=r(this.context.glContext.version),q=[U[0],U[1]],G=q[1],J=q[0],X=Math.ceil(K[W-1]/2),V=X*Math.ceil(K[W-2]/2),R="int b, int row, int col",z=`b * ${V} + (row / 2) * ${X} + (col / 2)`;for(let B=2;B<W-1;B++)R=`int b${B}, `+R,V*=K[W-B-1],z=`b${B} * ${V} + `+z;let Y=`vec4 ${Q}(${R}) {
      int index = ${z};
      int texR = index / ${J};
      int texC = index - texR * ${J};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${J}, ${G});
      return ${Z.texture2D}(${H}, uv);
    }`;return new y(Y)}getUnpackedSamplerScalar(Q,H,j){let[K,W]=[j.width,j.height];if(K===1&&W===1){let Z=`
          float ${Q}() {
            return sampleTexture(${H}, halfCR);
          }
        `;return new y(Z,["coordinates.sampleTexture"])}let U=`
        float ${Q}() {
          int offset_${H} = coordsToOffset(TexCoords, ${K}, ${W});
          vec2 uv = uvFromFlat(${K}, ${W}, offset_${H});
          return sampleTexture(${H}, uv);
        }
      `;return new y(U,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(Q,H,j){let{width:K,height:W}=j;if(W===1&&K===1){let Z=`
        float ${Q}(int index) {
          return sampleTexture(${H}, halfCR);
        }
      `;return new y(Z,["coordinates.sampleTexture"])}if(W===1){let Z=`
          float ${Q}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${K}.0, 0.5);
            return sampleTexture(${H}, uv);
          }
        `;return new y(Z,["coordinates.sampleTexture"])}if(K===1){let Z=`
          float ${Q}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${W}.0);
            return sampleTexture(${H}, uv);
          }
        `;return new y(Z,["coordinates.sampleTexture"])}let U=`
        float ${Q}(int index) {
          vec2 uv = uvFromFlat(${K}, ${W}, index);
          return sampleTexture(${H}, uv);
        }
      `;return new y(U,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(Q,H,j){let K=j.unpackedShape,W=[j.height,j.width];if(W!=null&&x4.arraysEqual(K,W)){let V=W[1],R=W[0],z=`
          float ${Q}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${V}.0, ${R}.0);
            return sampleTexture(${H}, uv);
          }
        `;return new y(z,["coordinates.sampleTexture"])}let{newShape:U,keptDims:Z}=E4(K),q=U;if(q.length<K.length){let V=F4(K,q),R=JSON.parse(JSON.stringify(j));R.unpackedShape=V;let z=["col","row"],Y=`
          ${this.getUnpackedSamplerFromInput(Q,H,R).routineBody}
          float ${Q}(int row, int col) {
            return ${Q}(${k4(z,Z)});
          }
        `;return new y(Y,["coordinates.sampleTexture"])}let G=W[1],J=W[0];if(J===1){let V=`
          float ${Q}(int row, int col) {
            int offset_${H} = coordsToOffset(TexCoords, ${G}, ${J});
            float index = dot(vec3(row, col, offset_${H}), vec3(${K[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${G}.0);
            return sampleTexture(${H}, uv);
          }
        `;return new y(V,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(G===1){let V=`
          float ${Q}(int row, int col) {
            int offset_${H} = coordsToOffset(TexCoords, ${G}, ${J});
            float index = dot(vec3(row, col, offset_${H}), vec3(${K[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${J}.0, 0.5);
            return sampleTexture(${H}, uv);
          }
        `;return new y(V,["coordinates.sampleTexture","coordinates.coordsToOffset"])}let X=`
        float ${Q}(int row, int col) {
          int index = col * ${K[1]} + row;
          vec2 uv = uvFromFlat(${G}, ${J}, index);
          return sampleTexture(${H}, uv);
        }
      `;return new y(X,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(Q,H,j){let K=j.unpackedShape,W=K[1]*K[2],U=K[2],{newShape:Z,keptDims:q}=E4(K),G=Z;if(G.length<K.length){let R=F4(K,G),z=["batch","col","row"],Y=JSON.parse(JSON.stringify(j));Y.unpackedShape=R;let B=this.getUnpackedSamplerFromInput(Q,H,Y),k=q.reverse(),w=`
          ${B.routineBody}
          float ${Q}(int batch, int row, int col) {
            return ${Q}(${k4(z,k)});
          }
        `;return new y(w,B.dependencies)}let{width:J,height:X}=j,V=`
          float ${Q}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${W} + col * ${U} + row;
            vec2 uv = uvFromFlat(${J}, ${X}, index);
            return sampleTexture(${H}, uv);
          }
      `;return new y(V,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(Q,H,j){let K=j.unpackedShape,W=K[3],U=K[2]*W,Z=K[1]*U,q=j.width,G=j.height,J=`
        float ${Q}(int row, int col, int depth, int depth2) {
          int index = row * ${Z} + col * ${U} +
              depth2 * ${W} + depth;
          vec2 uv = uvFromFlat(${q}, ${G}, index);
          return sampleTexture(${H}, uv);
        }
      `;return new y(J,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(Q,H,j){let K=j.unpackedShape,W=K[4],U=K[3]*W,Z=K[2]*U,q=K[1]*Z,{newShape:G,keptDims:J}=E4(K);if(G.length<K.length){let z=F4(K,G),Y=["row","col","depth","depth2","depth3"],B=JSON.parse(JSON.stringify(j));B.unpackedShape=z;let k=`
          ${this.getUnpackedSamplerFromInput(Q,H,B).routineBody}
          float ${Q}(int row, int col, int depth, int depth2, int depth3) {
            return ${Q}(${k4(Y,J)});
          }
        `;return new y(k,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let{width:X,height:V}=j,R=`
        float ${Q}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${q} + col * ${Z} + depth * ${U} +
          depth3 * ${W} + depth2;
          vec2 uv = uvFromFlat(${X}, ${V}, index);
          return sampleTexture(${H}, uv);
        }
      `;return new y(R,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(Q,H,j){let K=j.unpackedShape,W=K[5],U=K[4]*W,Z=K[3]*U,q=K[2]*Z,G=K[1]*q,{newShape:J,keptDims:X}=E4(K);if(J.length<K.length){let Y=F4(K,J),B=["row","col","depth","depth2","depth3","depth4"],k=JSON.parse(JSON.stringify(j));k.unpackedShape=Y;let w=`
            ${this.getUnpackedSamplerFromInput(Q,H,k).routineBody}
            float ${Q}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${Q}(${k4(B,X)});
            }
          `;return new y(w,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let{width:V,height:R}=j,z=`
          float ${Q}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${G} + col * ${q} + depth * ${Z} +
            depth2 * ${U} + depth3 * ${W} + depth4;
            vec2 uv = uvFromFlat(${V}, ${R}, index);
            return sampleTexture(${H}, uv);
          }
        `;return new y(z,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){let Q=this.context.outputTextureLayout,H=Q.shape.length,j=Q.strides,K=Q.width,W=Q.height,U=[];for(let q=0;q<H-1;++q)U.push(`
        c[${q}] = offset / ${j[q]};`),U.push(`
        offset -= c[${q}] * ${j[q]};`);U.push(`
        c[${H-1}] = offset;`);let Z=`
      void toVec(vec2 texCoords, out int c[${H}]) {
        int offset = coordsToOffset(texCoords, ${K}, ${W});
        ${U.join("")}
      }
      void toVec(int offset, out int c[${H}]) {
        ${U.join("")}
      }
    `;return{toVec:new y(Z,["coordinates.coordsToOffset"])}}valueFrom(){let Q={};return this.context.programInfo.inputNames.forEach((H,j)=>{let K=this.context.inputTextureLayouts[j],W=(K.unpackedShape.length>0?K.unpackedShape:K.shape).length,U=`_${H}`;Q[U]=new y(this.getValueFromSingle(H,W,K.width,K.height,!1),[`shapeUtils.indicesToOffset${U}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),U=U+"_T",Q[U]=new y(this.getValueFromSingle(H,W,K.width,K.height,!0),[`shapeUtils.indicesToOffset${U}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),Q}getValueFromSingle(Q,H,j,K,W){let U=`_${Q}`;W&&(U=U+"_T");let Z=r(this.context.glContext.version);return`
        float ${U}(int m[${H}]) {
          int offset = indicesToOffset${U}(m);
          vec2 coords = offsetToCoords(offset, ${j}, ${K});
          float value = getColorAsFloat(${Z.texture2D}(${Q}, coords));
          return value;
        }
        `}getPackedValueFrom(Q,H,j,K,W){let U=`_${Q}_Pack`;W&&(U=U+"_T");let Z=r(this.context.glContext.version);return`
        vec4 ${U}(int m[${H}]) {
          int offset = indicesToOffset_${Q}(m);
          vec2 coords = offsetToCoords(offset, ${j}, ${K});
          return ${Z.texture2D}(${Q}, coords);
        }
        `}}}),YJ,rj=E(()=>{E3(),YJ=class Q extends q4{constructor(H){super(H)}getFunctions(){return{...this.encodeFloat32(),...this.decodeFloat32()}}getCustomTypes(){return{}}encodeFloat32(){return{encode:new y(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new y(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){let H=Q.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new y(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${H}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){let H=Q.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new y(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${H}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){let H=new ArrayBuffer(4),j=new Uint32Array(H),K=new Uint8Array(H);if(j[0]=3735928559,K[0]===239)return!0;if(K[0]===222)return!1;throw new Error("unknown endianness")}}}),CJ,tj=E(()=>{E3(),W1(),CJ=class extends q4{constructor(Q){super(Q)}getFunctions(){return{...this.setFragColor(),...this.getColorAsFloat()}}getCustomTypes(){return{}}setFragColor(){let Q=r(this.context.glContext.version);return{setFragColor:new y(`
        void setFragColor(float value) {
            ${Q.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new y(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}}),BJ,ej=E(()=>{E3(),BJ=class Q extends q4{constructor(H){super(H)}getFunctions(){return{...this.bcastIndex(),...this.bcastMatmulIndex(),...this.offsetToIndices(),...this.indicesToOffset(),...this.incrementIndices()}}getCustomTypes(){return{}}bcastIndex(){let H=this.context.outputTextureLayout.shape.length,j={};return this.context.programInfo.inputNames.forEach((K,W)=>{let U=this.context.inputTextureLayouts[W].unpackedShape;if(U.length<=H){let Z=U.length,q=H-Z,G=`bcastIndices_${K}`,J="";for(let V=0;V<Z;++V)J+=`
          realIndices[${V}] = int( mod(float(bcastedIndices[${q+V}]), ${U[V]}.0) );
          `;let X=`
        void ${G} (int bcastedIndices[${H}], out int realIndices[${Z}]) {
          ${J}
        }
        `;j[G]=new y(X)}}),j}bcastMatmulIndex(){let H=this.context.outputTextureLayout.shape.length,j={};return this.context.programInfo.inputNames.forEach((K,W)=>{let U=this.context.inputTextureLayouts[W].shape;if(!(U.length<2||U.length>H)){let Z=U.length,q=H-Z,G=`bcastMatmulIndices_${K}`,J="";for(let V=0;V<Z-2;++V)J+=`
          realIndices[${V}] = int( mod(float(bcastedIndices[${q+V}]), ${U[V]}.0) );
          `;let X=`
        void ${G}(int bcastedIndices[${H}], out int realIndices[${Z}]) {
          ${J}
          realIndices[${Z-1}] = bcastedIndices[${H-1}];
          realIndices[${Z-2}] = bcastedIndices[${H-2}];
        }
        `;j[G]=new y(X)}}),j}indicesToOffset(){let H={};return this.context.programInfo.inputNames.forEach((j,K)=>{let W=this.context.inputTextureLayouts[K].shape,U=this.context.inputTextureLayouts[K].strides,Z=W.length,q=`indicesToOffset_${j}`;H[q]=new y(Q.indexToOffsetSingle(q,Z,U)),q=`indicesToOffset_${j}_T`,H[q]=new y(Q.indexToOffsetSingle(q,Z,U.slice().reverse()))}),H}static indexToOffsetSingle(H,j,K){let W="";for(let U=j-1;U>=0;--U)W+=`
        offset += indices[${U}] * ${K[U]};
        `;return`
      int ${H}(int indices[${j}]) {
        int offset = 0;
        ${W}
        return offset;
      }
      `}offsetToIndices(){let H={};return this.context.programInfo.inputNames.forEach((j,K)=>{let W=this.context.inputTextureLayouts[K].shape,U=this.context.inputTextureLayouts[K].strides,Z=W.length,q=`offsetToIndices_${j}`;H[q]=new y(Q.offsetToIndicesSingle(q,Z,U)),q=`offsetToIndices_${j}_T`,H[q]=new y(Q.offsetToIndicesSingle(q,Z,U.slice().reverse()))}),H}static offsetToIndicesSingle(H,j,K){let W=[];for(let U=0;U<j-1;++U)W.push(`
      indices[${U}] = offset / ${K[U]};`),W.push(`
        offset -= indices[${U}] * ${K[U]};`);return W.push(`
      indices[${j-1}] = offset;`),`
      void ${H}(int offset, out int indices[${j}]) {
        ${W.join("")}
      }
      `}incrementIndices(){let H={};return this.context.programInfo.inputNames.forEach((j,K)=>{let W=this.context.inputTextureLayouts[K].shape,U=W.length,Z=`incrementIndices_${j}`,q="";for(let J=0;J<U;++J)q+=`
        shape[${J}] = ${W[J]};`;let G=`
        void ${Z}(int axis, out int indices[${U}]) {
          int shape[${U}];
          ${q};
          for(int i = ${U} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;H[Z]=new y(G)}),H}}}),FJ,QV=E(()=>{E3(),FJ=class extends q4{constructor(Q){super(Q)}getCustomTypes(){return{}}getFunctions(){return{...this.binaryVecFunctions(),...this.copyVec(),...this.setVecItem(),...this.getVecItem()}}binaryVecFunctions(){let Q=this.context.outputTextureLayout.shape.length,H={add:"+=",sub:"-=",mul:"*=",div:"/="},j={};for(let K in H){let W=`${K}Vec`,U="";for(let q=0;q<Q;++q)U+=`
          dest[${q}] ${H[K]} src[${q}];
          `;let Z=`
        void ${W}(int src[${Q}], out int dest[${Q}]) {
          ${U}
        }
        `;j[W]=new y(Z)}return j}copyVec(){let Q=this.context.outputTextureLayout.shape.length,H="";for(let K=0;K<Q;++K)H+=`
        dest[${K}] = src[${K}];
        `;let j=`
      void copyVec(int src[${Q}], out int dest[${Q}]) {
        ${H}
      }
      `;return{copyVec:new y(j)}}setVecItem(){let Q=this.context.outputTextureLayout.shape.length,H=`
        if(index < 0)
            index =${Q} + index;
        if (index == 0)
            m[0] = value;
        `;for(let K=1;K<Q-1;++K)H+=`
        else if (index == ${K})
            m[${K}] = value;
            `;H+=`
        else
            m[${Q-1}] = value;
        `;let j=`
      void setVecItem(out int m[${Q}], int index, int value) {
        ${H}
      }
        `;return{setVecItem:new y(j)}}getVecItem(){let Q=this.context.outputTextureLayout.shape.length,H=`
        if(index < 0)
            index = ${Q} + index;
        if (index == 0)
            return m[0];
      `;for(let K=1;K<Q-1;++K)H+=`
        else if (index == ${K})
            return m[${K}];
      `;H+=`
        else
            return m[${Q-1}];
        `;let j=`
      int getVecItem(int m[${Q}], int index) {
        ${H}
      }
    `;return{getVecItem:new y(j)}}}}),c6,JV=E(()=>{nj(),rj(),tj(),ej(),QV(),c6={encoding:YJ,fragcolor:CJ,vec:FJ,shapeUtils:BJ,coordinates:MJ}}),kJ,HV=E(()=>{E3(),aj(),JV(),W1(),kJ=class{constructor(Q,H,j,K){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new W0(Q,H,j,K),Object.keys(c6).forEach((U)=>{let Z=new c6[U](this.context);this.libs[U]=Z});let W=this.glslLibRoutineDependencyGraph;for(let U in this.libs){let Z=this.libs[U].getFunctions();for(let q in Z){let G=U+"."+q,J;W[G]?(J=W[G],J.routineBody=Z[q].routineBody):(J=new D6(G,Z[q].routineBody),W[G]=J);let X=Z[q].dependencies;if(X)for(let V=0;V<X.length;++V)if(W[X[V]])J.addDependency(W[X[V]]);else{let R=new D6(X[V]);W[X[V]]=R,J.addDependency(R)}}}}preprocess(){let Q=this.context.programInfo,H=Q.shaderSource;return this.context.programInfo.hasMain||(H=`${H}
      ${TH(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),H=kZ(H),`${wH(this.context.glContext.version)}
    ${this.getUniforms(Q.inputNames,Q.variables)}
    ${this.getImports(H)}
    ${H}`}getImports(Q){let H=this.selectGlslLibRoutinesToBeIncluded(Q);if(H.length===0)return"";let j="";for(let K=0;K<H.length;++K)if(H[K].routineBody)j+=H[K].routineBody+`
`;else throw new Error(`Missing body for the Glsl Library routine: ${H[K].name}`);return j}selectGlslLibRoutinesToBeIncluded(Q){let H=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach((j)=>{let K=j.split(".")[1];Q.indexOf(K)!==-1&&H.push(this.glslLibRoutineDependencyGraph[j])}),G0.returnOrderedNodes(H)}getUniforms(Q,H){let j=[];if(Q)for(let K of Q)j.push(`uniform sampler2D ${K};`);if(H)for(let K of H)j.push(`uniform ${K.type} ${K.name}${K.arrayLength?`[${K.arrayLength}]`:""};`);return j.join(`
`)}}}),AJ,ZV=E(()=>{z3(),V3(),HV(),W1(),AJ=class{constructor(Q,H,j){this.profiler=Q,this.glContext=H,this.textureLayoutStrategy=j,this.repo=new Map,this.attributesBound=!1}getArtifact(Q){return this.repo.get(Q)}setArtifact(Q,H){this.repo.set(Q,H)}run(Q,H,j){this.profiler.event("op",`ProgramManager.run ${Q.programInfo.name??"unknown kernel"}`,()=>{let K=this.glContext.gl,W=Q.program;K.useProgram(W);try{this.bindOutput(j),this.attributesBound||this.bindAttributes(Q.attribLocations),this.bindUniforms(Q.uniformLocations,Q.programInfo.variables??[],H)}catch(U){throw C1.error("ProgramManager",Q.programInfo.shaderSource),U}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach((Q)=>this.glContext.deleteProgram(Q.program))}build(Q,H,j){return this.profiler.event("backend","ProgramManager.build",()=>{let K=new kJ(this.glContext,Q,H,j),W=K.preprocess(),U=this.compile(W);return{programInfo:Q,program:U,uniformLocations:this.getUniformLocations(U,K.context.programInfo.inputNames,K.context.programInfo.variables),attribLocations:this.getAttribLocations(U)}})}compile(Q){if(!this.vertexShader){C1.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");let K=vH(this.glContext.version);this.vertexShader=this.glContext.compileShader(K,this.glContext.gl.VERTEX_SHADER)}i.debug&&C1.verbose("ProrgramManager",`FragShader:
${Q}
`);let H=this.glContext.compileShader(Q,this.glContext.gl.FRAGMENT_SHADER),j=this.glContext.createProgram(this.vertexShader,H);return this.glContext.deleteShader(H),j}bindOutput(Q){let{width:H,height:j}=Q;C1.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${H}/${j}, shape=${Q.shape}, type=${Q.tensor.type}`),this.glContext.attachFramebuffer(Q.texture,H,j)}bindAttributes(Q){let{position:H,textureCoord:j}=Q;this.glContext.setVertexAttributes(H,j),this.attributesBound=!0}bindUniforms(Q,H,j){let K=this.glContext.gl,W=0;for(let{name:U,type:Z,location:q,arrayLength:G}of Q){let J=H.find((X)=>X.name===U)?.data;if(Z!=="sampler2D"&&!J)throw new Error(`variable '${U}' does not have data defined in program info`);switch(Z){case"sampler2D":this.bindTexture(j[W],q,W),W++;break;case"float":G?K.uniform1fv(q,J):K.uniform1f(q,J);break;case"int":G?K.uniform1iv(q,J):K.uniform1i(q,J);break;default:throw new Error(`Uniform not implemented: ${Z}`)}}}bindTexture(Q,H,j){this.glContext.bindTextureToUniform(Q.texture,j,H)}getAttribLocations(Q){return{position:this.getAttribLocation(Q,"position"),textureCoord:this.getAttribLocation(Q,"textureCoord")}}getUniformLocations(Q,H,j){let K=[];if(H)for(let W of H)K.push({name:W,type:"sampler2D",location:this.getUniformLocation(Q,W)});if(j)for(let W of j)K.push({...W,location:this.getUniformLocation(Q,W.name)});return K}getUniformLocation(Q,H){let j=this.glContext.gl.getUniformLocation(Q,H);if(j===null)throw new Error(`Uniform ${H} not found.`);return j}getAttribLocation(Q,H){return this.glContext.gl.getAttribLocation(Q,H)}}}),SJ,jV=E(()=>{V3(),z5(),SJ=class{constructor(Q,H,j,K){this.glContext=Q,this.layoutStrategy=H,this.profiler=j,this.config=K,this.pendingRead=new Map,K.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(Q,H,j,K){let W=this.toEncoderType(Q),U=this.glContext.getEncoder(W,H.channels||1,K);if(H.isPacked&&K===1)throw new Error("not implemented");let{width:Z,height:q}=H,G,J;if(this.config.reuseTextures){G=`${Z}x${q}_${U.format}_${U.internalFormat}_${U.textureType}`,J=this.inUseTextures.get(G),J||(J=[],this.inUseTextures.set(G,J));let V=this.idleTextures.get(G);if(V&&V.length>0){let R=V.pop();return J.push(R),K===1&&this.glContext.updateTexture(R,Z,q,U,this.toTextureData(Q,j)),R}}C1.verbose("TextureManager",`Creating new texture of size ${H.width}x${H.height}`);let X=this.glContext.allocateTexture(Z,q,U,this.toTextureData(Q,j));return this.config.reuseTextures&&(J.push(X),this.textureLookup.set(X,G)),X}readTexture(Q,H,j){return j||(j=1),this.profiler.event("backend","TextureManager.readTexture",()=>{let K=Q.shape.reduce((U,Z)=>U*Z)*j,W=this.glContext.readTexture(Q.texture,Q.width,Q.height,K,this.toEncoderType(H),j);return this.toTensorData(H,W)})}async readTextureAsync(Q,H,j){let K=Q.tensor.dataId;if(j||(j=1),this.pendingRead.has(K)){let W=this.pendingRead.get(K);return new Promise((U)=>W?.push(U))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(K,[]);let W=Q.shape.reduce((G,J)=>G*J)*j;await this.glContext.createAndWaitForFence();let U=this.glContext.readTexture(Q.texture,Q.width,Q.height,W,this.toEncoderType(H),j),Z=this.toTensorData(H,U),q=this.pendingRead.get(K);return this.pendingRead.delete(K),q?.forEach((G)=>G(Z)),Z})}readUint8TextureAsFloat(Q){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{let H=Q.shape.reduce((K,W)=>K*W),j=this.glContext.readTexture(Q.texture,Q.width,Q.height,H*4,"byte",4);return new Float32Array(j.buffer,j.byteOffset,H)})}releaseTexture(Q,H){let j;if(this.config.reuseTextures&&(j=this.textureLookup.get(Q.texture),j)){H&&this.textureLookup.delete(j);let K=this.inUseTextures.get(j);if(K){let W=K.indexOf(Q.texture);if(W!==-1){K.splice(W,1);let U=this.idleTextures.get(j);U||(U=[],this.idleTextures.set(j,U)),U.push(Q.texture)}}}(!j||H)&&(C1.verbose("TextureManager",`Deleting texture of size ${Q.width}x${Q.height}`),this.glContext.deleteTexture(Q.texture))}toTensorData(Q,H){switch(Q){case"int16":return H instanceof Int16Array?H:Int16Array.from(H);case"int32":return H instanceof Int32Array?H:Int32Array.from(H);case"int8":return H instanceof Int8Array?H:Int8Array.from(H);case"uint16":return H instanceof Uint16Array?H:Uint16Array.from(H);case"uint32":return H instanceof Uint32Array?H:Uint32Array.from(H);case"uint8":case"bool":return H instanceof Uint8Array?H:Uint8Array.from(H);case"float32":return H instanceof Float32Array?H:Float32Array.from(H);case"float64":return H instanceof Float64Array?H:Float64Array.from(H);default:throw new Error(`TensorData type ${Q} is not supported`)}}toTextureData(Q,H){if(H)return H instanceof Float32Array?H:new Float32Array(H)}toEncoderType(Q){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}}),$J,VV=E(()=>{V3(),aZ(),Cj(),oj(),ZV(),NJ(),jV(),$J=class{constructor(Q,H){this.backend=Q,this.context=H,this.layoutStrategy=new zJ(Q.glContext.maxTextureSize),this.programManager=new AJ(this.context.profiler,Q.glContext,this.layoutStrategy),this.textureManager=new SJ(Q.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:Q.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=Q.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new K0(this)}onGraphInitialized(Q){let H=Q.getValues().filter((j)=>j.from===-1&&j.tensor).map((j)=>j.tensor.dataId);this.initializers=new Set(H)}isInitializer(Q){return this.initializers?this.initializers.has(Q):!1}addInitializer(Q){this.initializers.add(Q)}getTextureData(Q,H){return H?this.packedTextureDataCache.get(Q):this.unpackedTextureDataCache.get(Q)}setTextureData(Q,H,j=!1){C1.verbose("WebGLSessionHandler","Storing Texture data in cache"),j?this.packedTextureDataCache.set(Q,H):this.unpackedTextureDataCache.set(Q,H)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((Q)=>this.textureManager.releaseTexture(Q,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((Q)=>this.textureManager.releaseTexture(Q,!0)),this.unpackedTextureDataCache=new Map}resolve(Q,H,j){let K=AH(Q,H,GJ);return{impl:K.opImpl,context:K.opInit?K.opInit(Q,j):Q}}}}),f6,XV=E(()=>{z3(),z5(),z5(),F3(),f6=class{constructor(Q,H){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=Q,this.version=H,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(Q,H,j,K){let W=this.gl,U=W.createTexture();W.bindTexture(W.TEXTURE_2D,U),W.texParameteri(W.TEXTURE_2D,W.TEXTURE_MIN_FILTER,W.NEAREST),W.texParameteri(W.TEXTURE_2D,W.TEXTURE_MAG_FILTER,W.NEAREST),W.texParameteri(W.TEXTURE_2D,W.TEXTURE_WRAP_S,W.CLAMP_TO_EDGE),W.texParameteri(W.TEXTURE_2D,W.TEXTURE_WRAP_T,W.CLAMP_TO_EDGE);let Z=K?j.encode(K,Q*H):null;return W.texImage2D(W.TEXTURE_2D,0,j.internalFormat,Q,H,0,j.format,j.textureType,Z),this.checkError(),U}updateTexture(Q,H,j,K,W){let U=this.gl;U.bindTexture(U.TEXTURE_2D,Q);let Z=K.encode(W,H*j);U.texSubImage2D(U.TEXTURE_2D,0,0,0,H,j,K.format,K.textureType,Z),this.checkError()}attachFramebuffer(Q,H,j){let K=this.gl;K.bindTexture(K.TEXTURE_2D,Q),K.bindFramebuffer(K.FRAMEBUFFER,this.framebuffer),K.framebufferTexture2D(K.FRAMEBUFFER,K.COLOR_ATTACHMENT0,K.TEXTURE_2D,Q,0),this.checkError(),K.viewport(0,0,H,j),K.scissor(0,0,H,j)}readTexture(Q,H,j,K,W,U){let Z=this.gl;U||(U=1),this.frameBufferBound||this.attachFramebuffer(Q,H,j);let q=this.getEncoder(W,U),G=q.allocate(H*j);return Z.bindTexture(Z.TEXTURE_2D,Q),Z.framebufferTexture2D(Z.FRAMEBUFFER,Z.COLOR_ATTACHMENT0,Z.TEXTURE_2D,Q,0),Z.readPixels(0,0,H,j,Z.RGBA,q.textureType,G),this.checkError(),q.decode(G,K)}isFramebufferReady(){return!0}getActiveTexture(){let Q=this.gl;return`TEXTURE${Q.getParameter(this.gl.ACTIVE_TEXTURE)-Q.TEXTURE0}`}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(Q,H){let j=this.gl;j.vertexAttribPointer(Q,3,j.FLOAT,!1,20,0),j.enableVertexAttribArray(Q),H!==-1&&(j.vertexAttribPointer(H,2,j.FLOAT,!1,20,12),j.enableVertexAttribArray(H)),this.checkError()}createProgram(Q,H){let j=this.gl,K=j.createProgram();return j.attachShader(K,Q),j.attachShader(K,H),j.linkProgram(K),K}compileShader(Q,H){let j=this.gl,K=j.createShader(H);if(!K)throw new Error(`createShader() returned null with type ${H}`);if(j.shaderSource(K,Q),j.compileShader(K),j.getShaderParameter(K,j.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${j.getShaderInfoLog(K)}
Shader source:
${Q}`);return K}deleteShader(Q){this.gl.deleteShader(Q)}bindTextureToUniform(Q,H,j){let K=this.gl;K.activeTexture(K.TEXTURE0+H),this.checkError(),K.bindTexture(K.TEXTURE_2D,Q),this.checkError(),K.uniform1i(j,H),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(i.debug){let Q=this.gl,H=Q.getError(),j="";switch(H){case Q.NO_ERROR:return;case Q.INVALID_ENUM:j="INVALID_ENUM";break;case Q.INVALID_VALUE:j="INVALID_VALUE";break;case Q.INVALID_OPERATION:j="INVALID_OPERATION";break;case Q.INVALID_FRAMEBUFFER_OPERATION:j="INVALID_FRAMEBUFFER_OPERATION";break;case Q.OUT_OF_MEMORY:j="OUT_OF_MEMORY";break;case Q.CONTEXT_LOST_WEBGL:j="CONTEXT_LOST_WEBGL";break;default:j=`Unknown WebGL Error: ${H.toString(16)}`}throw new Error(j)}}deleteTexture(Q){this.gl.deleteTexture(Q)}deleteProgram(Q){this.gl.deleteProgram(Q)}getEncoder(Q,H,j=0){if(this.version===2)return new j0(this.gl,H);switch(Q){case"float":return j===1||this.isRenderFloat32Supported?new w6(this.gl,H):new w6(this.gl,H,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new V0(this.gl,H);default:throw new Error(`Invalid dataType: ${Q}`)}}clearActiveTextures(){let Q=this.gl;for(let H=0;H<this.maxTextureImageUnits;++H)Q.activeTexture(Q.TEXTURE0+H),Q.bindTexture(Q.TEXTURE_2D,null)}dispose(){if(this.disposed)return;let Q=this.gl;Q.bindFramebuffer(Q.FRAMEBUFFER,null),Q.deleteFramebuffer(this.framebuffer),Q.bindBuffer(Q.ARRAY_BUFFER,null),Q.deleteBuffer(this.vertexbuffer),Q.bindBuffer(Q.ELEMENT_ARRAY_BUFFER,null),Q.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){let Q=this.gl,H=Q.createBuffer();if(!H)throw new Error("createBuffer() returned null");let j=this.createDefaultGeometry();return Q.bindBuffer(Q.ARRAY_BUFFER,H),Q.bufferData(Q.ARRAY_BUFFER,j,Q.STATIC_DRAW),this.checkError(),H}createFramebuffer(){let Q=this.gl.createFramebuffer();if(!Q)throw new Error("createFramebuffer returned null");return Q}queryVitalParameters(){let Q=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=Q.getParameter(Q.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=Q.getParameter(Q.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){let Q=this.gl,H=Q.createTexture();Q.bindTexture(Q.TEXTURE_2D,H);let j=this.version===2?Q.RGBA32F:Q.RGBA;Q.texImage2D(Q.TEXTURE_2D,0,j,1,1,0,Q.RGBA,Q.FLOAT,null);let K=Q.createFramebuffer();Q.bindFramebuffer(Q.FRAMEBUFFER,K),Q.framebufferTexture2D(Q.FRAMEBUFFER,Q.COLOR_ATTACHMENT0,Q.TEXTURE_2D,H,0);let W=Q.checkFramebufferStatus(Q.FRAMEBUFFER)===Q.FRAMEBUFFER_COMPLETE;return Q.bindTexture(Q.TEXTURE_2D,null),Q.bindFramebuffer(Q.FRAMEBUFFER,null),Q.deleteTexture(H),Q.deleteFramebuffer(K),W}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){let Q=this.gl,H,j,K,W,U;try{H=Q.createTexture(),j=Q.createFramebuffer(),Q.bindTexture(Q.TEXTURE_2D,H);let Z=this.version===2?Q.RGBA32F:Q.RGBA;return Q.texImage2D(Q.TEXTURE_2D,0,Z,1,1,0,Q.RGBA,Q.FLOAT,null),Q.bindFramebuffer(Q.FRAMEBUFFER,j),Q.framebufferTexture2D(Q.FRAMEBUFFER,Q.COLOR_ATTACHMENT0,Q.TEXTURE_2D,H,0),Q.enable(Q.BLEND),K=Q.createShader(Q.VERTEX_SHADER),!K||(Q.shaderSource(K,"void main(){}"),Q.compileShader(K),W=Q.createShader(Q.FRAGMENT_SHADER),!W)||(Q.shaderSource(W,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),Q.compileShader(W),U=Q.createProgram(),!U)?!1:(Q.attachShader(U,K),Q.attachShader(U,W),Q.linkProgram(U),Q.useProgram(U),Q.drawArrays(Q.POINTS,0,1),Q.getError()===Q.NO_ERROR)}finally{Q.disable(Q.BLEND),U&&Q.deleteProgram(U),K&&Q.deleteShader(K),W&&Q.deleteShader(W),j&&(Q.bindFramebuffer(Q.FRAMEBUFFER,null),Q.deleteFramebuffer(j)),H&&(Q.bindTexture(Q.TEXTURE_2D,null),Q.deleteTexture(H))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let Q=this.gl,H=this.disjointTimerQueryWebgl2Extension,j=Q.createQuery();return Q.beginQuery(H.TIME_ELAPSED_EXT,j),j}else throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let Q=this.gl,H=this.disjointTimerQueryWebgl2Extension;Q.endQuery(H.TIME_ELAPSED_EXT);return}else throw new Error("WebGL1 profiling currently not supported")}isTimerResultAvailable(Q){let H=!1,j=!1;if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let K=this.gl,W=this.disjointTimerQueryWebgl2Extension;H=K.getQueryParameter(Q,K.QUERY_RESULT_AVAILABLE),j=K.getParameter(W.GPU_DISJOINT_EXT)}else throw new Error("WebGL1 profiling currently not supported");return H&&!j}getTimerResult(Q){let H=0;if(this.version===2){let j=this.gl;H=j.getQueryParameter(Q,j.QUERY_RESULT),j.deleteQuery(Q)}else throw new Error("WebGL1 profiling currently not supported");return H/1e6}async waitForQueryAndGetTime(Q){return await u7(()=>this.isTimerResultAvailable(Q)),this.getTimerResult(Q)}async createAndWaitForFence(){let Q=this.createFence(this.gl);return this.pollFence(Q)}createFence(Q){let H,j=Q,K=j.fenceSync(j.SYNC_GPU_COMMANDS_COMPLETE,0);return Q.flush(),K===null?H=()=>!0:H=()=>{let W=j.clientWaitSync(K,0,0);return W===j.ALREADY_SIGNALED||W===j.CONDITION_SATISFIED},{query:K,isFencePassed:H}}async pollFence(Q){return new Promise((H)=>{this.addItemToPoll(()=>Q.isFencePassed(),()=>H())})}pollItems(){let Q=LZ(this.itemsToPoll.map((H)=>H.isDoneFn));for(let H=0;H<=Q;++H){let{resolveFn:j}=this.itemsToPoll[H];j()}this.itemsToPoll=this.itemsToPoll.slice(Q+1)}async addItemToPoll(Q,H){this.itemsToPoll.push({isDoneFn:Q,resolveFn:H}),!(this.itemsToPoll.length>1)&&await u7(()=>(this.pollItems(),this.itemsToPoll.length===0))}}}),u3,KV=E(()=>{V3(),XV(),u3={}}),LJ,UV=E(()=>{z3(),V3(),VV(),KV(),LJ=class{get contextId(){return i.webgl.contextId}set contextId(Q){i.webgl.contextId=Q}get matmulMaxBatchSize(){return i.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(Q){i.webgl.matmulMaxBatchSize=Q}get textureCacheMode(){return i.webgl.textureCacheMode}set textureCacheMode(Q){i.webgl.textureCacheMode=Q}get pack(){return i.webgl.pack}set pack(Q){i.webgl.pack=Q}get async(){return i.webgl.async}set async(Q){i.webgl.async=Q}initialize(){try{return this.glContext=T2(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),C1.setWithEnv(i),i.webgl.context||Object.defineProperty(i.webgl,"context",{value:this.glContext.gl}),C1.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(Q){return C1.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${Q}`),!1}}createSessionHandler(Q){return new $J(this,Q)}dispose(){this.glContext.dispose()}}}),U7,vJ,qV=E(()=>{UV(),U7=new Map,vJ={webgl:new LJ}}),H2,wJ,WV=E(()=>{V3(),H2=class{constructor(Q,H){this.op=Q,this.node=H}},wJ=class{constructor(Q,H,j){this.graph=Q,this.profiler=j,this.initialize(H)}initialize(Q){this.profiler.event("session","ExecutionPlan.initialize",()=>{let H=this.graph.getNodes();if(H.length!==Q.length)throw new Error("The size of nodes and OPs do not match.");this._ops=Q.map((j,K)=>new H2(j,H[K])),this.reset(),this._starter=[],this._ops.forEach((j,K)=>{let W=!0;for(let U of j.node.inputs)if(!this._values[U]&&this.graph.getInputIndices().indexOf(U)===-1){W=!1;break}W&&this._starter.push(K)})})}reset(){this._values=this.graph.getValues().map((Q)=>Q.tensor)}async execute(Q,H){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();let j=Q.createInferenceHandler(),K=this.graph.getInputIndices();if(H.length!==K.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${H.length} expected: ${K.length}`);H.forEach((J,X)=>{let V=K[X];this._values[V]=J});let W=this._starter.slice(0),U=this.graph.getValues(),Z=this.graph.getNodes(),q=0;for(;q<W.length;){let J=W[q++],X=this._ops[J],V=X.node.inputs.map((B)=>this._values[B]);if(V.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${X.node}`);let R=V;C1.verbose("ExecPlan",`Runing op:${X.node.name} (${R.map((B,k)=>`'${X.node.inputs[k]}': ${B.type}[${B.dims.join(",")}]`).join(", ")})`);let z=await this.profiler.event("node",X.node.name,async()=>X.op.impl(j,R,X.op.context));if(z.length!==X.node.outputs.length)throw new Error("the size of output does not match model definition.");z.forEach((B,k)=>{let w=X.node.outputs[k];if(this._values[w])throw new Error(`output [${w}] already has value: op:${X.node.name}`);this._values[w]=B});let Y=new Set;z.forEach((B,k)=>{let w=X.node.outputs[k];for(let A of U[w].to){let D=Z[A],I=!0;for(let h of D.inputs)if(!this._values[h]){I=!1;break}I&&Y.add(A)}}),W.push(...Y)}let G=[];for(let J=0;J<this.graph.getOutputIndices().length;J++){let X=this.graph.getOutputIndices()[J],V=this._values[X];if(V===void 0)throw new Error(`required output [${X}] does not have value`);X===0?await V.getData():V.data,G.push(V)}return C1.verbose("ExecPlan","disposing of inferenceHandler"),j.dispose(),G})}}}),n,s1,l6,GV=E(()=>{B5(),n=Z4(l4()),K4(),Q1(),s1=H1.experimental.fbs,l6=class Q{constructor(H){if(this._attributes=new Map,H!=null){for(let j of H)j instanceof n.onnx.AttributeProto?this._attributes.set(j.name,[Q.getValue(j),Q.getType(j)]):j instanceof s1.Attribute&&this._attributes.set(j.name(),[Q.getValue(j),Q.getType(j)]);if(this._attributes.size<H.length)throw new Error("duplicated attribute names")}}set(H,j,K){this._attributes.set(H,[K,j])}delete(H){this._attributes.delete(H)}getFloat(H,j){return this.get(H,"float",j)}getInt(H,j){return this.get(H,"int",j)}getString(H,j){return this.get(H,"string",j)}getTensor(H,j){return this.get(H,"tensor",j)}getFloats(H,j){return this.get(H,"floats",j)}getInts(H,j){return this.get(H,"ints",j)}getStrings(H,j){return this.get(H,"strings",j)}getTensors(H,j){return this.get(H,"tensors",j)}get(H,j,K){let W=this._attributes.get(H);if(W===void 0){if(K!==void 0)return K;throw new Error(`required attribute not found: ${H}`)}if(W[1]!==j)throw new Error(`type mismatch: expected ${j} but got ${W[1]}`);return W[0]}static getType(H){let j=H instanceof n.onnx.AttributeProto?H.type:H.type();switch(j){case n.onnx.AttributeProto.AttributeType.FLOAT:return"float";case n.onnx.AttributeProto.AttributeType.INT:return"int";case n.onnx.AttributeProto.AttributeType.STRING:return"string";case n.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case n.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case n.onnx.AttributeProto.AttributeType.INTS:return"ints";case n.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case n.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${n.onnx.AttributeProto.AttributeType[j]}`)}}static getValue(H){let j=H instanceof n.onnx.AttributeProto?H.type:H.type();if(j===n.onnx.AttributeProto.AttributeType.GRAPH||j===n.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");let K=this.getValueNoCheck(H);if(j===n.onnx.AttributeProto.AttributeType.INT&&G3.isLong(K))return G3.longToNumber(K);if(j===n.onnx.AttributeProto.AttributeType.INTS){let W=K,U=new Array(W.length);for(let Z=0;Z<W.length;Z++){let q=W[Z];U[Z]=G3.longToNumber(q)}return U}if(j===n.onnx.AttributeProto.AttributeType.TENSOR)return H instanceof n.onnx.AttributeProto?o1.fromProto(K):o1.fromOrtTensor(K);if(j===n.onnx.AttributeProto.AttributeType.TENSORS){if(H instanceof n.onnx.AttributeProto)return K.map((W)=>o1.fromProto(W));if(H instanceof s1.Attribute)return K.map((W)=>o1.fromOrtTensor(W))}return j===n.onnx.AttributeProto.AttributeType.STRING&&H instanceof n.onnx.AttributeProto?N6(K):j===n.onnx.AttributeProto.AttributeType.STRINGS&&H instanceof n.onnx.AttributeProto?K.map(N6):K}static getValueNoCheck(H){return H instanceof n.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(H):this.getValueNoCheckFromOrtFormat(H)}static getValueNoCheckFromOnnxFormat(H){switch(H.type){case n.onnx.AttributeProto.AttributeType.FLOAT:return H.f;case n.onnx.AttributeProto.AttributeType.INT:return H.i;case n.onnx.AttributeProto.AttributeType.STRING:return H.s;case n.onnx.AttributeProto.AttributeType.TENSOR:return H.t;case n.onnx.AttributeProto.AttributeType.GRAPH:return H.g;case n.onnx.AttributeProto.AttributeType.FLOATS:return H.floats;case n.onnx.AttributeProto.AttributeType.INTS:return H.ints;case n.onnx.AttributeProto.AttributeType.STRINGS:return H.strings;case n.onnx.AttributeProto.AttributeType.TENSORS:return H.tensors;case n.onnx.AttributeProto.AttributeType.GRAPHS:return H.graphs;default:throw new Error(`unsupported attribute type: ${n.onnx.AttributeProto.AttributeType[H.type]}`)}}static getValueNoCheckFromOrtFormat(H){switch(H.type()){case s1.AttributeType.FLOAT:return H.f();case s1.AttributeType.INT:return H.i();case s1.AttributeType.STRING:return H.s();case s1.AttributeType.TENSOR:return H.t();case s1.AttributeType.GRAPH:return H.g();case s1.AttributeType.FLOATS:return H.floatsArray();case s1.AttributeType.INTS:{let j=[];for(let K=0;K<H.intsLength();K++)j.push(H.ints(K));return j}case s1.AttributeType.STRINGS:{let j=[];for(let K=0;K<H.stringsLength();K++)j.push(H.strings(K));return j}case s1.AttributeType.TENSORS:{let j=[];for(let K=0;K<H.tensorsLength();K++)j.push(H.tensors(K));return j}default:throw new Error(`unsupported attribute type: ${s1.AttributeType[H.type()]}`)}}}}),K6,w4,u6,B3,U6,Z2,RV=E(()=>{GV(),B5(),K6=Z4(l4()),K4(),Q1(),w4=H1.experimental.fbs,u6={from:(Q,H)=>new Z2(Q,H)},B3=class{constructor(Q){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,Q&&(this.type=i1.tensorValueTypeFromProto(Q.type.tensorType))}get from(){return this._from}get to(){return this._to}},U6=class{constructor(Q,H){Q instanceof K6.onnx.NodeProto?(this.name=Q.name,this.opType=Q.opType,this.attributes=new l6(Q.attribute)):Q instanceof w4.Node&&(this.name=H??Q.name(),this.opType=Q.opType(),this.attributes=new l6(i1.tensorAttributesFromORTFormat(Q))),this.inputs=[],this.outputs=[],this.executeNode=!0}},Z2=class{constructor(Q,H){if(!Q)throw new TypeError("graph is empty");this.buildGraph(Q),this.transformGraph(H),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(Q){if(Q instanceof K6.onnx.GraphProto)this.buildGraphFromOnnxFormat(Q);else if(Q instanceof w4.Graph)this.buildGraphFromOrtFormat(Q);else throw new TypeError("Graph type is not supported.")}buildGraphFromOnnxFormat(Q){let H=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let j=new Map;if(!Q.input)throw new Error("missing information in graph: input");let K=[];for(let W of Q.input){if(H.has(W.name))throw new Error(`duplicated input name: ${W.name}`);let U=this._allData.push(new B3(W))-1;H.set(W.name,U),K.push(W.name)}if(!Q.initializer)throw new Error("missing information in graph: initializer");for(let W of Q.initializer){let U=H.get(W.name);if(U===void 0){let Z=new B3;Z.type={shape:{dims:i1.tensorDimsFromProto(W.dims)},tensorType:i1.tensorDataTypeFromProto(W.dataType)},U=this._allData.push(Z)-1,H.set(W.name,U)}this._allData[U]._from=-1,this._allData[U].tensor=o1.fromProto(W)}for(let W=0;W<this._allData.length;W++)this._allData[W].tensor||(this._allInputIndices.push(W),this._allInputNames.push(K[W]));if(!Q.output)throw new Error("missing information in graph: output");for(let W of Q.output){if(H.has(W.name))throw new Error(`duplicated output name: ${W.name}`);let U=this._allData.push(new B3(W))-1;H.set(W.name,U),this._allOutputIndices.push(U),this._allOutputNames.push(W.name)}if(!Q.node)throw new Error("missing information in graph: node");for(let W of Q.node){if(!W.name)for(let Z=0;;Z++){let q=`unnamed_${W.opType}_${Z}`;if(!j.has(q)){W.name=q;break}}if(j.has(W.name))throw new Error(`duplicated node name: ${W.name}`);let U=this._nodes.push(new U6(W))-1;j.set(W.name,U)}for(let W=0;W<this._nodes.length;W++){let U=this._nodes[W],Z=Q.node[W];if(!Z.output)throw new Error(`missing output for node: ${Z.name}`);for(let q of Z.output){let G=H.get(q);if(typeof G>"u"&&(G=this._allData.push(new B3)-1,H.set(q,G)),U.outputs.push(G),this._allData[G]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${G}`);if(this._allData[G]._from=W,Z.opType==="Constant"){if(!Z.attribute||Z.attribute.length!==1||!Z.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!Z.output||Z.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");U.outputs.pop(),U.executeNode=!1,this._allData[G]._from=-1,this._allData[G].tensor=o1.fromProto(Z.attribute[0].t)}}}for(let W=0;W<this._nodes.length;W++){let U=this._nodes[W],Z=Q.node[W];if(!Z.input)throw new Error(`missing input for node: ${Z.name}`);for(let q of Z.input){let G=H.get(q);if(typeof G>"u"){if(q===""&&(Z.input.length===3||Z.input.length===4)&&Z.opType==="Resize")continue;throw new Error(`unrecognized input '${q}' for node: ${Z.name}`)}U.inputs.push(G),this._allData[G]._to.push(W)}}return!0}buildGraphFromOrtFormat(Q){let H=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let j=new Map,K=[];for(let W=0;W<Q.inputsLength();W++){let U=Q.inputs(W);if(H.has(U))throw new Error(`duplicated input name: ${U}`);for(let Z=0;Z<Q.nodeArgsLength();Z++)if(Q.nodeArgs(Z)?.name()===U){let q=new B3;if(Q.nodeArgs(Z)?.type()?.valueType()!==w4.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");let G=Q.nodeArgs(Z).type().value(new w4.TensorTypeAndShape),J=i1.tensorDataTypeFromProto(G.elemType()),X=G.shape(),V=[];for(let z=0;z<X.dimLength();z++)V.push(G3.longToNumber(X.dim(z).value().dimValue()));q.type={shape:{dims:V},tensorType:J};let R=this._allData.push(q)-1;H.set(U,R),K.push(U)}}for(let W=0;W<Q.initializersLength();W++){let U=Q.initializers(W),Z=H.get(U.name());if(Z===void 0){let q=new B3,G=i1.tensorDimsFromORTFormat(U),J=i1.tensorDataTypeFromProto(U.dataType());q.type={shape:{dims:G},tensorType:J},Z=this._allData.push(q)-1,H.set(U.name(),Z)}this._allData[Z]._from=-1,this._allData[Z].tensor=o1.fromOrtTensor(U)}for(let W=0;W<this._allData.length;W++)this._allData[W].tensor||(this._allInputIndices.push(W),this._allInputNames.push(K[W]));for(let W=0;W<Q.outputsLength();W++){let U=Q.outputs(W);if(H.has(U))throw new Error(`duplicated output name: ${U}`);let Z=this._allData.push(new B3)-1;H.set(U,Z),this._allOutputIndices.push(Z),this._allOutputNames.push(U)}if(!Q.nodes)throw new Error("missing information in graph: node");for(let W=0;W<Q.nodesLength();W++){let U=Q.nodes(W),Z=U.name();if(!Z)for(let G=0;Z=`unnamed_${U.opType()}_${G}`,!!j.has(Z);G++);if(j.has(Z))throw new Error(`duplicated node name: ${Z}`);let q=this._nodes.push(new U6(U,Z))-1;j.set(Z,q)}for(let W=0;W<this._nodes.length;W++){let U=this._nodes[W],Z=Q.nodes(W);if(Z==null)throw new Error(`No node exists at index ${W}`);if(Z?.outputsLength()===0)throw new Error(`missing output for node: ${Z.name}`);for(let q=0;q<Z?.outputsLength();q++){let G=Z?.outputs(q),J=H.get(G);if(typeof J>"u"&&(J=this._allData.push(new B3)-1,H.set(G,J)),U.outputs.push(J),this._allData[J]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${J}`);if(this._allData[J]._from=W,Z.opType()==="Constant"){if(Z.attributesLength()!==1||!Z.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(Z.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");U.outputs.pop(),U.executeNode=!1,this._allData[J]._from=-1,this._allData[J].tensor=o1.fromOrtTensor(Z.attributes(0).t())}}}for(let W=0;W<this._nodes.length;W++){let U=this._nodes[W],Z=Q.nodes(W);if(Z.inputsLength()===0)throw new Error(`missing input for node: ${Z.name}`);for(let q=0;q<Z.inputsLength();q++){let G=Z.inputs(q),J=H.get(G);if(typeof J>"u")throw new Error(`unrecognized input '${G}' for node: ${Z.name()}`);U.inputs.push(J),this._allData[J]._to.push(W)}}}checkIsAcyclic(){let Q=new Set;this._allInputIndices.forEach((K)=>{this._allData[K]._to.forEach((W)=>{Q.add(W)})});let H=Array.from(Q),j=new Array(this._nodes.length).fill("white");for(;H.length>0;){let K=H.pop();j[K]==="gray"?j[K]="black":(H.push(K),j[K]="gray",this._nodes[K].outputs.forEach((W)=>{let U=this._allData[W];if(typeof U.tensor<"u")throw new Error("node outputs should not be initialized");if(U._from!==K)throw new Error("from property of the Value object doesn't match index of Node being processed");U._to.forEach((Z)=>{if(j[Z]==="gray")throw new Error("model graph is cyclic");j[Z]==="white"&&H.push(Z)})}))}}transformGraph(Q){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),Q&&Q.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let Q=0,H=new Array(this._nodes.length,0),j=0;for(let K=0;K<this._nodes.length;K++)H[K]=j,this._nodes[K].executeNode?(j!==K&&(this._nodes[j]=this._nodes[K]),j++):this._nodes[K].outputs.forEach((W)=>{this._allData[W]._from=-2});this._nodes.splice(j,this._nodes.length-j);for(let K=0;K<this._allData.length;K++){let W=this._allData[K];W._from!==void 0&&W._from!==-1&&W._from!==-2&&(W._from=H[W._from]);for(let U=0;U<W._to.length;U++)if(W._to[U]>=0)W._to[U]=H[W._to[U]];else throw new Error("Trying to update a removed node")}Q=0;for(let K=0;K<this._allData.length;K++){if(this._allData[K].from===-2&&this._allOutputIndices.indexOf(K+Q)===-1){Q++,this._allData.splice(K,1),K--;continue}if(Q>0){let W=-1;this._allData[K].from!==void 0&&this._allData[K].from!==-1?(W=this._nodes[this._allData[K].from].outputs.indexOf(K+Q),W!==-1&&(this._nodes[this._allData[K].from].outputs[W]=K)):(W=this._allInputIndices.indexOf(K+Q),W!==-1&&(this._allInputIndices[W]=K)),this._allData[K].to.forEach((U)=>{W=this._nodes[U].inputs.indexOf(K+Q),W!==-1&&(this._nodes[U].inputs[W]=K)}),this._allData[K].to.length===0&&(W=this._allOutputIndices.indexOf(K+Q),W!==-1&&(this._allOutputIndices[W]=K))}}}deleteNode(Q){let H=this._nodes[Q];if(H.outputs.length>1){for(let Z=1;Z<H.outputs.length;Z++)if(this._allData[H.outputs[Z]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}H.executeNode=!1;let j=H.inputs[0],K=H.outputs[0],W=this._allData[K].to;for(let Z=0;Z<H.inputs.length;Z++){let q=this._allData[H.inputs[Z]].to.indexOf(Q);if(q===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[H.inputs[Z]].to.splice(q,1)}this._allData[K]._to=[];let U=this._allOutputIndices.indexOf(K);if(U!==-1&&(this._allOutputIndices[U]=j),W&&W.length>0)for(let Z of W){let q=this._nodes[Z].inputs.indexOf(K);if(q===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[Z].inputs[q]=j,this._allData[j].to.push(Z)}}removeAllDropoutNodes(){let Q=0;for(let H of this._nodes){if(H.opType==="Dropout"){if(H.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(H.outputs.length!==1&&H.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(H.outputs.length===2&&this._allData[H.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(Q)}Q++}}removeAllIdentityNodes(){let Q=0;for(let H of this._nodes)H.opType==="Identity"&&this.deleteNode(Q),Q++}isActivation(Q){switch(Q.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(let Q of this._nodes)if(Q.opType==="Conv"){let H=this._allData[Q.outputs[0]]._to;if(H.length===1&&this.isActivation(this._nodes[H[0]])){let j=this._nodes[H[0]];if(j.opType==="Clip")if(j.inputs.length===1)try{Q.attributes.set("activation_params","floats",[j.attributes.getFloat("min"),j.attributes.getFloat("max")])}catch{Q.attributes.set("activation_params","floats",[h4,b4])}else if(j.inputs.length>=3&&this._allData[j.inputs[1]].tensor!==void 0&&this._allData[j.inputs[2]].tensor!==void 0)Q.attributes.set("activation_params","floats",[this._allData[j.inputs[1]].tensor.floatData[0],this._allData[j.inputs[2]].tensor.floatData[0]]);else continue;Q.attributes.set("activation","string",j.opType),this.deleteNode(H[0])}}}}}),j2,V2,TJ,zV=E(()=>{H7(),RV(),B5(),j2=Z4(l4()),Q1(),V2=H1.experimental.fbs,TJ=class{constructor(){}load(Q,H,j){let K;if(!j)try{this.loadFromOnnxFormat(Q,H);return}catch(W){if(j!==void 0)throw W;K=W}try{this.loadFromOrtFormat(Q,H)}catch(W){throw j!==void 0?W:new Error(`Failed to load model as ONNX format: ${K}
as ORT format: ${W}`)}}loadFromOnnxFormat(Q,H){let j=j2.onnx.ModelProto.decode(Q);if(G3.longToNumber(j.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=j.opsetImport.map((K)=>({domain:K.domain,version:G3.longToNumber(K.version)})),this._graph=u6.from(j.graph,H)}loadFromOrtFormat(Q,H){let j=new $.ByteBuffer(Q),K=V2.InferenceSession.getRootAsInferenceSession(j).model();if(G3.longToNumber(K.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let W=0;W<K.opsetImportLength();W++){let U=K.opsetImport(W);this._opsets.push({domain:U?.domain(),version:G3.longToNumber(U.version())})}this._graph=u6.from(K.graph(),H)}get graph(){return this._graph}get opsets(){return this._opsets}}}),DJ,NV=E(()=>{qV(),WV(),V3(),zV(),DJ=class{constructor(Q={}){this._initialized=!1,this.backendHint=Q.backendHint,this.profiler=o2.create(Q.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(Q,H,j){await this.profiler.event("session","Session.loadModel",async()=>{let K=await D2(this.backendHint);if(this.sessionHandler=K.createSessionHandler(this.context),this._model=new TJ,typeof Q=="string"){let W=Q.endsWith(".ort");if(typeof process<"u"&&process.versions&&process.versions.node){let U=await(void 0)(Q);this.initialize(U,W)}else{let U=await(await fetch(Q)).arrayBuffer();this.initialize(new Uint8Array(U),W)}}else if(ArrayBuffer.isView(Q))this.initialize(Q);else{let W=new Uint8Array(Q,H||0,j||Q.byteLength);this.initialize(W)}})}initialize(Q,H){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{let j=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(Q,j,H),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new wJ(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(Q){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{let H=this.normalizeAndValidateInputs(Q),j=await this._executionPlan.execute(this.sessionHandler,H);return this.createOutput(j)})}normalizeAndValidateInputs(Q){let H=this._model.graph.getInputNames();if(Array.isArray(Q)){if(Q.length!==H.length)throw new Error(`incorrect input array length: expected ${H.length} but got ${Q.length}`)}else{if(Q.size!==H.length)throw new Error(`incorrect input map size: expected ${H.length} but got ${Q.size}`);let j=new Array(Q.size),K=0;for(let W=0;W<H.length;++W){let U=Q.get(H[W]);if(!U)throw new Error(`missing input tensor for: '${name}'`);j[K++]=U}Q=j}if(!this.context.graphInputTypes||this.context.graphInputTypes.length===0||!this.context.graphInputDims||this.context.graphInputDims.length===0){let j=this._model.graph.getInputIndices(),K=this._model.graph.getValues(),W=new Array(j.length);for(let U=0;U<j.length;++U){let Z=K[j[U]];W[U]=Z.type.shape.dims,this.context.graphInputTypes.push(Z.type.tensorType),this.context.graphInputDims.push(Q[U].dims)}this.validateInputTensorDims(W,Q,!0)}else this.validateInputTensorDims(this.context.graphInputDims,Q,!1);return this.validateInputTensorTypes(this.context.graphInputTypes,Q),Q}validateInputTensorTypes(Q,H){for(let j=0;j<H.length;j++){let K=Q[j],W=H[j].type;if(K!==W)throw new Error(`input tensor[${j}] check failed: expected type '${K}' but got ${W}`)}}validateInputTensorDims(Q,H,j){for(let K=0;K<H.length;K++){let W=Q[K],U=H[K].dims;if(!this.compareTensorDims(W,U,j))throw new Error(`input tensor[${K}] check failed: expected shape '[${W.join(",")}]' but got [${U.join(",")}]`)}}compareTensorDims(Q,H,j){if(Q.length!==H.length)return!1;for(let K=0;K<Q.length;++K)if(Q[K]!==H[K]&&(!j||Q[K]!==0))return!1;return!0}createOutput(Q){let H=this._model.graph.getOutputNames();if(Q.length!==H.length)throw new Error("expected number of outputs do not match number of generated outputs");let j=new Map;for(let K=0;K<H.length;++K)j.set(H[K],Q[K]);return j}initializeOps(Q){let H=Q.getNodes();this._ops=new Array(H.length);for(let j=0;j<H.length;j++)this._ops[j]=this.sessionHandler.resolve(H[j],this._model.opsets,Q)}}}),_J,MV=E(()=>{z3(),K4(),_J=class{constructor(Q){this.session=Q,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(Q,H,j){let K=new Map;for(let Z in Q)if(Object.hasOwnProperty.call(Q,Z)){let q=Q[Z];K.set(Z,new o1(q.dims,q.type,void 0,void 0,q.data))}let W=await this.session.run(K),U={};return W.forEach((Z,q)=>{U[q]=new d1(Z.type,Z.data,Z.dims)}),U}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}}),PJ={};X4(PJ,{onnxjsBackend:()=>EJ});var X2,EJ,YV=E(()=>{NV(),MV(),X2=class{async init(){}async createInferenceSessionHandler(Q,H){let j=new DJ(H);return typeof Q=="string"?await j.loadModel(Q):await j.loadModel(Q),new _J(j)}},EJ=new X2}),q7={};X4(q7,{createReadStream:()=>OJ,readFile:()=>IJ,readFileSync:()=>xJ});var IJ,xJ,OJ,gJ=E(()=>{IJ=void 0,xJ=void 0,OJ=void 0}),W7={};X4(W7,{join:()=>yJ});var yJ,dJ=E(()=>{yJ=void 0}),CV=U1((Q,H)=>{var j=(()=>{var K=typeof document<"u"?document.currentScript?.src:void 0;return typeof G5<"u"&&(K||=G5),function(W={}){var U=W,Z,q,G=new Promise((M,S)=>{Z=M,q=S}),J=Object.assign({},U),X="./this.program",V=typeof window=="object",R=typeof importScripts=="function",z=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",Y="",B,k,w;if(z){var A=(gJ(),a3(q7)),D=(dJ(),a3(W7));Y=R?D.dirname(Y)+"/":r6+"/",B=(M,S)=>(M=O1(M)?new URL(M):D.normalize(M),A.readFileSync(M,S?void 0:"utf8")),w=(M)=>(M=B(M,!0),M.buffer||(M=new Uint8Array(M)),M),k=(M,S,L,P=!0)=>{M=O1(M)?new URL(M):D.normalize(M),A.readFile(M,P?void 0:"utf8",(d,m)=>{d?L(d):S(P?m.buffer:m)})},!U.thisProgram&&1<process.argv.length&&(X=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2)}else(V||R)&&(R?Y=self.location.href:typeof document<"u"&&document.currentScript&&(Y=document.currentScript.src),K&&(Y=K),Y.startsWith("blob:")?Y="":Y=Y.substr(0,Y.replace(/[?#].*/,"").lastIndexOf("/")+1),B=(M)=>{var S=new XMLHttpRequest;return S.open("GET",M,!1),S.send(null),S.responseText},R&&(w=(M)=>{var S=new XMLHttpRequest;return S.open("GET",M,!1),S.responseType="arraybuffer",S.send(null),new Uint8Array(S.response)}),k=(M,S,L)=>{var P=new XMLHttpRequest;P.open("GET",M,!0),P.responseType="arraybuffer",P.onload=()=>{P.status==200||P.status==0&&P.response?S(P.response):L()},P.onerror=L,P.send(null)});var I=console.log.bind(console),h=console.error.bind(console);Object.assign(U,J),J=null;var $1,L1=!1,x1,G1,p,S1,I3;function x3(){var M=$1.buffer;U.HEAP8=x1=new Int8Array(M),U.HEAP16=new Int16Array(M),U.HEAPU8=G1=new Uint8Array(M),U.HEAPU16=new Uint16Array(M),U.HEAP32=p=new Int32Array(M),U.HEAPU32=S1=new Uint32Array(M),U.HEAPF32=new Float32Array(M),U.HEAPF64=I3=new Float64Array(M)}var k3=[],R1=[],l=[],h1=0,X3=null,v1=null;function b1(M){throw M="Aborted("+M+")",h(M),L1=!0,M=new WebAssembly.RuntimeError(M+". Build with -sASSERTIONS for more info."),q(M),M}var P1=(M)=>M.startsWith("data:application/octet-stream;base64,"),O1=(M)=>M.startsWith("file://"),m1;if(m1="ort-wasm.wasm",!P1(m1)){var A3=m1;m1=U.locateFile?U.locateFile(A3,Y):Y+A3}function c1(M){if(w)return w(M);throw"both async and sync fetching of the wasm failed"}function r3(M){if(V||R){if(typeof fetch=="function"&&!O1(M))return fetch(M,{credentials:"same-origin"}).then((S)=>{if(!S.ok)throw`failed to load wasm binary file at '${M}'`;return S.arrayBuffer()}).catch(()=>c1(M));if(k)return new Promise((S,L)=>{k(M,(P)=>S(new Uint8Array(P)),L)})}return Promise.resolve().then(()=>c1(M))}function a1(M,S,L){return r3(M).then((P)=>WebAssembly.instantiate(P,S)).then(L,(P)=>{h(`failed to asynchronously prepare wasm: ${P}`),b1(P)})}function J3(M,S){var L=m1;return typeof WebAssembly.instantiateStreaming!="function"||P1(L)||O1(L)||z||typeof fetch!="function"?a1(L,M,S):fetch(L,{credentials:"same-origin"}).then((P)=>WebAssembly.instantiateStreaming(P,M).then(S,function(d){return h(`wasm streaming compile failed: ${d}`),h("falling back to ArrayBuffer instantiation"),a1(L,M,S)}))}var H3,z1={798088:(M,S,L,P)=>{if(typeof U>"u"||!U.ya)return 1;if(M=N3(M>>>0),M.startsWith("./")&&(M=M.substring(2)),M=U.ya.get(M),!M)return 2;if(S>>>=0,L>>>=0,S+L>M.byteLength)return 3;try{return G1.set(M.subarray(S,S+L),P>>>0>>>0),0}catch{return 4}}};class k1{constructor(M){this.wa=M-24}}var g1=0,O3=0,g3=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,G4=(M,S,L)=>{S>>>=0;var P=S+L;for(L=S;M[L]&&!(L>=P);)++L;if(16<L-S&&M.buffer&&g3)return g3.decode(M.subarray(S,L));for(P="";S<L;){var d=M[S++];if(d&128){var m=M[S++]&63;if((d&224)==192)P+=String.fromCharCode((d&31)<<6|m);else{var a=M[S++]&63;d=(d&240)==224?(d&15)<<12|m<<6|a:(d&7)<<18|m<<12|a<<6|M[S++]&63,65536>d?P+=String.fromCharCode(d):(d-=65536,P+=String.fromCharCode(55296|d>>10,56320|d&1023))}}else P+=String.fromCharCode(d)}return P},N3=(M,S)=>(M>>>=0)?G4(G1,M,S):"",S3=(M)=>{for(var S=0,L=0;L<M.length;++L){var P=M.charCodeAt(L);127>=P?S++:2047>=P?S+=2:55296<=P&&57343>=P?(S+=4,++L):S+=3}return S},M3=(M,S,L,P)=>{if(L>>>=0,!(0<P))return 0;var d=L;P=L+P-1;for(var m=0;m<M.length;++m){var a=M.charCodeAt(m);if(55296<=a&&57343>=a){var A1=M.charCodeAt(++m);a=65536+((a&1023)<<10)|A1&1023}if(127>=a){if(L>=P)break;S[L++>>>0]=a}else{if(2047>=a){if(L+1>=P)break;S[L++>>>0]=192|a>>6}else{if(65535>=a){if(L+2>=P)break;S[L++>>>0]=224|a>>12}else{if(L+3>=P)break;S[L++>>>0]=240|a>>18,S[L++>>>0]=128|a>>12&63}S[L++>>>0]=128|a>>6&63}S[L++>>>0]=128|a&63}}return S[L>>>0]=0,L-d},$3=(M)=>M%4===0&&(M%100!==0||M%400===0),R4=[0,31,60,91,121,152,182,213,244,274,305,335],i4=[0,31,59,90,120,151,181,212,243,273,304,334],K3=[],t3={},y3=()=>{if(!d3){var M={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:X||"./this.program"},S;for(S in t3)t3[S]===void 0?delete M[S]:M[S]=t3[S];var L=[];for(S in M)L.push(`${S}=${M[S]}`);d3=L}return d3},d3,o4=[null,[],[]],Y3=[31,29,31,30,31,30,31,31,30,31,30,31],a4=[31,28,31,30,31,30,31,31,30,31,30,31];function j1(M){var S=Array(S3(M)+1);return M3(M,S,0,S.length),S}function z4(M,S,L,P){function d(T,J1,q1){for(T=typeof T=="number"?T.toString():T||"";T.length<J1;)T=q1[0]+T;return T}function m(T,J1){return d(T,J1,"0")}function a(T,J1){function q1(B4){return 0>B4?-1:0<B4?1:0}var U3;return(U3=q1(T.getFullYear()-J1.getFullYear()))===0&&(U3=q1(T.getMonth()-J1.getMonth()))===0&&(U3=q1(T.getDate()-J1.getDate())),U3}function A1(T){switch(T.getDay()){case 0:return new Date(T.getFullYear()-1,11,29);case 1:return T;case 2:return new Date(T.getFullYear(),0,3);case 3:return new Date(T.getFullYear(),0,2);case 4:return new Date(T.getFullYear(),0,1);case 5:return new Date(T.getFullYear()-1,11,31);case 6:return new Date(T.getFullYear()-1,11,30)}}function f1(T){var J1=T.sa;for(T=new Date(new Date(T.ta+1900,0,1).getTime());0<J1;){var q1=T.getMonth(),U3=($3(T.getFullYear())?Y3:a4)[q1];if(J1>U3-T.getDate())J1-=U3-T.getDate()+1,T.setDate(1),11>q1?T.setMonth(q1+1):(T.setMonth(0),T.setFullYear(T.getFullYear()+1));else{T.setDate(T.getDate()+J1);break}}return q1=new Date(T.getFullYear()+1,0,4),J1=A1(new Date(T.getFullYear(),0,4)),q1=A1(q1),0>=a(J1,T)?0>=a(q1,T)?T.getFullYear()+1:T.getFullYear():T.getFullYear()-1}M>>>=0,S>>>=0,L>>>=0,P>>>=0;var T1=S1[P+40>>>2>>>0];P={Ba:p[P>>>2>>>0],Aa:p[P+4>>>2>>>0],ua:p[P+8>>>2>>>0],xa:p[P+12>>>2>>>0],va:p[P+16>>>2>>>0],ta:p[P+20>>>2>>>0],na:p[P+24>>>2>>>0],sa:p[P+28>>>2>>>0],Da:p[P+32>>>2>>>0],za:p[P+36>>>2>>>0],Ca:T1?N3(T1):""},L=N3(L),T1={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var D1 in T1)L=L.replace(new RegExp(D1,"g"),T1[D1]);var C4="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),L3="January February March April May June July August September October November December".split(" ");T1={"%a":(T)=>C4[T.na].substring(0,3),"%A":(T)=>C4[T.na],"%b":(T)=>L3[T.va].substring(0,3),"%B":(T)=>L3[T.va],"%C":(T)=>m((T.ta+1900)/100|0,2),"%d":(T)=>m(T.xa,2),"%e":(T)=>d(T.xa,2," "),"%g":(T)=>f1(T).toString().substring(2),"%G":f1,"%H":(T)=>m(T.ua,2),"%I":(T)=>(T=T.ua,T==0?T=12:12<T&&(T-=12),m(T,2)),"%j":(T)=>{for(var J1=0,q1=0;q1<=T.va-1;J1+=($3(T.ta+1900)?Y3:a4)[q1++]);return m(T.xa+J1,3)},"%m":(T)=>m(T.va+1,2),"%M":(T)=>m(T.Aa,2),"%n":()=>`
`,"%p":(T)=>0<=T.ua&&12>T.ua?"AM":"PM","%S":(T)=>m(T.Ba,2),"%t":()=>"	","%u":(T)=>T.na||7,"%U":(T)=>m(Math.floor((T.sa+7-T.na)/7),2),"%V":(T)=>{var J1=Math.floor((T.sa+7-(T.na+6)%7)/7);if(2>=(T.na+371-T.sa-2)%7&&J1++,J1)J1==53&&(q1=(T.na+371-T.sa)%7,q1==4||q1==3&&$3(T.ta)||(J1=1));else{J1=52;var q1=(T.na+7-T.sa-1)%7;(q1==4||q1==5&&$3(T.ta%400-1))&&J1++}return m(J1,2)},"%w":(T)=>T.na,"%W":(T)=>m(Math.floor((T.sa+7-(T.na+6)%7)/7),2),"%y":(T)=>(T.ta+1900).toString().substring(2),"%Y":(T)=>T.ta+1900,"%z":(T)=>{T=T.za;var J1=0<=T;return T=Math.abs(T)/60,(J1?"+":"-")+("0000"+(T/60*100+T%60)).slice(-4)},"%Z":(T)=>T.Ca,"%%":()=>"%"},L=L.replace(/%%/g,"\0\0");for(D1 in T1)L.includes(D1)&&(L=L.replace(new RegExp(D1,"g"),T1[D1](P)));return L=L.replace(/\0\0/g,"%"),D1=j1(L),D1.length>S?0:(x1.set(D1,M>>>0),D1.length-1)}var N4={a:function(M,S,L){M>>>=0;var P=new k1(M);throw S1[P.wa+16>>>2>>>0]=0,S1[P.wa+4>>>2>>>0]=S>>>0,S1[P.wa+8>>>2>>>0]=L>>>0,g1=M,O3++,g1},e:function(){return 0},H:function(){},x:function(){},z:function(){},J:function(){return 0},F:function(){},A:function(){},E:function(){},g:function(){},y:function(){},v:function(){},G:function(){},w:function(){},k:()=>1,I:function(M,S,L){return S>>>=0,G1.copyWithin(M>>>0>>>0,S>>>0,S+(L>>>0)>>>0)},n:function(M,S,L){M=S+2097152>>>0<4194305-!!M?(M>>>0)+4294967296*S:NaN,L>>>=0,M=new Date(1000*M),p[L>>>2>>>0]=M.getUTCSeconds(),p[L+4>>>2>>>0]=M.getUTCMinutes(),p[L+8>>>2>>>0]=M.getUTCHours(),p[L+12>>>2>>>0]=M.getUTCDate(),p[L+16>>>2>>>0]=M.getUTCMonth(),p[L+20>>>2>>>0]=M.getUTCFullYear()-1900,p[L+24>>>2>>>0]=M.getUTCDay(),p[L+28>>>2>>>0]=(M.getTime()-Date.UTC(M.getUTCFullYear(),0,1,0,0,0,0))/86400000|0},o:function(M,S,L){M=S+2097152>>>0<4194305-!!M?(M>>>0)+4294967296*S:NaN,L>>>=0,M=new Date(1000*M),p[L>>>2>>>0]=M.getSeconds(),p[L+4>>>2>>>0]=M.getMinutes(),p[L+8>>>2>>>0]=M.getHours(),p[L+12>>>2>>>0]=M.getDate(),p[L+16>>>2>>>0]=M.getMonth(),p[L+20>>>2>>>0]=M.getFullYear()-1900,p[L+24>>>2>>>0]=M.getDay(),p[L+28>>>2>>>0]=($3(M.getFullYear())?R4:i4)[M.getMonth()]+M.getDate()-1|0,p[L+36>>>2>>>0]=-(60*M.getTimezoneOffset()),S=new Date(M.getFullYear(),6,1).getTimezoneOffset();var P=new Date(M.getFullYear(),0,1).getTimezoneOffset();p[L+32>>>2>>>0]=(S!=P&&M.getTimezoneOffset()==Math.min(P,S))|0},p:function(M){M>>>=0;var S=new Date(p[M+20>>>2>>>0]+1900,p[M+16>>>2>>>0],p[M+12>>>2>>>0],p[M+8>>>2>>>0],p[M+4>>>2>>>0],p[M>>>2>>>0],0),L=p[M+32>>>2>>>0],P=S.getTimezoneOffset(),d=new Date(S.getFullYear(),6,1).getTimezoneOffset(),m=new Date(S.getFullYear(),0,1).getTimezoneOffset(),a=Math.min(m,d);return 0>L?p[M+32>>>2>>>0]=+(d!=m&&a==P):0<L!=(a==P)&&(d=Math.max(m,d),S.setTime(S.getTime()+60000*((0<L?a:d)-P))),p[M+24>>>2>>>0]=S.getDay(),p[M+28>>>2>>>0]=($3(S.getFullYear())?R4:i4)[S.getMonth()]+S.getDate()-1|0,p[M>>>2>>>0]=S.getSeconds(),p[M+4>>>2>>>0]=S.getMinutes(),p[M+8>>>2>>>0]=S.getHours(),p[M+12>>>2>>>0]=S.getDate(),p[M+16>>>2>>>0]=S.getMonth(),p[M+20>>>2>>>0]=S.getYear(),M=S.getTime(),M=isNaN(M)?-1:M/1000,M4((H3=M,1<=+Math.abs(H3)?0<H3?+Math.floor(H3/4294967296)>>>0:~~+Math.ceil((H3-+(~~H3>>>0))/4294967296)>>>0:0)),M>>>0},l:function(){return-52},m:function(){},t:function(M,S,L,P){L>>>=0,P>>>=0;var d=(new Date()).getFullYear(),m=new Date(d,0,1),a=new Date(d,6,1);d=m.getTimezoneOffset();var A1=a.getTimezoneOffset();S1[M>>>0>>>2>>>0]=60*Math.max(d,A1),p[S>>>0>>>2>>>0]=+(d!=A1),M=(f1)=>f1.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1],m=M(m),a=M(a),A1<d?(M3(m,G1,L,17),M3(a,G1,P,17)):(M3(m,G1,P,17),M3(a,G1,L,17))},d:()=>{b1("")},B:function(M,S,L){M>>>=0,S>>>=0,L>>>=0,K3.length=0;for(var P;P=G1[S++>>>0];){var d=P!=105;d&=P!=112,L+=d&&L%8?4:0,K3.push(P==112?S1[L>>>2>>>0]:P==105?p[L>>>2>>>0]:I3[L>>>3>>>0]),L+=d?8:4}return z1[M](...K3)},h:()=>Date.now(),u:function(){return 4294901760},b:()=>performance.now(),s:function(M){M>>>=0;var S=G1.length;if(4294901760<M)return!1;for(var L=1;4>=L;L*=2){var P=S*(1+0.2/L);P=Math.min(P,M+100663296);var d=Math;P=Math.max(M,P);Q:{d=(d.min.call(d,4294901760,P+(65536-P%65536)%65536)-$1.buffer.byteLength+65535)/65536;try{$1.grow(d),x3();var m=1;break Q}catch{}m=void 0}if(m)return!0}return!1},C:function(M,S){M>>>=0,S>>>=0;var L=0;return y3().forEach((P,d)=>{var m=S+L;for(d=S1[M+4*d>>>2>>>0]=m,m=0;m<P.length;++m)x1[d++>>>0]=P.charCodeAt(m);x1[d>>>0]=0,L+=P.length+1}),0},D:function(M,S){M>>>=0,S>>>=0;var L=y3();S1[M>>>2>>>0]=L.length;var P=0;return L.forEach((d)=>P+=d.length+1),S1[S>>>2>>>0]=P,0},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(M,S,L,P){S>>>=0,L>>>=0,P>>>=0;for(var d=0,m=0;m<L;m++){var a=S1[S>>>2>>>0],A1=S1[S+4>>>2>>>0];S+=8;for(var f1=0;f1<A1;f1++){var T1=G1[a+f1>>>0],D1=o4[M];T1===0||T1===10?((M===1?I:h)(G4(D1,0)),D1.length=0):D1.push(T1)}d+=A1}return S1[P>>>2>>>0]=d,0},r:z4,c:function(M,S,L,P){return z4(M>>>0,S>>>0,L>>>0,P>>>0)}},s=function(){function M(L){return s=L.exports,s=r4(),$1=s.K,x3(),R1.unshift(s.L),h1--,h1==0&&(X3!==null&&(clearInterval(X3),X3=null),v1&&(L=v1,v1=null,L())),s}var S={a:N4};if(h1++,U.instantiateWasm)try{return U.instantiateWasm(S,M)}catch(L){h(`Module.instantiateWasm callback failed with error: ${L}`),q(L)}return J3(S,function(L){M(L.instance)}).catch(q),{}}();U._OrtInit=(M,S)=>(U._OrtInit=s.M)(M,S),U._OrtGetLastError=(M,S)=>(U._OrtGetLastError=s.N)(M,S),U._OrtCreateSessionOptions=(M,S,L,P,d,m,a,A1,f1,T1)=>(U._OrtCreateSessionOptions=s.O)(M,S,L,P,d,m,a,A1,f1,T1),U._OrtAppendExecutionProvider=(M,S)=>(U._OrtAppendExecutionProvider=s.P)(M,S),U._OrtAddFreeDimensionOverride=(M,S,L)=>(U._OrtAddFreeDimensionOverride=s.Q)(M,S,L),U._OrtAddSessionConfigEntry=(M,S,L)=>(U._OrtAddSessionConfigEntry=s.R)(M,S,L),U._OrtReleaseSessionOptions=(M)=>(U._OrtReleaseSessionOptions=s.S)(M),U._OrtCreateSession=(M,S,L)=>(U._OrtCreateSession=s.T)(M,S,L),U._OrtReleaseSession=(M)=>(U._OrtReleaseSession=s.U)(M),U._OrtGetInputOutputCount=(M,S,L)=>(U._OrtGetInputOutputCount=s.V)(M,S,L),U._OrtGetInputName=(M,S)=>(U._OrtGetInputName=s.W)(M,S),U._OrtGetOutputName=(M,S)=>(U._OrtGetOutputName=s.X)(M,S),U._OrtFree=(M)=>(U._OrtFree=s.Y)(M),U._OrtCreateTensor=(M,S,L,P,d,m)=>(U._OrtCreateTensor=s.Z)(M,S,L,P,d,m),U._OrtGetTensorData=(M,S,L,P,d)=>(U._OrtGetTensorData=s._)(M,S,L,P,d),U._OrtReleaseTensor=(M)=>(U._OrtReleaseTensor=s.$)(M),U._OrtCreateRunOptions=(M,S,L,P)=>(U._OrtCreateRunOptions=s.aa)(M,S,L,P),U._OrtAddRunConfigEntry=(M,S,L)=>(U._OrtAddRunConfigEntry=s.ba)(M,S,L),U._OrtReleaseRunOptions=(M)=>(U._OrtReleaseRunOptions=s.ca)(M),U._OrtCreateBinding=(M)=>(U._OrtCreateBinding=s.da)(M),U._OrtBindInput=(M,S,L)=>(U._OrtBindInput=s.ea)(M,S,L),U._OrtBindOutput=(M,S,L,P)=>(U._OrtBindOutput=s.fa)(M,S,L,P),U._OrtClearBoundOutputs=(M)=>(U._OrtClearBoundOutputs=s.ga)(M),U._OrtReleaseBinding=(M)=>(U._OrtReleaseBinding=s.ha)(M),U._OrtRunWithBinding=(M,S,L,P,d)=>(U._OrtRunWithBinding=s.ia)(M,S,L,P,d),U._OrtRun=(M,S,L,P,d,m,a,A1)=>(U._OrtRun=s.ja)(M,S,L,P,d,m,a,A1),U._OrtEndProfiling=(M)=>(U._OrtEndProfiling=s.ka)(M),U._malloc=(M)=>(U._malloc=s.la)(M),U._free=(M)=>(U._free=s.ma)(M);var M4=(M)=>(M4=s.oa)(M),n4=(M)=>(n4=s.pa)(M),c=(M)=>(c=s.qa)(M),p3=()=>(p3=s.ra)();function r4(){var M=s;M=Object.assign({},M);var S=(L)=>(P)=>L(P)>>>0;return M.la=S(M.la),M.qa=S(M.qa),M.ra=((L)=>()=>L()>>>0)(M.ra),M}U.stackSave=()=>p3(),U.stackRestore=(M)=>n4(M),U.stackAlloc=(M)=>c(M),U.UTF8ToString=N3,U.stringToUTF8=(M,S,L)=>M3(M,G1,S,L),U.lengthBytesUTF8=S3;var C3;v1=function M(){C3||Y4(),C3||(v1=M)};function Y4(){if(!(0<h1)){if(U.preRun)for(typeof U.preRun=="function"&&(U.preRun=[U.preRun]);U.preRun.length;){var M=U.preRun.shift();k3.unshift(M)}for(;0<k3.length;)k3.shift()(U);if(!(0<h1||C3||(C3=!0,U.calledRun=!0,L1))){for(;0<R1.length;)R1.shift()(U);for(Z(U);0<l.length;)l.shift()(U)}}}return Y4(),G}})();typeof Q=="object"&&typeof H=="object"?H.exports=j:typeof define=="function"&&define.amd&&define([],()=>j)}),BV=U1(()=>{}),FV=U1(()=>{}),pJ={};X4(pJ,{cpus:()=>hJ});var hJ,kV=E(()=>{hJ=void 0}),AV=U1((Q,H)=>{var j=(()=>{var K=typeof document<"u"?document.currentScript?.src:void 0;return typeof G5<"u"&&(K||=G5),function(W={}){function U(){return l.buffer!=b1.buffer&&c1(),b1}function Z(){return l.buffer!=b1.buffer&&c1(),P1}function q(){return l.buffer!=b1.buffer&&c1(),O1}function G(){return l.buffer!=b1.buffer&&c1(),m1}function J(){return l.buffer!=b1.buffer&&c1(),A3}var X=W,V,R,z=new Promise((N,C)=>{V=N,R=C}),Y=Object.assign({},X),B="./this.program",k=(N,C)=>{throw C},w=typeof window=="object",A=typeof importScripts=="function",D=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",I=X.ENVIRONMENT_IS_PTHREAD||!1,h="";function $1(N){return X.locateFile?X.locateFile(N,h):h+N}var L1,x1,G1;if(D){var p=(gJ(),a3(q7)),S1=(dJ(),a3(W7));h=A?S1.dirname(h)+"/":r6+"/",L1=(N,C)=>(N=N3(N)?new URL(N):S1.normalize(N),p.readFileSync(N,C?void 0:"utf8")),G1=(N)=>(N=L1(N,!0),N.buffer||(N=new Uint8Array(N)),N),x1=(N,C,F,v=!0)=>{N=N3(N)?new URL(N):S1.normalize(N),p.readFile(N,v?void 0:"utf8",(g,x)=>{g?F(g):C(v?x.buffer:x)})},!X.thisProgram&&1<process.argv.length&&(B=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),k=(N,C)=>{throw process.exitCode=N,C},global.Worker=BV().Worker}else(w||A)&&(A?h=self.location.href:typeof document<"u"&&document.currentScript&&(h=document.currentScript.src),typeof K<"u"&&K&&(h=K),h.startsWith("blob:")?h="":h=h.substr(0,h.replace(/[?#].*/,"").lastIndexOf("/")+1),D||(L1=(N)=>{var C=new XMLHttpRequest;return C.open("GET",N,!1),C.send(null),C.responseText},A&&(G1=(N)=>{var C=new XMLHttpRequest;return C.open("GET",N,!1),C.responseType="arraybuffer",C.send(null),new Uint8Array(C.response)}),x1=(N,C,F)=>{var v=new XMLHttpRequest;v.open("GET",N,!0),v.responseType="arraybuffer",v.onload=()=>{v.status==200||v.status==0&&v.response?C(v.response):F()},v.onerror=F,v.send(null)}));D&&typeof performance>"u"&&(global.performance=FV().performance);var I3=console.log.bind(console),x3=console.error.bind(console);D&&(I3=(...N)=>p.writeSync(1,N.join(" ")+`
`),x3=(...N)=>p.writeSync(2,N.join(" ")+`
`));var k3=I3,R1=x3;Object.assign(X,Y),Y=null;var l,h1,X3=!1,v1,b1,P1,O1,m1,A3;function c1(){var N=l.buffer;X.HEAP8=b1=new Int8Array(N),X.HEAP16=new Int16Array(N),X.HEAPU8=P1=new Uint8Array(N),X.HEAPU16=new Uint16Array(N),X.HEAP32=O1=new Int32Array(N),X.HEAPU32=m1=new Uint32Array(N),X.HEAPF32=new Float32Array(N),X.HEAPF64=A3=new Float64Array(N)}var r3=16777216;if(I)l=X.wasmMemory;else if(X.wasmMemory)l=X.wasmMemory;else if(l=new WebAssembly.Memory({initial:r3/65536,maximum:65536,shared:!0}),!(l.buffer instanceof SharedArrayBuffer))throw R1("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),D&&R1("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");c1(),r3=l.buffer.byteLength;var a1=[],J3=[],H3=[],z1=0,k1=null,g1=null;function O3(){if(z1--,z1==0&&(k1!==null&&(clearInterval(k1),k1=null),g1)){var N=g1;g1=null,N()}}function g3(N){throw N="Aborted("+N+")",R1(N),X3=!0,v1=1,N=new WebAssembly.RuntimeError(N+". Build with -sASSERTIONS for more info."),R(N),N}var G4=(N)=>N.startsWith("data:application/octet-stream;base64,"),N3=(N)=>N.startsWith("file://"),S3;S3="ort-wasm-threaded.wasm",G4(S3)||(S3=$1(S3));function M3(N){if(G1)return G1(N);throw"both async and sync fetching of the wasm failed"}function $3(N){if(w||A){if(typeof fetch=="function"&&!N3(N))return fetch(N,{credentials:"same-origin"}).then((C)=>{if(!C.ok)throw`failed to load wasm binary file at '${N}'`;return C.arrayBuffer()}).catch(()=>M3(N));if(x1)return new Promise((C,F)=>{x1(N,(v)=>C(new Uint8Array(v)),F)})}return Promise.resolve().then(()=>M3(N))}function R4(N,C,F){return $3(N).then((v)=>WebAssembly.instantiate(v,C)).then(F,(v)=>{R1(`failed to asynchronously prepare wasm: ${v}`),g3(v)})}function i4(N,C){var F=S3;return typeof WebAssembly.instantiateStreaming!="function"||G4(F)||N3(F)||D||typeof fetch!="function"?R4(F,N,C):fetch(F,{credentials:"same-origin"}).then((v)=>WebAssembly.instantiateStreaming(v,N).then(C,function(g){return R1(`wasm streaming compile failed: ${g}`),R1("falling back to ArrayBuffer instantiation"),R4(F,N,C)}))}var K3,t3={799444:(N,C,F,v)=>{if(typeof X>"u"||!X.bb)return 1;if(N=A1(N>>>0),N.startsWith("./")&&(N=N.substring(2)),N=X.bb.get(N),!N)return 2;if(C>>>=0,F>>>=0,v>>>=0,C+F>N.byteLength)return 3;try{return Z().set(N.subarray(C,C+F),v>>>0),0}catch{return 4}}};function y3(N){this.name="ExitStatus",this.message=`Program terminated with exit(${N})`,this.status=N}var d3=(N)=>{N.terminate(),N.onmessage=()=>{}},o4=(N)=>{c.Oa.length==0&&(M4(),c.Xa(c.Oa[0]));var C=c.Oa.pop();if(!C)return 6;c.Pa.push(C),c.La[N.Na]=C,C.Na=N.Na;var F={cmd:"run",start_routine:N.gb,arg:N.cb,pthread_ptr:N.Na};return D&&C.unref(),C.postMessage(F,N.mb),0},Y3=0,a4=(N)=>{var C=_5();return N=N(),Q5(C),N},j1=(N,C,...F)=>a4(()=>{for(var v=F.length,g=D5(8*v),x=g>>>3,b=0;b<F.length;b++){var N1=F[b];J()[x+b>>>0]=N1}return O7(N,0,v,g,C)});function z4(N){if(I)return j1(0,1,N);v1=N,0<Y3||(c.hb(),X.onExit?.(N),X3=!0),k(N,new y3(N))}var N4=(N)=>{if(v1=N,I)throw r4(N),"unwind";z4(N)};function s(){for(var N=X.numThreads;N--;)M4();a1.unshift(()=>{z1++,n4(()=>O3())})}function M4(){var N=$1("ort-wasm-threaded.worker.js");N=new Worker(N),c.Oa.push(N)}function n4(N){I?N():Promise.all(c.Oa.map(c.Xa)).then(N)}var c={Oa:[],Pa:[],ab:[],La:{},Va(){I?(c.receiveObjectTransfer=c.fb,c.threadInitTLS=c.$a,c.setExitStatus=c.Za):s()},Za:(N)=>v1=N,pb:["$terminateWorker"],hb:()=>{for(var N of c.Pa)d3(N);for(N of c.Oa)d3(N);c.Oa=[],c.Pa=[],c.La=[]},Ya:(N)=>{var C=N.Na;delete c.La[C],c.Oa.push(N),c.Pa.splice(c.Pa.indexOf(N),1),N.Na=0,w5(C)},fb(){},$a(){c.ab.forEach((N)=>N())},Xa:(N)=>new Promise((C)=>{N.onmessage=(x)=>{x=x.data;var b=x.cmd;if(x.targetThread&&x.targetThread!=e4()){var N1=c.La[x.targetThread];N1?N1.postMessage(x,x.transferList):R1(`Internal error! Worker sent a message "${b}" to target pthread ${x.targetThread}, but that thread no longer exists!`)}else b==="checkMailbox"?t4():b==="spawnThread"?o4(x):b==="cleanupThread"?c.Ya(c.La[x.thread]):b==="killThread"?(x=x.thread,b=c.La[x],delete c.La[x],d3(b),w5(x),c.Pa.splice(c.Pa.indexOf(b),1),b.Na=0):b==="cancelThread"?c.La[x.thread].postMessage({cmd:"cancel"}):b==="loaded"?(N.loaded=!0,D&&!N.Na&&N.unref(),C(N)):b==="alert"?alert(`Thread ${x.threadId}: ${x.text}`):x.target==="setimmediate"?N.postMessage(x):b==="callHandler"?X[x.handler](...x.args):b&&R1(`worker sent an unknown command ${b}`)},N.onerror=(x)=>{throw R1(`worker sent an error! ${x.filename}:${x.lineno}: ${x.message}`),x},D&&(N.on("message",(x)=>N.onmessage({data:x})),N.on("error",(x)=>N.onerror(x)));var F=[],v=["onExit"],g;for(g of v)X.hasOwnProperty(g)&&F.push(g);N.postMessage({cmd:"load",handlers:F,urlOrBlob:X.mainScriptUrlOrBlob||K,wasmMemory:l,wasmModule:h1})})};X.PThread=c;var p3=(N)=>{for(;0<N.length;)N.shift()(X)};X.establishStackSpace=()=>{var N=e4(),C=G()[N+52>>>2>>>0];N=G()[N+56>>>2>>>0],d7(C,C-N),Q5(C)};function r4(N){if(I)return j1(1,0,N);N4(N)}var C3=[],Y4;X.invokeEntryPoint=(N,C)=>{Y3=0;var F=C3[N];F||(N>=C3.length&&(C3.length=N+1),C3[N]=F=Y4.get(N)),N=F(C),0<Y3?c.Za(N):T5(N)};class M{constructor(N){this.Ua=N-24}Va(N,C){G()[this.Ua+16>>>2>>>0]=0,G()[this.Ua+4>>>2>>>0]=N,G()[this.Ua+8>>>2>>>0]=C}}var S=0,L=0;function P(N,C,F,v){return I?j1(2,1,N,C,F,v):d(N,C,F,v)}function d(N,C,F,v){if(N>>>=0,C>>>=0,F>>>=0,v>>>=0,typeof SharedArrayBuffer>"u")return R1("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var g=[];return I&&g.length===0?P(N,C,F,v):(N={gb:F,Na:N,cb:v,mb:g},I?(N.ob="spawnThread",postMessage(N,g),0):o4(N))}var m=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,a=(N,C,F)=>{C>>>=0;var v=C+F;for(F=C;N[F]&&!(F>=v);)++F;if(16<F-C&&N.buffer&&m)return m.decode(N.buffer instanceof SharedArrayBuffer?N.slice(C,F):N.subarray(C,F));for(v="";C<F;){var g=N[C++];if(g&128){var x=N[C++]&63;if((g&224)==192)v+=String.fromCharCode((g&31)<<6|x);else{var b=N[C++]&63;g=(g&240)==224?(g&15)<<12|x<<6|b:(g&7)<<18|x<<12|b<<6|N[C++]&63,65536>g?v+=String.fromCharCode(g):(g-=65536,v+=String.fromCharCode(55296|g>>10,56320|g&1023))}}else v+=String.fromCharCode(g)}return v},A1=(N,C)=>(N>>>=0)?a(Z(),N,C):"";function f1(N,C,F){return I?j1(3,1,N,C,F):0}function T1(N,C){if(I)return j1(4,1,N,C)}var D1=(N)=>{for(var C=0,F=0;F<N.length;++F){var v=N.charCodeAt(F);127>=v?C++:2047>=v?C+=2:55296<=v&&57343>=v?(C+=4,++F):C+=3}return C},C4=(N,C,F,v)=>{if(F>>>=0,!(0<v))return 0;var g=F;v=F+v-1;for(var x=0;x<N.length;++x){var b=N.charCodeAt(x);if(55296<=b&&57343>=b){var N1=N.charCodeAt(++x);b=65536+((b&1023)<<10)|N1&1023}if(127>=b){if(F>=v)break;C[F++>>>0]=b}else{if(2047>=b){if(F+1>=v)break;C[F++>>>0]=192|b>>6}else{if(65535>=b){if(F+2>=v)break;C[F++>>>0]=224|b>>12}else{if(F+3>=v)break;C[F++>>>0]=240|b>>18,C[F++>>>0]=128|b>>12&63}C[F++>>>0]=128|b>>6&63}C[F++>>>0]=128|b&63}}return C[F>>>0]=0,F-g},L3=(N,C,F)=>C4(N,Z(),C,F);function T(N,C){if(I)return j1(5,1,N,C)}function J1(N,C,F){if(I)return j1(6,1,N,C,F)}function q1(N,C,F){return I?j1(7,1,N,C,F):0}function U3(N,C){if(I)return j1(8,1,N,C)}function B4(N,C,F){if(I)return j1(9,1,N,C,F)}function z7(N,C,F,v){if(I)return j1(10,1,N,C,F,v)}function N7(N,C,F,v){if(I)return j1(11,1,N,C,F,v)}function M7(N,C,F,v){if(I)return j1(12,1,N,C,F,v)}function Y7(N){if(I)return j1(13,1,N)}function C7(N,C){if(I)return j1(14,1,N,C)}function B7(N,C,F){if(I)return j1(15,1,N,C,F)}function A5(N){N>>>=0,typeof Atomics.nb=="function"&&(Atomics.nb(q(),N>>>2,N).value.then(t4),N+=128,Atomics.store(q(),N>>>2,1))}X.__emscripten_thread_mailbox_await=A5;var t4=()=>{var N=e4();if(N&&(A5(N),N=g7,!X3))try{if(N(),!(0<Y3))try{I?T5(v1):N4(v1)}catch(C){C instanceof y3||C=="unwind"||k(1,C)}}catch(C){C instanceof y3||C=="unwind"||k(1,C)}};X.checkMailbox=t4;var S5=[],e3=(N)=>N%4===0&&(N%100!==0||N%400===0),F7=[0,31,60,91,121,152,182,213,244,274,305,335],k7=[0,31,59,90,120,151,181,212,243,273,304,334];function A7(N,C,F,v,g,x,b,N1){return I?j1(16,1,N,C,F,v,g,x,b,N1):-52}function S7(N,C,F,v,g,x,b){if(I)return j1(17,1,N,C,F,v,g,x,b)}var $5=[],L5={},$7=()=>{if(!v5){var N={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:B||"./this.program"},C;for(C in L5)L5[C]===void 0?delete N[C]:N[C]=L5[C];var F=[];for(C in N)F.push(`${C}=${N[C]}`);v5=F}return v5},v5;function L7(N,C){if(I)return j1(18,1,N,C);N>>>=0,C>>>=0;var F=0;return $7().forEach((v,g)=>{var x=C+F;for(g=G()[N+4*g>>>2>>>0]=x,x=0;x<v.length;++x)U()[g++>>>0]=v.charCodeAt(x);U()[g>>>0]=0,F+=v.length+1}),0}function v7(N,C){if(I)return j1(19,1,N,C);N>>>=0,C>>>=0;var F=$7();G()[N>>>2>>>0]=F.length;var v=0;return F.forEach((g)=>v+=g.length+1),G()[C>>>2>>>0]=v,0}function w7(N){return I?j1(20,1,N):52}function T7(N,C,F,v){return I?j1(21,1,N,C,F,v):52}function D7(N,C,F,v,g){return I?j1(22,1,N,C,F,v,g):70}var NH=[null,[],[]];function _7(N,C,F,v){if(I)return j1(23,1,N,C,F,v);C>>>=0,F>>>=0,v>>>=0;for(var g=0,x=0;x<F;x++){var b=G()[C>>>2>>>0],N1=G()[C+4>>>2>>>0];C+=8;for(var q3=0;q3<N1;q3++){var E1=Z()[b+q3>>>0],p1=NH[N];E1===0||E1===10?((N===1?k3:R1)(a(p1,0)),p1.length=0):p1.push(E1)}g+=N1}return G()[v>>>2>>>0]=g,0}var P7=[31,29,31,30,31,30,31,31,30,31,30,31],E7=[31,28,31,30,31,30,31,31,30,31,30,31];function MH(N){var C=Array(D1(N)+1);return C4(N,C,0,C.length),C}var YH=(N,C)=>{U().set(N,C>>>0)};function I7(N,C,F,v){function g(_,Z1,M1){for(_=typeof _=="number"?_.toString():_||"";_.length<Z1;)_=M1[0]+_;return _}function x(_,Z1){return g(_,Z1,"0")}function b(_,Z1){function M1(m7){return 0>m7?-1:0<m7?1:0}var h3;return(h3=M1(_.getFullYear()-Z1.getFullYear()))===0&&(h3=M1(_.getMonth()-Z1.getMonth()))===0&&(h3=M1(_.getDate()-Z1.getDate())),h3}function N1(_){switch(_.getDay()){case 0:return new Date(_.getFullYear()-1,11,29);case 1:return _;case 2:return new Date(_.getFullYear(),0,3);case 3:return new Date(_.getFullYear(),0,2);case 4:return new Date(_.getFullYear(),0,1);case 5:return new Date(_.getFullYear()-1,11,31);case 6:return new Date(_.getFullYear()-1,11,30)}}function q3(_){var Z1=_.Qa;for(_=new Date(new Date(_.Ra+1900,0,1).getTime());0<Z1;){var M1=_.getMonth(),h3=(e3(_.getFullYear())?P7:E7)[M1];if(Z1>h3-_.getDate())Z1-=h3-_.getDate()+1,_.setDate(1),11>M1?_.setMonth(M1+1):(_.setMonth(0),_.setFullYear(_.getFullYear()+1));else{_.setDate(_.getDate()+Z1);break}}return M1=new Date(_.getFullYear()+1,0,4),Z1=N1(new Date(_.getFullYear(),0,4)),M1=N1(M1),0>=b(Z1,_)?0>=b(M1,_)?_.getFullYear()+1:_.getFullYear():_.getFullYear()-1}N>>>=0,C>>>=0,F>>>=0,v>>>=0;var E1=G()[v+40>>>2>>>0];v={kb:q()[v>>>2>>>0],jb:q()[v+4>>>2>>>0],Sa:q()[v+8>>>2>>>0],Wa:q()[v+12>>>2>>>0],Ta:q()[v+16>>>2>>>0],Ra:q()[v+20>>>2>>>0],Ma:q()[v+24>>>2>>>0],Qa:q()[v+28>>>2>>>0],qb:q()[v+32>>>2>>>0],ib:q()[v+36>>>2>>>0],lb:E1?A1(E1):""},F=A1(F),E1={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var p1 in E1)F=F.replace(new RegExp(p1,"g"),E1[p1]);var h7="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),b7="January February March April May June July August September October November December".split(" ");E1={"%a":(_)=>h7[_.Ma].substring(0,3),"%A":(_)=>h7[_.Ma],"%b":(_)=>b7[_.Ta].substring(0,3),"%B":(_)=>b7[_.Ta],"%C":(_)=>x((_.Ra+1900)/100|0,2),"%d":(_)=>x(_.Wa,2),"%e":(_)=>g(_.Wa,2," "),"%g":(_)=>q3(_).toString().substring(2),"%G":q3,"%H":(_)=>x(_.Sa,2),"%I":(_)=>(_=_.Sa,_==0?_=12:12<_&&(_-=12),x(_,2)),"%j":(_)=>{for(var Z1=0,M1=0;M1<=_.Ta-1;Z1+=(e3(_.Ra+1900)?P7:E7)[M1++]);return x(_.Wa+Z1,3)},"%m":(_)=>x(_.Ta+1,2),"%M":(_)=>x(_.jb,2),"%n":()=>`
`,"%p":(_)=>0<=_.Sa&&12>_.Sa?"AM":"PM","%S":(_)=>x(_.kb,2),"%t":()=>"	","%u":(_)=>_.Ma||7,"%U":(_)=>x(Math.floor((_.Qa+7-_.Ma)/7),2),"%V":(_)=>{var Z1=Math.floor((_.Qa+7-(_.Ma+6)%7)/7);if(2>=(_.Ma+371-_.Qa-2)%7&&Z1++,Z1)Z1==53&&(M1=(_.Ma+371-_.Qa)%7,M1==4||M1==3&&e3(_.Ra)||(Z1=1));else{Z1=52;var M1=(_.Ma+7-_.Qa-1)%7;(M1==4||M1==5&&e3(_.Ra%400-1))&&Z1++}return x(Z1,2)},"%w":(_)=>_.Ma,"%W":(_)=>x(Math.floor((_.Qa+7-(_.Ma+6)%7)/7),2),"%y":(_)=>(_.Ra+1900).toString().substring(2),"%Y":(_)=>_.Ra+1900,"%z":(_)=>{_=_.ib;var Z1=0<=_;return _=Math.abs(_)/60,(Z1?"+":"-")+("0000"+(_/60*100+_%60)).slice(-4)},"%Z":(_)=>_.lb,"%%":()=>"%"},F=F.replace(/%%/g,"\0\0");for(p1 in E1)F.includes(p1)&&(F=F.replace(new RegExp(p1,"g"),E1[p1](v)));return F=F.replace(/\0\0/g,"%"),p1=MH(F),p1.length>C?0:(YH(p1,N),p1.length-1)}c.Va();var CH=[z4,r4,P,f1,T1,T,J1,q1,U3,B4,z7,N7,M7,Y7,C7,B7,A7,S7,L7,v7,w7,T7,D7,_7],BH={b:function(N,C,F){throw N>>>=0,new M(N).Va(C>>>0,F>>>0),S=N,L++,S},L:function(N){x7(N>>>0,!A,1,!w,131072,!1),c.$a()},j:function(N){N>>>=0,I?postMessage({cmd:"cleanupThread",thread:N}):c.Ya(c.La[N])},H:d,h:f1,S:T1,D:T,F:J1,T:q1,Q:U3,J:B4,P:z7,n:N7,E:M7,B:Y7,R:C7,C:B7,p:()=>1,z:function(N,C){N>>>=0,N==C>>>0?setTimeout(t4):I?postMessage({targetThread:N,cmd:"checkMailbox"}):(N=c.La[N])&&N.postMessage({cmd:"checkMailbox"})},I:function(N,C,F,v,g){C>>>=0,F>>>=0,S5.length=v,g=g>>>0>>>3;for(var x=0;x<v;x++)S5[x]=J()[g+x>>>0];return N=C?t3[C]:CH[N],c.eb=F,F=N(...S5),c.eb=0,F},K:A5,o:function(N){D&&c.La[N>>>0].ref()},s:function(N,C,F){N=C+2097152>>>0<4194305-!!N?(N>>>0)+4294967296*C:NaN,F>>>=0,N=new Date(1000*N),q()[F>>>2>>>0]=N.getUTCSeconds(),q()[F+4>>>2>>>0]=N.getUTCMinutes(),q()[F+8>>>2>>>0]=N.getUTCHours(),q()[F+12>>>2>>>0]=N.getUTCDate(),q()[F+16>>>2>>>0]=N.getUTCMonth(),q()[F+20>>>2>>>0]=N.getUTCFullYear()-1900,q()[F+24>>>2>>>0]=N.getUTCDay(),N=(N.getTime()-Date.UTC(N.getUTCFullYear(),0,1,0,0,0,0))/86400000|0,q()[F+28>>>2>>>0]=N},t:function(N,C,F){N=C+2097152>>>0<4194305-!!N?(N>>>0)+4294967296*C:NaN,F>>>=0,N=new Date(1000*N),q()[F>>>2>>>0]=N.getSeconds(),q()[F+4>>>2>>>0]=N.getMinutes(),q()[F+8>>>2>>>0]=N.getHours(),q()[F+12>>>2>>>0]=N.getDate(),q()[F+16>>>2>>>0]=N.getMonth(),q()[F+20>>>2>>>0]=N.getFullYear()-1900,q()[F+24>>>2>>>0]=N.getDay(),C=(e3(N.getFullYear())?F7:k7)[N.getMonth()]+N.getDate()-1|0,q()[F+28>>>2>>>0]=C,q()[F+36>>>2>>>0]=-(60*N.getTimezoneOffset()),C=new Date(N.getFullYear(),6,1).getTimezoneOffset();var v=new Date(N.getFullYear(),0,1).getTimezoneOffset();N=(C!=v&&N.getTimezoneOffset()==Math.min(v,C))|0,q()[F+32>>>2>>>0]=N},u:function(N){N>>>=0;var C=new Date(q()[N+20>>>2>>>0]+1900,q()[N+16>>>2>>>0],q()[N+12>>>2>>>0],q()[N+8>>>2>>>0],q()[N+4>>>2>>>0],q()[N>>>2>>>0],0),F=q()[N+32>>>2>>>0],v=C.getTimezoneOffset(),g=new Date(C.getFullYear(),6,1).getTimezoneOffset(),x=new Date(C.getFullYear(),0,1).getTimezoneOffset(),b=Math.min(x,g);return 0>F?q()[N+32>>>2>>>0]=+(g!=x&&b==v):0<F!=(b==v)&&(g=Math.max(x,g),C.setTime(C.getTime()+60000*((0<F?b:g)-v))),q()[N+24>>>2>>>0]=C.getDay(),F=(e3(C.getFullYear())?F7:k7)[C.getMonth()]+C.getDate()-1|0,q()[N+28>>>2>>>0]=F,q()[N>>>2>>>0]=C.getSeconds(),q()[N+4>>>2>>>0]=C.getMinutes(),q()[N+8>>>2>>>0]=C.getHours(),q()[N+12>>>2>>>0]=C.getDate(),q()[N+16>>>2>>>0]=C.getMonth(),q()[N+20>>>2>>>0]=C.getYear(),N=C.getTime(),N=isNaN(N)?-1:N/1000,y7((K3=N,1<=+Math.abs(K3)?0<K3?+Math.floor(K3/4294967296)>>>0:~~+Math.ceil((K3-+(~~K3>>>0))/4294967296)>>>0:0)),N>>>0},q:A7,r:S7,y:function(N,C,F,v){N>>>=0,C>>>=0,F>>>=0,v>>>=0;var g=(new Date()).getFullYear(),x=new Date(g,0,1),b=new Date(g,6,1);g=x.getTimezoneOffset();var N1=b.getTimezoneOffset(),q3=Math.max(g,N1);G()[N>>>2>>>0]=60*q3,q()[C>>>2>>>0]=+(g!=N1),N=(E1)=>E1.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1],x=N(x),b=N(b),N1<g?(L3(x,F,17),L3(b,v,17)):(L3(x,v,17),L3(b,F,17))},c:()=>{g3("")},O:function(N,C,F){N>>>=0,C>>>=0,F>>>=0,$5.length=0;for(var v;v=Z()[C++>>>0];){var g=v!=105;g&=v!=112,F+=g&&F%8?4:0,$5.push(v==112?G()[F>>>2>>>0]:v==105?q()[F>>>2>>>0]:J()[F>>>3>>>0]),F+=g?8:4}return t3[N](...$5)},k:()=>{},i:()=>Date.now(),U:()=>{throw Y3+=1,"unwind"},A:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:()=>D?(kV(),a3(pJ)).cpus().length:navigator.hardwareConcurrency,x:function(N){N>>>=0;var C=Z().length;if(N<=C||4294901760<N)return!1;for(var F=1;4>=F;F*=2){var v=C*(1+0.2/F);v=Math.min(v,N+100663296);var g=Math;v=Math.max(N,v);Q:{g=(g.min.call(g,4294901760,v+(65536-v%65536)%65536)-l.buffer.byteLength+65535)/65536;try{l.grow(g),c1();var x=1;break Q}catch{}x=void 0}if(x)return!0}return!1},M:L7,N:v7,G:N4,g:w7,m:T7,v:D7,l:_7,a:l||X.wasmMemory,w:I7,d:function(N,C,F,v){return I7(N>>>0,C>>>0,F>>>0,v>>>0)}},f=function(){function N(F,v){return f=F.exports,f=FH(),c.ab.push(f.ya),Y4=f.za,J3.unshift(f.V),h1=v,O3(),f}var C={a:BH};if(z1++,X.instantiateWasm)try{return X.instantiateWasm(C,N)}catch(F){R1(`Module.instantiateWasm callback failed with error: ${F}`),R(F)}return i4(C,function(F){N(F.instance,F.module)}).catch(R),{}}();X._OrtInit=(N,C)=>(X._OrtInit=f.W)(N,C),X._OrtGetLastError=(N,C)=>(X._OrtGetLastError=f.X)(N,C),X._OrtCreateSessionOptions=(N,C,F,v,g,x,b,N1,q3,E1)=>(X._OrtCreateSessionOptions=f.Y)(N,C,F,v,g,x,b,N1,q3,E1),X._OrtAppendExecutionProvider=(N,C)=>(X._OrtAppendExecutionProvider=f.Z)(N,C),X._OrtAddFreeDimensionOverride=(N,C,F)=>(X._OrtAddFreeDimensionOverride=f._)(N,C,F),X._OrtAddSessionConfigEntry=(N,C,F)=>(X._OrtAddSessionConfigEntry=f.$)(N,C,F),X._OrtReleaseSessionOptions=(N)=>(X._OrtReleaseSessionOptions=f.aa)(N),X._OrtCreateSession=(N,C,F)=>(X._OrtCreateSession=f.ba)(N,C,F),X._OrtReleaseSession=(N)=>(X._OrtReleaseSession=f.ca)(N),X._OrtGetInputOutputCount=(N,C,F)=>(X._OrtGetInputOutputCount=f.da)(N,C,F),X._OrtGetInputName=(N,C)=>(X._OrtGetInputName=f.ea)(N,C),X._OrtGetOutputName=(N,C)=>(X._OrtGetOutputName=f.fa)(N,C),X._OrtFree=(N)=>(X._OrtFree=f.ga)(N),X._OrtCreateTensor=(N,C,F,v,g,x)=>(X._OrtCreateTensor=f.ha)(N,C,F,v,g,x),X._OrtGetTensorData=(N,C,F,v,g)=>(X._OrtGetTensorData=f.ia)(N,C,F,v,g),X._OrtReleaseTensor=(N)=>(X._OrtReleaseTensor=f.ja)(N),X._OrtCreateRunOptions=(N,C,F,v)=>(X._OrtCreateRunOptions=f.ka)(N,C,F,v),X._OrtAddRunConfigEntry=(N,C,F)=>(X._OrtAddRunConfigEntry=f.la)(N,C,F),X._OrtReleaseRunOptions=(N)=>(X._OrtReleaseRunOptions=f.ma)(N),X._OrtCreateBinding=(N)=>(X._OrtCreateBinding=f.na)(N),X._OrtBindInput=(N,C,F)=>(X._OrtBindInput=f.oa)(N,C,F),X._OrtBindOutput=(N,C,F,v)=>(X._OrtBindOutput=f.pa)(N,C,F,v),X._OrtClearBoundOutputs=(N)=>(X._OrtClearBoundOutputs=f.qa)(N),X._OrtReleaseBinding=(N)=>(X._OrtReleaseBinding=f.ra)(N),X._OrtRunWithBinding=(N,C,F,v,g)=>(X._OrtRunWithBinding=f.sa)(N,C,F,v,g),X._OrtRun=(N,C,F,v,g,x,b,N1)=>(X._OrtRun=f.ta)(N,C,F,v,g,x,b,N1),X._OrtEndProfiling=(N)=>(X._OrtEndProfiling=f.ua)(N);var e4=X._pthread_self=()=>(e4=X._pthread_self=f.va)();X._malloc=(N)=>(X._malloc=f.wa)(N),X._free=(N)=>(X._free=f.xa)(N),X.__emscripten_tls_init=()=>(X.__emscripten_tls_init=f.ya)();var x7=X.__emscripten_thread_init=(N,C,F,v,g,x)=>(x7=X.__emscripten_thread_init=f.Aa)(N,C,F,v,g,x);X.__emscripten_thread_crashed=()=>(X.__emscripten_thread_crashed=f.Ba)();var O7=(N,C,F,v,g)=>(O7=f.Ca)(N,C,F,v,g),w5=(N)=>(w5=f.Da)(N),T5=X.__emscripten_thread_exit=(N)=>(T5=X.__emscripten_thread_exit=f.Ea)(N),g7=()=>(g7=f.Fa)(),y7=(N)=>(y7=f.Ga)(N),d7=(N,C)=>(d7=f.Ha)(N,C),Q5=(N)=>(Q5=f.Ia)(N),D5=(N)=>(D5=f.Ja)(N),_5=()=>(_5=f.Ka)();function FH(){var N=f;N=Object.assign({},N);var C=(v)=>()=>v()>>>0,F=(v)=>(g)=>v(g)>>>0;return N.va=C(N.va),N.wa=F(N.wa),N.emscripten_main_runtime_thread_id=C(N.emscripten_main_runtime_thread_id),N.Ja=F(N.Ja),N.Ka=C(N.Ka),N}X.wasmMemory=l,X.stackSave=()=>_5(),X.stackRestore=(N)=>Q5(N),X.stackAlloc=(N)=>D5(N),X.keepRuntimeAlive=()=>0<Y3,X.UTF8ToString=A1,X.stringToUTF8=L3,X.lengthBytesUTF8=D1,X.ExitStatus=y3,X.PThread=c;var J5;g1=function N(){J5||p7(),J5||(g1=N)};function p7(){if(!(0<z1))if(I)V(X),I||p3(J3),startWorker(X);else{if(X.preRun)for(typeof X.preRun=="function"&&(X.preRun=[X.preRun]);X.preRun.length;)a1.unshift(X.preRun.shift());p3(a1),0<z1||J5||(J5=!0,X.calledRun=!0,X3||(I||p3(J3),V(X),I||p3(H3)))}}return p7(),z}})();typeof Q=="object"&&typeof H=="object"?H.exports=j:typeof define=="function"&&define.amd&&define([],()=>j)}),SV=U1((Q,H)=>{H.exports='"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs"),vm=require("vm");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>vm.runInThisContext(fs.readFileSync(e,"utf8"),{filename:e}),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(...e){var a=e.join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,a+`\n`);return}console.error(a)}function threadAlert(...e){var a=e.join(" ");postMessage({cmd:"alert",text:a,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,a)=>{var r=Module.wasmModule;Module.wasmModule=null;var t=new WebAssembly.Instance(r,e);return a(t)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let r=[];self.onmessage=t=>r.push(t),self.startWorker=t=>{Module=t,postMessage({cmd:"loaded"});for(let s of r)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const t of e.data.handlers)Module[t]=(...s)=>{postMessage({cmd:"callHandler",handler:t,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var a=URL.createObjectURL(e.data.urlOrBlob);importScripts(a),URL.revokeObjectURL(a)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(r){if(r!="unwind")throw r}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(r){throw Module.__emscripten_thread_crashed?.(),r}}self.onmessage=handleMessage;\n'}),K2,U2,q6,K5,T4,W6,q2,W2,G2,bJ,w1,s4=E(()=>{K2=CV(),U2=AV(),K5=!1,T4=!1,W6=!1,q2=(Q)=>{if(Q===1)return!1;if(typeof SharedArrayBuffer>"u")return typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+Q+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),!1;typeof process<"u"&&process.versions&&process.versions.node&&console.warn("env.wasm.numThreads is set to "+Q+", however, currently onnxruntime-web does not support multi-threads in Node.js. Please consider using onnxruntime-node for performance critical scenarios.");try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},W2=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},G2=(Q,H)=>Q?H?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":H?"ort-wasm-threaded.wasm":"ort-wasm.wasm",bJ=async(Q)=>{if(K5)return Promise.resolve();if(T4)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(W6)throw new Error("previous call to 'initializeWebAssembly()' failed.");T4=!0;let{initTimeout:H,numThreads:j,simd:K}=Q,W=q2(j),U=K&&W2(),Z=Q.wasmPaths,q=typeof Z=="string"?Z:void 0,G=G2(U,W),J=typeof Z=="object"?Z[G]:void 0,X=!1,V=[];if(H>0&&V.push(new Promise((R)=>{setTimeout(()=>{X=!0,R()},H)})),V.push(new Promise((R,z)=>{let Y=W?U2:K2,B={locateFile:(k,w)=>W&&k.endsWith(".worker.js")&&typeof Blob<"u"?URL.createObjectURL(new Blob([SV()],{type:"text/javascript"})):k.endsWith(".wasm")?J||(q??w)+G:w+k};if(W)if(B.numThreads=j,typeof Blob>"u")B.mainScriptUrlOrBlob=(void 0)(r6,"ort-wasm-threaded.js");else{let k=`var ortWasmThreaded=${Y.toString()};`;B.mainScriptUrlOrBlob=new Blob([k],{type:"text/javascript"})}Y(B).then((k)=>{T4=!1,K5=!0,q6=k,R()},(k)=>{T4=!1,W6=!0,z(k)})})),await Promise.race(V),X)throw new Error(`WebAssembly backend initializing failed due to timeout: ${H}ms`)},w1=()=>{if(K5&&q6)return q6;throw new Error("WebAssembly is not initialized yet.")}}),B1,M5,F1,G7=E(()=>{s4(),B1=(Q,H)=>{let j=w1(),K=j.lengthBytesUTF8(Q)+1,W=j._malloc(K);return j.stringToUTF8(Q,W,K),H.push(W),W},M5=(Q,H,j,K)=>{if(typeof Q=="object"&&Q!==null){if(j.has(Q))throw new Error("Circular reference in options");j.add(Q)}Object.entries(Q).forEach(([W,U])=>{let Z=H?H+W:W;if(typeof U=="object")M5(U,Z+".",j,K);else if(typeof U=="string"||typeof U=="number")K(Z,U.toString());else if(typeof U=="boolean")K(Z,U?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof U}`)})},F1=(Q)=>{let H=w1(),j=H.stackSave();try{let K=H.stackAlloc(8);H._OrtGetLastError(K,K+4);let W=H.HEAP32[K/4],U=H.HEAPU32[K/4+1],Z=U?H.UTF8ToString(U):"";throw new Error(`${Q} ERROR_CODE: ${W}, ERROR_MESSAGE: ${Z}`)}finally{H.stackRestore(j)}}}),mJ,$V=E(()=>{s4(),G7(),mJ=(Q)=>{let H=w1(),j=0,K=[],W=Q||{};try{if(Q?.logSeverityLevel===void 0)W.logSeverityLevel=2;else if(typeof Q.logSeverityLevel!="number"||!Number.isInteger(Q.logSeverityLevel)||Q.logSeverityLevel<0||Q.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${Q.logSeverityLevel}`);if(Q?.logVerbosityLevel===void 0)W.logVerbosityLevel=0;else if(typeof Q.logVerbosityLevel!="number"||!Number.isInteger(Q.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${Q.logVerbosityLevel}`);Q?.terminate===void 0&&(W.terminate=!1);let U=0;return Q?.tag!==void 0&&(U=B1(Q.tag,K)),j=H._OrtCreateRunOptions(W.logSeverityLevel,W.logVerbosityLevel,!!W.terminate,U),j===0&&F1("Can't create run options."),Q?.extra!==void 0&&M5(Q.extra,"",new WeakSet,(Z,q)=>{let G=B1(Z,K),J=B1(q,K);H._OrtAddRunConfigEntry(j,G,J)!==0&&F1(`Can't set a run config entry: ${Z} - ${q}.`)}),[j,K]}catch(U){throw j!==0&&H._OrtReleaseRunOptions(j),K.forEach((Z)=>H._free(Z)),U}}}),R2,z2,N2,M2,cJ,LV=E(()=>{s4(),G7(),R2=(Q)=>{switch(Q){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${Q}`)}},z2=(Q)=>{switch(Q){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${Q}`)}},N2=(Q)=>{Q.extra||(Q.extra={}),Q.extra.session||(Q.extra.session={});let H=Q.extra.session;H.use_ort_model_bytes_directly||(H.use_ort_model_bytes_directly="1"),Q.executionProviders&&Q.executionProviders.some((j)=>(typeof j=="string"?j:j.name)==="webgpu")&&(Q.enableMemPattern=!1)},M2=(Q,H,j)=>{for(let K of H){let W=typeof K=="string"?K:K.name;switch(W){case"webnn":if(W="WEBNN",typeof K!="string"){let Z=K;if(Z?.deviceType){let q=B1("deviceType",j),G=B1(Z.deviceType,j);w1()._OrtAddSessionConfigEntry(Q,q,G)!==0&&F1(`Can't set a session config entry: 'deviceType' - ${Z.deviceType}.`)}if(Z?.numThreads){let q=Z.numThreads;(typeof q!="number"||!Number.isInteger(q)||q<0)&&(q=0);let G=B1("numThreads",j),J=B1(q.toString(),j);w1()._OrtAddSessionConfigEntry(Q,G,J)!==0&&F1(`Can't set a session config entry: 'numThreads' - ${Z.numThreads}.`)}if(Z?.powerPreference){let q=B1("powerPreference",j),G=B1(Z.powerPreference,j);w1()._OrtAddSessionConfigEntry(Q,q,G)!==0&&F1(`Can't set a session config entry: 'powerPreference' - ${Z.powerPreference}.`)}}break;case"webgpu":if(W="JS",typeof K!="string"){let Z=K;if(Z?.preferredLayout){if(Z.preferredLayout!=="NCHW"&&Z.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${Z.preferredLayout}`);let q=B1("preferredLayout",j),G=B1(Z.preferredLayout,j);w1()._OrtAddSessionConfigEntry(Q,q,G)!==0&&F1(`Can't set a session config entry: 'preferredLayout' - ${Z.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${W}`)}let U=B1(W,j);w1()._OrtAppendExecutionProvider(Q,U)!==0&&F1(`Can't append execution provider: ${W}.`)}},cJ=(Q)=>{let H=w1(),j=0,K=[],W=Q||{};N2(W);try{let U=R2(W.graphOptimizationLevel??"all"),Z=z2(W.executionMode??"sequential"),q=typeof W.logId=="string"?B1(W.logId,K):0,G=W.logSeverityLevel??2;if(!Number.isInteger(G)||G<0||G>4)throw new Error(`log serverity level is not valid: ${G}`);let J=W.logVerbosityLevel??0;if(!Number.isInteger(J)||J<0||J>4)throw new Error(`log verbosity level is not valid: ${J}`);let X=typeof W.optimizedModelFilePath=="string"?B1(W.optimizedModelFilePath,K):0;if(j=H._OrtCreateSessionOptions(U,!!W.enableCpuMemArena,!!W.enableMemPattern,Z,!!W.enableProfiling,0,q,G,J,X),j===0&&F1("Can't create session options."),W.executionProviders&&M2(j,W.executionProviders,K),W.enableGraphCapture!==void 0){if(typeof W.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${W.enableGraphCapture}`);let V=B1("enableGraphCapture",K),R=B1(W.enableGraphCapture.toString(),K);H._OrtAddSessionConfigEntry(j,V,R)!==0&&F1(`Can't set a session config entry: 'enableGraphCapture' - ${W.enableGraphCapture}.`)}if(W.freeDimensionOverrides)for(let[V,R]of Object.entries(W.freeDimensionOverrides)){if(typeof V!="string")throw new Error(`free dimension override name must be a string: ${V}`);if(typeof R!="number"||!Number.isInteger(R)||R<0)throw new Error(`free dimension override value must be a non-negative integer: ${R}`);let z=B1(V,K);H._OrtAddFreeDimensionOverride(j,z,R)!==0&&F1(`Can't set a free dimension override: ${V} - ${R}.`)}return W.extra!==void 0&&M5(W.extra,"",new WeakSet,(V,R)=>{let z=B1(V,K),Y=B1(R,K);H._OrtAddSessionConfigEntry(j,z,Y)!==0&&F1(`Can't set a session config entry: ${V} - ${R}.`)}),[j,K]}catch(U){throw j!==0&&H._OrtReleaseSessionOptions(j),K.forEach((Z)=>H._free(Z)),U}}}),s6,fJ,i6,lJ,uJ,R7,sJ,iJ=E(()=>{s6=(Q)=>{switch(Q){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${Q}`)}},fJ=(Q)=>{switch(Q){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${Q}`)}},i6=(Q)=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][Q],lJ=(Q)=>{switch(Q){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${Q}`)}},uJ=(Q)=>{switch(Q){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${Q}`)}},R7=(Q)=>Q==="float32"||Q==="float16"||Q==="int32"||Q==="int64"||Q==="uint32"||Q==="uint8"||Q==="bool",sJ=(Q)=>{switch(Q){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${Q}`)}}}),Y5,oJ=E(()=>{Y5=async(Q)=>{if(typeof Q=="string")if(typeof process<"u"&&process.versions&&process.versions.node)try{return new Uint8Array(await(void 0)(Q))}catch(H){if(H.code==="ERR_FS_FILE_TOO_LARGE"){let j=(void 0)(Q),K=[];for await(let W of j)K.push(W);return new Uint8Array(Buffer.concat(K))}throw H}else{let H=await fetch(Q);if(!H.ok)throw new Error(`failed to load external data file: ${Q}`);let j=H.headers.get("Content-Length"),K=j?parseInt(j,10):0;if(K<1073741824)return new Uint8Array(await H.arrayBuffer());{if(!H.body)throw new Error(`failed to load external data file: ${Q}, no response body.`);let W=H.body.getReader(),U;try{U=new ArrayBuffer(K)}catch(q){if(q instanceof RangeError){let G=Math.ceil(K/65536);U=new WebAssembly.Memory({initial:G,maximum:G}).buffer}else throw q}let Z=0;for(;;){let{done:q,value:G}=await W.read();if(q)break;let J=G.byteLength;new Uint8Array(U,Z,J).set(G),Z+=J}return new Uint8Array(U,0,K)}}else return Q instanceof Blob?new Uint8Array(await Q.arrayBuffer()):Q instanceof Uint8Array?Q:new Uint8Array(Q)}}),Y2,aJ,nJ,c3,C2,o6,rJ,tJ,G6,eJ,QH,JH,vV=E(()=>{$V(),LV(),iJ(),s4(),G7(),oJ(),Y2=(Q,H)=>{w1()._OrtInit(Q,H)!==0&&F1("Can't initialize onnxruntime.")},aJ=async(Q)=>{Y2(Q.wasm.numThreads,uJ(Q.logLevel))},nJ=async(Q,H)=>{},c3=new Map,C2=(Q)=>{let H=w1(),j=H.stackSave();try{let K=H.stackAlloc(8);return H._OrtGetInputOutputCount(Q,K,K+4)!==0&&F1("Can't get session input/output count."),[H.HEAP32[K/4],H.HEAP32[K/4+1]]}finally{H.stackRestore(j)}},o6=(Q)=>{let H=w1(),j=H._malloc(Q.byteLength);if(j===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${Q.byteLength}.`);return H.HEAPU8.set(Q,j),[j,Q.byteLength]},rJ=async(Q,H)=>{let j,K,W=w1();Array.isArray(Q)?[j,K]=Q:Q.buffer===W.HEAPU8.buffer?[j,K]=[Q.byteOffset,Q.byteLength]:[j,K]=o6(Q);let U=0,Z=0,q=0,G=[],J=[],X=[];try{if([Z,G]=cJ(H),H?.externalData&&W.mountExternalData){let A=[];for(let D of H.externalData){let I=typeof D=="string"?D:D.path;A.push(Y5(typeof D=="string"?D:D.data).then((h)=>{W.mountExternalData(I,h)}))}await Promise.all(A)}U=await W._OrtCreateSession(j,K,Z),U===0&&F1("Can't create a session.");let[V,R]=C2(U),z=!!H?.enableGraphCapture,Y=[],B=[],k=[];for(let A=0;A<V;A++){let D=W._OrtGetInputName(U,A);D===0&&F1("Can't get an input name."),J.push(D),Y.push(W.UTF8ToString(D))}for(let A=0;A<R;A++){let D=W._OrtGetOutputName(U,A);D===0&&F1("Can't get an output name."),X.push(D);let I=W.UTF8ToString(D);B.push(I)}let w=null;return c3.set(U,[U,J,X,w,z,!1]),[U,Y,B]}catch(V){throw J.forEach((R)=>W._OrtFree(R)),X.forEach((R)=>W._OrtFree(R)),q!==0&&W._OrtReleaseBinding(q),U!==0&&W._OrtReleaseSession(U),V}finally{W._free(j),Z!==0&&W._OrtReleaseSessionOptions(Z),G.forEach((V)=>W._free(V)),W.unmountExternalData?.()}},tJ=(Q)=>{let H=w1(),j=c3.get(Q);if(!j)throw new Error(`cannot release session. invalid session id: ${Q}`);let[K,W,U,Z,q]=j;Z&&(q&&H._OrtClearBoundOutputs(Z.handle),H._OrtReleaseBinding(Z.handle)),H.jsepOnReleaseSession?.(Q),W.forEach((G)=>H._OrtFree(G)),U.forEach((G)=>H._OrtFree(G)),H._OrtReleaseSession(K),c3.delete(Q)},G6=(Q,H,j,K,W,U=!1)=>{if(!Q){H.push(0);return}let Z=w1(),q=Q[0],G=Q[1],J=Q[3],X,V;if(q==="string"&&J==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(U&&J!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${W} when enableGraphCapture is true.`);if(J==="gpu-buffer"){let Y=Q[2].gpuBuffer,B=i6(s6(q));V=G.reduce((w,A)=>w*A,1)*B;let k=Z.jsepRegisterBuffer;if(!k)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');X=k(K,W,Y,V)}else{let Y=Q[2];if(Array.isArray(Y)){V=4*Y.length,X=Z._malloc(V),j.push(X);let B=X/4;for(let k=0;k<Y.length;k++){if(typeof Y[k]!="string")throw new TypeError(`tensor data at index ${k} is not a string`);Z.HEAPU32[B++]=B1(Y[k],j)}}else V=Y.byteLength,X=Z._malloc(V),j.push(X),Z.HEAPU8.set(new Uint8Array(Y.buffer,Y.byteOffset,V),X)}let R=Z.stackSave(),z=Z.stackAlloc(4*G.length);try{let Y=z/4;G.forEach((k)=>Z.HEAP32[Y++]=k);let B=Z._OrtCreateTensor(s6(q),X,V,z,G.length,sJ(J));B===0&&F1(`Can't create tensor for input/output. session=${K}, index=${W}.`),H.push(B)}finally{Z.stackRestore(R)}},eJ=async(Q,H,j,K,W,U)=>{let Z=w1(),q=c3.get(Q);if(!q)throw new Error(`cannot run inference. invalid session id: ${Q}`);let G=q[0],J=q[1],X=q[2],V=q[3],R=q[4],z=q[5],Y=H.length,B=K.length,k=0,w=[],A=[],D=[],I=[],h=Z.stackSave(),$1=Z.stackAlloc(Y*4),L1=Z.stackAlloc(Y*4),x1=Z.stackAlloc(B*4),G1=Z.stackAlloc(B*4);try{[k,w]=mJ(U);for(let l=0;l<Y;l++)G6(j[l],A,I,Q,H[l],R);for(let l=0;l<B;l++)G6(W[l],D,I,Q,Y+K[l],R);let p=$1/4,S1=L1/4,I3=x1/4,x3=G1/4;for(let l=0;l<Y;l++)Z.HEAPU32[p++]=A[l],Z.HEAPU32[S1++]=J[H[l]];for(let l=0;l<B;l++)Z.HEAPU32[I3++]=D[l],Z.HEAPU32[x3++]=X[K[l]];Z.jsepOnRunStart?.(G);let k3;k3=await Z._OrtRun(G,L1,$1,Y,G1,B,x1,k),k3!==0&&F1("failed to call OrtRun().");let R1=[];for(let l=0;l<B;l++){let h1=Z.HEAPU32[x1/4+l];if(h1===D[l]){R1.push(W[l]);continue}let X3=Z.stackSave(),v1=Z.stackAlloc(16),b1=!1,P1,O1=0;try{Z._OrtGetTensorData(h1,v1,v1+4,v1+8,v1+12)!==0&&F1(`Can't access output tensor data on index ${l}.`);let m1=v1/4,A3=Z.HEAPU32[m1++];O1=Z.HEAPU32[m1++];let c1=Z.HEAPU32[m1++],r3=Z.HEAPU32[m1++],a1=[];for(let z1=0;z1<r3;z1++)a1.push(Z.HEAPU32[c1/4+z1]);Z._OrtFree(c1);let J3=a1.reduce((z1,k1)=>z1*k1,1);P1=fJ(A3);let H3=V?.outputPreferredLocations[K[l]];if(P1==="string"){if(H3==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let z1=[],k1=O1/4;for(let g1=0;g1<J3;g1++){let O3=Z.HEAPU32[k1++],g3=g1===J3-1?void 0:Z.HEAPU32[k1]-O3;z1.push(Z.UTF8ToString(O3,g3))}R1.push([P1,a1,z1,"cpu"])}else if(H3==="gpu-buffer"&&J3>0){let z1=Z.jsepGetBuffer;if(!z1)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let k1=z1(O1),g1=i6(A3);if(g1===void 0||!R7(P1))throw new Error(`Unsupported data type: ${P1}`);b1=!0,R1.push([P1,a1,{gpuBuffer:k1,download:Z.jsepCreateDownloader(k1,J3*g1,P1),dispose:()=>{Z._OrtReleaseTensor(h1)}},"gpu-buffer"])}else{let z1=lJ(P1),k1=new z1(J3);new Uint8Array(k1.buffer,k1.byteOffset,k1.byteLength).set(Z.HEAPU8.subarray(O1,O1+k1.byteLength)),R1.push([P1,a1,k1,"cpu"])}}finally{Z.stackRestore(X3),P1==="string"&&O1&&Z._free(O1),b1||Z._OrtReleaseTensor(h1)}}return V&&!R&&(Z._OrtClearBoundOutputs(V.handle),c3.set(Q,[G,J,X,V,R,!1])),R1}finally{Z.stackRestore(h),A.forEach((p)=>Z._OrtReleaseTensor(p)),D.forEach((p)=>Z._OrtReleaseTensor(p)),I.forEach((p)=>Z._free(p)),k!==0&&Z._OrtReleaseRunOptions(k),w.forEach((p)=>Z._free(p))}},QH=(Q)=>{let H=w1(),j=c3.get(Q);if(!j)throw new Error("invalid session id");let K=j[0],W=H._OrtEndProfiling(K);W===0&&F1("Can't get an profile file name."),H._OrtFree(W)},JH=(Q)=>{let H=[];for(let j of Q){let K=j[2];!Array.isArray(K)&&"buffer"in K&&H.push(K.buffer)}return H}}),wV=U1((Q,H)=>{H.exports='/*!\n * ONNX Runtime Web v1.18.0\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var vt=Object.defineProperty;var qr=Object.getOwnPropertyDescriptor;var Vr=Object.getOwnPropertyNames;var Jr=Object.prototype.hasOwnProperty;var _t=(i,c)=>()=>(i&&(c=i(i=0)),c);var Ke=(i,c)=>()=>(c||i((c={exports:{}}).exports,c),c.exports),Et=(i,c)=>{for(var a in c)vt(i,a,{get:c[a],enumerable:!0})},Xr=(i,c,a,h)=>{if(c&&typeof c=="object"||typeof c=="function")for(let f of Vr(c))!Jr.call(i,f)&&f!==a&&vt(i,f,{get:()=>c[f],enumerable:!(h=qr(c,f))||h.enumerable});return i};var et=i=>Xr(vt({},"__esModule",{value:!0}),i);var St={};Et(St,{createReadStream:()=>lr,readFile:()=>Qr,readFileSync:()=>Zr});var Qr,Zr,lr,At=_t(()=>{Qr=void 0,Zr=void 0,lr=void 0});var Tt={};Et(Tt,{join:()=>Kr});var Kr,Mt=_t(()=>{Kr=void 0});var pr=Ke((dr,Ct)=>{"use strict";var cr=(()=>{var i=typeof document<"u"?document.currentScript?.src:void 0;return typeof __filename<"u"&&(i||=__filename),function(c={}){var a=c,h,f,w=new Promise((t,o)=>{h=t,f=o}),g=Object.assign({},a),s="./this.program",S=typeof window=="object",x=typeof importScripts=="function",H=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",A="",I,V,R;if(H){var B=(At(),et(St)),D=(Mt(),et(Tt));A=x?D.dirname(A)+"/":__dirname+"/",I=(t,o)=>(t=ce(t)?new URL(t):D.normalize(t),B.readFileSync(t,o?void 0:"utf8")),R=t=>(t=I(t,!0),t.buffer||(t=new Uint8Array(t)),t),V=(t,o,u,m=!0)=>{t=ce(t)?new URL(t):D.normalize(t),B.readFile(t,m?void 0:"utf8",(O,E)=>{O?u(O):o(m?E.buffer:E)})},!a.thisProgram&&1<process.argv.length&&(s=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2)}else(S||x)&&(x?A=self.location.href:typeof document<"u"&&document.currentScript&&(A=document.currentScript.src),i&&(A=i),A.startsWith("blob:")?A="":A=A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1),I=t=>{var o=new XMLHttpRequest;return o.open("GET",t,!1),o.send(null),o.responseText},x&&(R=t=>{var o=new XMLHttpRequest;return o.open("GET",t,!1),o.responseType="arraybuffer",o.send(null),new Uint8Array(o.response)}),V=(t,o,u)=>{var m=new XMLHttpRequest;m.open("GET",t,!0),m.responseType="arraybuffer",m.onload=()=>{m.status==200||m.status==0&&m.response?o(m.response):u()},m.onerror=u,m.send(null)});var T=console.log.bind(console),L=console.error.bind(console);Object.assign(a,g),g=null;var W,de=!1,pe,Z,_,J,Pe;function le(){var t=W.buffer;a.HEAP8=pe=new Int8Array(t),a.HEAP16=new Int16Array(t),a.HEAPU8=Z=new Uint8Array(t),a.HEAPU16=new Uint16Array(t),a.HEAP32=_=new Int32Array(t),a.HEAPU32=J=new Uint32Array(t),a.HEAPF32=new Float32Array(t),a.HEAPF64=Pe=new Float64Array(t)}var Ie=[],ne=[],X=[],we=0,me=null,F=null;function ie(t){throw t="Aborted("+t+")",L(t),de=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),f(t),t}var xe=t=>t.startsWith("data:application/octet-stream;base64,"),ce=t=>t.startsWith("file://"),be;if(be="ort-wasm.wasm",!xe(be)){var ae=be;be=a.locateFile?a.locateFile(ae,A):A+ae}function K(t){if(R)return R(t);throw"both async and sync fetching of the wasm failed"}function je(t){if(S||x){if(typeof fetch=="function"&&!ce(t))return fetch(t,{credentials:"same-origin"}).then(o=>{if(!o.ok)throw`failed to load wasm binary file at \'${t}\'`;return o.arrayBuffer()}).catch(()=>K(t));if(V)return new Promise((o,u)=>{V(t,m=>o(new Uint8Array(m)),u)})}return Promise.resolve().then(()=>K(t))}function Oe(t,o,u){return je(t).then(m=>WebAssembly.instantiate(m,o)).then(u,m=>{L(`failed to asynchronously prepare wasm: ${m}`),ie(m)})}function Ue(t,o){var u=be;return typeof WebAssembly.instantiateStreaming!="function"||xe(u)||ce(u)||H||typeof fetch!="function"?Oe(u,t,o):fetch(u,{credentials:"same-origin"}).then(m=>WebAssembly.instantiateStreaming(m,t).then(o,function(O){return L(`wasm streaming compile failed: ${O}`),L("falling back to ArrayBuffer instantiation"),Oe(u,t,o)}))}var ve,Ae={798088:(t,o,u,m)=>{if(typeof a>"u"||!a.ya)return 1;if(t=ue(t>>>0),t.startsWith("./")&&(t=t.substring(2)),t=a.ya.get(t),!t)return 2;if(o>>>=0,u>>>=0,o+u>t.byteLength)return 3;try{return Z.set(t.subarray(o,o+u),m>>>0>>>0),0}catch{return 4}}};class _e{constructor(o){this.wa=o-24}}var ge=0,Be=0,te=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,re=(t,o,u)=>{o>>>=0;var m=o+u;for(u=o;t[u]&&!(u>=m);)++u;if(16<u-o&&t.buffer&&te)return te.decode(t.subarray(o,u));for(m="";o<u;){var O=t[o++];if(O&128){var E=t[o++]&63;if((O&224)==192)m+=String.fromCharCode((O&31)<<6|E);else{var U=t[o++]&63;O=(O&240)==224?(O&15)<<12|E<<6|U:(O&7)<<18|E<<12|U<<6|t[o++]&63,65536>O?m+=String.fromCharCode(O):(O-=65536,m+=String.fromCharCode(55296|O>>10,56320|O&1023))}}else m+=String.fromCharCode(O)}return m},ue=(t,o)=>(t>>>=0)?re(Z,t,o):"",Ee=t=>{for(var o=0,u=0;u<t.length;++u){var m=t.charCodeAt(u);127>=m?o++:2047>=m?o+=2:55296<=m&&57343>=m?(o+=4,++u):o+=3}return o},Se=(t,o,u,m)=>{if(u>>>=0,!(0<m))return 0;var O=u;m=u+m-1;for(var E=0;E<t.length;++E){var U=t.charCodeAt(E);if(55296<=U&&57343>=U){var ee=t.charCodeAt(++E);U=65536+((U&1023)<<10)|ee&1023}if(127>=U){if(u>=m)break;o[u++>>>0]=U}else{if(2047>=U){if(u+1>=m)break;o[u++>>>0]=192|U>>6}else{if(65535>=U){if(u+2>=m)break;o[u++>>>0]=224|U>>12}else{if(u+3>=m)break;o[u++>>>0]=240|U>>18,o[u++>>>0]=128|U>>12&63}o[u++>>>0]=128|U>>6&63}o[u++>>>0]=128|U&63}}return o[u>>>0]=0,u-O},Le=t=>t%4===0&&(t%100!==0||t%400===0),ze=[0,31,60,91,121,152,182,213,244,274,305,335],rt=[0,31,59,90,120,151,181,212,243,273,304,334],Te=[],Ge={},ke=()=>{if(!We){var t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:s||"./this.program"},o;for(o in Ge)Ge[o]===void 0?delete t[o]:t[o]=Ge[o];var u=[];for(o in t)u.push(`${o}=${t[o]}`);We=u}return We},We,nt=[null,[],[]],De=[31,29,31,30,31,30,31,31,30,31,30,31],at=[31,28,31,30,31,30,31,31,30,31,30,31];function G(t){var o=Array(Ee(t)+1);return Se(t,o,0,o.length),o}function qe(t,o,u,m){function O(d,k,$){for(d=typeof d=="number"?d.toString():d||"";d.length<k;)d=$[0]+d;return d}function E(d,k){return O(d,k,"0")}function U(d,k){function $(Ze){return 0>Ze?-1:0<Ze?1:0}var Me;return(Me=$(d.getFullYear()-k.getFullYear()))===0&&(Me=$(d.getMonth()-k.getMonth()))===0&&(Me=$(d.getDate()-k.getDate())),Me}function ee(d){switch(d.getDay()){case 0:return new Date(d.getFullYear()-1,11,29);case 1:return d;case 2:return new Date(d.getFullYear(),0,3);case 3:return new Date(d.getFullYear(),0,2);case 4:return new Date(d.getFullYear(),0,1);case 5:return new Date(d.getFullYear()-1,11,31);case 6:return new Date(d.getFullYear()-1,11,30)}}function ye(d){var k=d.sa;for(d=new Date(new Date(d.ta+1900,0,1).getTime());0<k;){var $=d.getMonth(),Me=(Le(d.getFullYear())?De:at)[$];if(k>Me-d.getDate())k-=Me-d.getDate()+1,d.setDate(1),11>$?d.setMonth($+1):(d.setMonth(0),d.setFullYear(d.getFullYear()+1));else{d.setDate(d.getDate()+k);break}}return $=new Date(d.getFullYear()+1,0,4),k=ee(new Date(d.getFullYear(),0,4)),$=ee($),0>=U(k,d)?0>=U($,d)?d.getFullYear()+1:d.getFullYear():d.getFullYear()-1}t>>>=0,o>>>=0,u>>>=0,m>>>=0;var oe=J[m+40>>>2>>>0];m={Ba:_[m>>>2>>>0],Aa:_[m+4>>>2>>>0],ua:_[m+8>>>2>>>0],xa:_[m+12>>>2>>>0],va:_[m+16>>>2>>>0],ta:_[m+20>>>2>>>0],na:_[m+24>>>2>>>0],sa:_[m+28>>>2>>>0],Da:_[m+32>>>2>>>0],za:_[m+36>>>2>>>0],Ca:oe?ue(oe):""},u=ue(u),oe={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var se in oe)u=u.replace(new RegExp(se,"g"),oe[se]);var Qe="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Re="January February March April May June July August September October November December".split(" ");oe={"%a":d=>Qe[d.na].substring(0,3),"%A":d=>Qe[d.na],"%b":d=>Re[d.va].substring(0,3),"%B":d=>Re[d.va],"%C":d=>E((d.ta+1900)/100|0,2),"%d":d=>E(d.xa,2),"%e":d=>O(d.xa,2," "),"%g":d=>ye(d).toString().substring(2),"%G":ye,"%H":d=>E(d.ua,2),"%I":d=>(d=d.ua,d==0?d=12:12<d&&(d-=12),E(d,2)),"%j":d=>{for(var k=0,$=0;$<=d.va-1;k+=(Le(d.ta+1900)?De:at)[$++]);return E(d.xa+k,3)},"%m":d=>E(d.va+1,2),"%M":d=>E(d.Aa,2),"%n":()=>`\n`,"%p":d=>0<=d.ua&&12>d.ua?"AM":"PM","%S":d=>E(d.Ba,2),"%t":()=>"	","%u":d=>d.na||7,"%U":d=>E(Math.floor((d.sa+7-d.na)/7),2),"%V":d=>{var k=Math.floor((d.sa+7-(d.na+6)%7)/7);if(2>=(d.na+371-d.sa-2)%7&&k++,k)k==53&&($=(d.na+371-d.sa)%7,$==4||$==3&&Le(d.ta)||(k=1));else{k=52;var $=(d.na+7-d.sa-1)%7;($==4||$==5&&Le(d.ta%400-1))&&k++}return E(k,2)},"%w":d=>d.na,"%W":d=>E(Math.floor((d.sa+7-(d.na+6)%7)/7),2),"%y":d=>(d.ta+1900).toString().substring(2),"%Y":d=>d.ta+1900,"%z":d=>{d=d.za;var k=0<=d;return d=Math.abs(d)/60,(k?"+":"-")+("0000"+(d/60*100+d%60)).slice(-4)},"%Z":d=>d.Ca,"%%":()=>"%"},u=u.replace(/%%/g,"\\0\\0");for(se in oe)u.includes(se)&&(u=u.replace(new RegExp(se,"g"),oe[se](m)));return u=u.replace(/\\0\\0/g,"%"),se=G(u),se.length>o?0:(pe.set(se,t>>>0),se.length-1)}var Ve={a:function(t,o,u){t>>>=0;var m=new _e(t);throw J[m.wa+16>>>2>>>0]=0,J[m.wa+4>>>2>>>0]=o>>>0,J[m.wa+8>>>2>>>0]=u>>>0,ge=t,Be++,ge},e:function(){return 0},H:function(){},x:function(){},z:function(){},J:function(){return 0},F:function(){},A:function(){},E:function(){},g:function(){},y:function(){},v:function(){},G:function(){},w:function(){},k:()=>1,I:function(t,o,u){return o>>>=0,Z.copyWithin(t>>>0>>>0,o>>>0,o+(u>>>0)>>>0)},n:function(t,o,u){t=o+2097152>>>0<4194305-!!t?(t>>>0)+4294967296*o:NaN,u>>>=0,t=new Date(1e3*t),_[u>>>2>>>0]=t.getUTCSeconds(),_[u+4>>>2>>>0]=t.getUTCMinutes(),_[u+8>>>2>>>0]=t.getUTCHours(),_[u+12>>>2>>>0]=t.getUTCDate(),_[u+16>>>2>>>0]=t.getUTCMonth(),_[u+20>>>2>>>0]=t.getUTCFullYear()-1900,_[u+24>>>2>>>0]=t.getUTCDay(),_[u+28>>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},o:function(t,o,u){t=o+2097152>>>0<4194305-!!t?(t>>>0)+4294967296*o:NaN,u>>>=0,t=new Date(1e3*t),_[u>>>2>>>0]=t.getSeconds(),_[u+4>>>2>>>0]=t.getMinutes(),_[u+8>>>2>>>0]=t.getHours(),_[u+12>>>2>>>0]=t.getDate(),_[u+16>>>2>>>0]=t.getMonth(),_[u+20>>>2>>>0]=t.getFullYear()-1900,_[u+24>>>2>>>0]=t.getDay(),_[u+28>>>2>>>0]=(Le(t.getFullYear())?ze:rt)[t.getMonth()]+t.getDate()-1|0,_[u+36>>>2>>>0]=-(60*t.getTimezoneOffset()),o=new Date(t.getFullYear(),6,1).getTimezoneOffset();var m=new Date(t.getFullYear(),0,1).getTimezoneOffset();_[u+32>>>2>>>0]=(o!=m&&t.getTimezoneOffset()==Math.min(m,o))|0},p:function(t){t>>>=0;var o=new Date(_[t+20>>>2>>>0]+1900,_[t+16>>>2>>>0],_[t+12>>>2>>>0],_[t+8>>>2>>>0],_[t+4>>>2>>>0],_[t>>>2>>>0],0),u=_[t+32>>>2>>>0],m=o.getTimezoneOffset(),O=new Date(o.getFullYear(),6,1).getTimezoneOffset(),E=new Date(o.getFullYear(),0,1).getTimezoneOffset(),U=Math.min(E,O);return 0>u?_[t+32>>>2>>>0]=+(O!=E&&U==m):0<u!=(U==m)&&(O=Math.max(E,O),o.setTime(o.getTime()+6e4*((0<u?U:O)-m))),_[t+24>>>2>>>0]=o.getDay(),_[t+28>>>2>>>0]=(Le(o.getFullYear())?ze:rt)[o.getMonth()]+o.getDate()-1|0,_[t>>>2>>>0]=o.getSeconds(),_[t+4>>>2>>>0]=o.getMinutes(),_[t+8>>>2>>>0]=o.getHours(),_[t+12>>>2>>>0]=o.getDate(),_[t+16>>>2>>>0]=o.getMonth(),_[t+20>>>2>>>0]=o.getYear(),t=o.getTime(),t=isNaN(t)?-1:t/1e3,Je((ve=t,1<=+Math.abs(ve)?0<ve?+Math.floor(ve/4294967296)>>>0:~~+Math.ceil((ve-+(~~ve>>>0))/4294967296)>>>0:0)),t>>>0},l:function(){return-52},m:function(){},t:function(t,o,u,m){u>>>=0,m>>>=0;var O=new Date().getFullYear(),E=new Date(O,0,1),U=new Date(O,6,1);O=E.getTimezoneOffset();var ee=U.getTimezoneOffset();J[t>>>0>>>2>>>0]=60*Math.max(O,ee),_[o>>>0>>>2>>>0]=+(O!=ee),t=ye=>ye.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1],E=t(E),U=t(U),ee<O?(Se(E,Z,u,17),Se(U,Z,m,17)):(Se(E,Z,m,17),Se(U,Z,u,17))},d:()=>{ie("")},B:function(t,o,u){t>>>=0,o>>>=0,u>>>=0,Te.length=0;for(var m;m=Z[o++>>>0];){var O=m!=105;O&=m!=112,u+=O&&u%8?4:0,Te.push(m==112?J[u>>>2>>>0]:m==105?_[u>>>2>>>0]:Pe[u>>>3>>>0]),u+=O?8:4}return Ae[t](...Te)},h:()=>Date.now(),u:function(){return 4294901760},b:()=>performance.now(),s:function(t){t>>>=0;var o=Z.length;if(4294901760<t)return!1;for(var u=1;4>=u;u*=2){var m=o*(1+.2/u);m=Math.min(m,t+100663296);var O=Math;m=Math.max(t,m);e:{O=(O.min.call(O,4294901760,m+(65536-m%65536)%65536)-W.buffer.byteLength+65535)/65536;try{W.grow(O),le();var E=1;break e}catch{}E=void 0}if(E)return!0}return!1},C:function(t,o){t>>>=0,o>>>=0;var u=0;return ke().forEach((m,O)=>{var E=o+u;for(O=J[t+4*O>>>2>>>0]=E,E=0;E<m.length;++E)pe[O++>>>0]=m.charCodeAt(E);pe[O>>>0]=0,u+=m.length+1}),0},D:function(t,o){t>>>=0,o>>>=0;var u=ke();J[t>>>2>>>0]=u.length;var m=0;return u.forEach(O=>m+=O.length+1),J[o>>>2>>>0]=m,0},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(t,o,u,m){o>>>=0,u>>>=0,m>>>=0;for(var O=0,E=0;E<u;E++){var U=J[o>>>2>>>0],ee=J[o+4>>>2>>>0];o+=8;for(var ye=0;ye<ee;ye++){var oe=Z[U+ye>>>0],se=nt[t];oe===0||oe===10?((t===1?T:L)(re(se,0)),se.length=0):se.push(oe)}O+=ee}return J[m>>>2>>>0]=O,0},r:qe,c:function(t,o,u,m){return qe(t>>>0,o>>>0,u>>>0,m>>>0)}},P=function(){function t(u){return P=u.exports,P=st(),W=P.K,le(),ne.unshift(P.L),we--,we==0&&(me!==null&&(clearInterval(me),me=null),F&&(u=F,F=null,u())),P}var o={a:Ve};if(we++,a.instantiateWasm)try{return a.instantiateWasm(o,t)}catch(u){L(`Module.instantiateWasm callback failed with error: ${u}`),f(u)}return Ue(o,function(u){t(u.instance)}).catch(f),{}}();a._OrtInit=(t,o)=>(a._OrtInit=P.M)(t,o),a._OrtGetLastError=(t,o)=>(a._OrtGetLastError=P.N)(t,o),a._OrtCreateSessionOptions=(t,o,u,m,O,E,U,ee,ye,oe)=>(a._OrtCreateSessionOptions=P.O)(t,o,u,m,O,E,U,ee,ye,oe),a._OrtAppendExecutionProvider=(t,o)=>(a._OrtAppendExecutionProvider=P.P)(t,o),a._OrtAddFreeDimensionOverride=(t,o,u)=>(a._OrtAddFreeDimensionOverride=P.Q)(t,o,u),a._OrtAddSessionConfigEntry=(t,o,u)=>(a._OrtAddSessionConfigEntry=P.R)(t,o,u),a._OrtReleaseSessionOptions=t=>(a._OrtReleaseSessionOptions=P.S)(t),a._OrtCreateSession=(t,o,u)=>(a._OrtCreateSession=P.T)(t,o,u),a._OrtReleaseSession=t=>(a._OrtReleaseSession=P.U)(t),a._OrtGetInputOutputCount=(t,o,u)=>(a._OrtGetInputOutputCount=P.V)(t,o,u),a._OrtGetInputName=(t,o)=>(a._OrtGetInputName=P.W)(t,o),a._OrtGetOutputName=(t,o)=>(a._OrtGetOutputName=P.X)(t,o),a._OrtFree=t=>(a._OrtFree=P.Y)(t),a._OrtCreateTensor=(t,o,u,m,O,E)=>(a._OrtCreateTensor=P.Z)(t,o,u,m,O,E),a._OrtGetTensorData=(t,o,u,m,O)=>(a._OrtGetTensorData=P._)(t,o,u,m,O),a._OrtReleaseTensor=t=>(a._OrtReleaseTensor=P.$)(t),a._OrtCreateRunOptions=(t,o,u,m)=>(a._OrtCreateRunOptions=P.aa)(t,o,u,m),a._OrtAddRunConfigEntry=(t,o,u)=>(a._OrtAddRunConfigEntry=P.ba)(t,o,u),a._OrtReleaseRunOptions=t=>(a._OrtReleaseRunOptions=P.ca)(t),a._OrtCreateBinding=t=>(a._OrtCreateBinding=P.da)(t),a._OrtBindInput=(t,o,u)=>(a._OrtBindInput=P.ea)(t,o,u),a._OrtBindOutput=(t,o,u,m)=>(a._OrtBindOutput=P.fa)(t,o,u,m),a._OrtClearBoundOutputs=t=>(a._OrtClearBoundOutputs=P.ga)(t),a._OrtReleaseBinding=t=>(a._OrtReleaseBinding=P.ha)(t),a._OrtRunWithBinding=(t,o,u,m,O)=>(a._OrtRunWithBinding=P.ia)(t,o,u,m,O),a._OrtRun=(t,o,u,m,O,E,U,ee)=>(a._OrtRun=P.ja)(t,o,u,m,O,E,U,ee),a._OrtEndProfiling=t=>(a._OrtEndProfiling=P.ka)(t),a._malloc=t=>(a._malloc=P.la)(t),a._free=t=>(a._free=P.ma)(t);var Je=t=>(Je=P.oa)(t),ot=t=>(ot=P.pa)(t),M=t=>(M=P.qa)(t),Ne=()=>(Ne=P.ra)();function st(){var t=P;t=Object.assign({},t);var o=u=>m=>u(m)>>>0;return t.la=o(t.la),t.qa=o(t.qa),t.ra=(u=>()=>u()>>>0)(t.ra),t}a.stackSave=()=>Ne(),a.stackRestore=t=>ot(t),a.stackAlloc=t=>M(t),a.UTF8ToString=ue,a.stringToUTF8=(t,o,u)=>Se(t,Z,o,u),a.lengthBytesUTF8=Ee;var Fe;F=function t(){Fe||Xe(),Fe||(F=t)};function Xe(){if(!(0<we)){if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;){var t=a.preRun.shift();Ie.unshift(t)}for(;0<Ie.length;)Ie.shift()(a);if(!(0<we||Fe||(Fe=!0,a.calledRun=!0,de))){for(;0<ne.length;)ne.shift()(a);for(h(a);0<X.length;)X.shift()(a)}}}return Xe(),w}})();typeof dr=="object"&&typeof Ct=="object"?Ct.exports=cr:typeof define=="function"&&define.amd&&define([],()=>cr)});var mr=Ke(()=>{});var gr=Ke(()=>{});var hr={};Et(hr,{cpus:()=>en});var en,br=_t(()=>{en=void 0});var Or=Ke((wr,Dt)=>{"use strict";var yr=(()=>{var i=typeof document<"u"?document.currentScript?.src:void 0;return typeof __filename<"u"&&(i||=__filename),function(c={}){function a(){return X.buffer!=ie.buffer&&K(),ie}function h(){return X.buffer!=ie.buffer&&K(),xe}function f(){return X.buffer!=ie.buffer&&K(),ce}function w(){return X.buffer!=ie.buffer&&K(),be}function g(){return X.buffer!=ie.buffer&&K(),ae}var s=c,S,x,H=new Promise((e,r)=>{S=e,x=r}),A=Object.assign({},s),I="./this.program",V=(e,r)=>{throw r},R=typeof window=="object",B=typeof importScripts=="function",D=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",T=s.ENVIRONMENT_IS_PTHREAD||!1,L="";function W(e){return s.locateFile?s.locateFile(e,L):L+e}var de,pe,Z;if(D){var _=(At(),et(St)),J=(Mt(),et(Tt));L=B?J.dirname(L)+"/":__dirname+"/",de=(e,r)=>(e=ue(e)?new URL(e):J.normalize(e),_.readFileSync(e,r?void 0:"utf8")),Z=e=>(e=de(e,!0),e.buffer||(e=new Uint8Array(e)),e),pe=(e,r,n,l=!0)=>{e=ue(e)?new URL(e):J.normalize(e),_.readFile(e,l?void 0:"utf8",(y,b)=>{y?n(y):r(l?b.buffer:b)})},!s.thisProgram&&1<process.argv.length&&(I=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),V=(e,r)=>{throw process.exitCode=e,r},global.Worker=mr().Worker}else(R||B)&&(B?L=self.location.href:typeof document<"u"&&document.currentScript&&(L=document.currentScript.src),typeof i<"u"&&i&&(L=i),L.startsWith("blob:")?L="":L=L.substr(0,L.replace(/[?#].*/,"").lastIndexOf("/")+1),D||(de=e=>{var r=new XMLHttpRequest;return r.open("GET",e,!1),r.send(null),r.responseText},B&&(Z=e=>{var r=new XMLHttpRequest;return r.open("GET",e,!1),r.responseType="arraybuffer",r.send(null),new Uint8Array(r.response)}),pe=(e,r,n)=>{var l=new XMLHttpRequest;l.open("GET",e,!0),l.responseType="arraybuffer",l.onload=()=>{l.status==200||l.status==0&&l.response?r(l.response):n()},l.onerror=n,l.send(null)}));D&&typeof performance>"u"&&(global.performance=gr().performance);var Pe=console.log.bind(console),le=console.error.bind(console);D&&(Pe=(...e)=>_.writeSync(1,e.join(" ")+`\n`),le=(...e)=>_.writeSync(2,e.join(" ")+`\n`));var Ie=Pe,ne=le;Object.assign(s,A),A=null;var X,we,me=!1,F,ie,xe,ce,be,ae;function K(){var e=X.buffer;s.HEAP8=ie=new Int8Array(e),s.HEAP16=new Int16Array(e),s.HEAPU8=xe=new Uint8Array(e),s.HEAPU16=new Uint16Array(e),s.HEAP32=ce=new Int32Array(e),s.HEAPU32=be=new Uint32Array(e),s.HEAPF32=new Float32Array(e),s.HEAPF64=ae=new Float64Array(e)}var je=16777216;if(T)X=s.wasmMemory;else if(s.wasmMemory)X=s.wasmMemory;else if(X=new WebAssembly.Memory({initial:je/65536,maximum:65536,shared:!0}),!(X.buffer instanceof SharedArrayBuffer))throw ne("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),D&&ne("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");K(),je=X.buffer.byteLength;var Oe=[],Ue=[],ve=[],Ae=0,_e=null,ge=null;function Be(){if(Ae--,Ae==0&&(_e!==null&&(clearInterval(_e),_e=null),ge)){var e=ge;ge=null,e()}}function te(e){throw e="Aborted("+e+")",ne(e),me=!0,F=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),x(e),e}var re=e=>e.startsWith("data:application/octet-stream;base64,"),ue=e=>e.startsWith("file://"),Ee;Ee="ort-wasm-threaded.wasm",re(Ee)||(Ee=W(Ee));function Se(e){if(Z)return Z(e);throw"both async and sync fetching of the wasm failed"}function Le(e){if(R||B){if(typeof fetch=="function"&&!ue(e))return fetch(e,{credentials:"same-origin"}).then(r=>{if(!r.ok)throw`failed to load wasm binary file at \'${e}\'`;return r.arrayBuffer()}).catch(()=>Se(e));if(pe)return new Promise((r,n)=>{pe(e,l=>r(new Uint8Array(l)),n)})}return Promise.resolve().then(()=>Se(e))}function ze(e,r,n){return Le(e).then(l=>WebAssembly.instantiate(l,r)).then(n,l=>{ne(`failed to asynchronously prepare wasm: ${l}`),te(l)})}function rt(e,r){var n=Ee;return typeof WebAssembly.instantiateStreaming!="function"||re(n)||ue(n)||D||typeof fetch!="function"?ze(n,e,r):fetch(n,{credentials:"same-origin"}).then(l=>WebAssembly.instantiateStreaming(l,e).then(r,function(y){return ne(`wasm streaming compile failed: ${y}`),ne("falling back to ArrayBuffer instantiation"),ze(n,e,r)}))}var Te,Ge={799444:(e,r,n,l)=>{if(typeof s>"u"||!s.bb)return 1;if(e=ee(e>>>0),e.startsWith("./")&&(e=e.substring(2)),e=s.bb.get(e),!e)return 2;if(r>>>=0,n>>>=0,l>>>=0,r+n>e.byteLength)return 3;try{return h().set(e.subarray(r,r+n),l>>>0),0}catch{return 4}}};function ke(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}var We=e=>{e.terminate(),e.onmessage=()=>{}},nt=e=>{M.Oa.length==0&&(Je(),M.Xa(M.Oa[0]));var r=M.Oa.pop();if(!r)return 6;M.Pa.push(r),M.La[e.Na]=r,r.Na=e.Na;var n={cmd:"run",start_routine:e.gb,arg:e.cb,pthread_ptr:e.Na};return D&&r.unref(),r.postMessage(n,e.mb),0},De=0,at=e=>{var r=Ot();return e=e(),ft(r),e},G=(e,r,...n)=>at(()=>{for(var l=n.length,y=wt(8*l),b=y>>>3,v=0;v<n.length;v++){var z=n[v];g()[b+v>>>0]=z}return rr(e,0,l,y,r)});function qe(e){if(T)return G(0,1,e);F=e,0<De||(M.hb(),s.onExit?.(e),me=!0),V(e,new ke(e))}var Ve=e=>{if(F=e,T)throw st(e),"unwind";qe(e)};function P(){for(var e=s.numThreads;e--;)Je();Oe.unshift(()=>{Ae++,ot(()=>Be())})}function Je(){var e=W("ort-wasm-threaded.worker.js");e=new Worker(e),M.Oa.push(e)}function ot(e){T?e():Promise.all(M.Oa.map(M.Xa)).then(e)}var M={Oa:[],Pa:[],ab:[],La:{},Va(){T?(M.receiveObjectTransfer=M.fb,M.threadInitTLS=M.$a,M.setExitStatus=M.Za):P()},Za:e=>F=e,pb:["$terminateWorker"],hb:()=>{for(var e of M.Pa)We(e);for(e of M.Oa)We(e);M.Oa=[],M.Pa=[],M.La=[]},Ya:e=>{var r=e.Na;delete M.La[r],M.Oa.push(e),M.Pa.splice(M.Pa.indexOf(e),1),e.Na=0,bt(r)},fb(){},$a(){M.ab.forEach(e=>e())},Xa:e=>new Promise(r=>{e.onmessage=b=>{b=b.data;var v=b.cmd;if(b.targetThread&&b.targetThread!=ut()){var z=M.La[b.targetThread];z?z.postMessage(b,b.transferList):ne(`Internal error! Worker sent a message "${v}" to target pthread ${b.targetThread}, but that thread no longer exists!`)}else v==="checkMailbox"?it():v==="spawnThread"?nt(b):v==="cleanupThread"?M.Ya(M.La[b.thread]):v==="killThread"?(b=b.thread,v=M.La[b],delete M.La[b],We(v),bt(b),M.Pa.splice(M.Pa.indexOf(v),1),v.Na=0):v==="cancelThread"?M.La[b.thread].postMessage({cmd:"cancel"}):v==="loaded"?(e.loaded=!0,D&&!e.Na&&e.unref(),r(e)):v==="alert"?alert(`Thread ${b.threadId}: ${b.text}`):b.target==="setimmediate"?e.postMessage(b):v==="callHandler"?s[b.handler](...b.args):v&&ne(`worker sent an unknown command ${v}`)},e.onerror=b=>{throw ne(`worker sent an error! ${b.filename}:${b.lineno}: ${b.message}`),b},D&&(e.on("message",b=>e.onmessage({data:b})),e.on("error",b=>e.onerror(b)));var n=[],l=["onExit"],y;for(y of l)s.hasOwnProperty(y)&&n.push(y);e.postMessage({cmd:"load",handlers:n,urlOrBlob:s.mainScriptUrlOrBlob||i,wasmMemory:X,wasmModule:we})})};s.PThread=M;var Ne=e=>{for(;0<e.length;)e.shift()(s)};s.establishStackSpace=()=>{var e=ut(),r=w()[e+52>>>2>>>0];e=w()[e+56>>>2>>>0],or(r,r-e),ft(r)};function st(e){if(T)return G(1,0,e);Ve(e)}var Fe=[],Xe;s.invokeEntryPoint=(e,r)=>{De=0;var n=Fe[e];n||(e>=Fe.length&&(Fe.length=e+1),Fe[e]=n=Xe.get(e)),e=n(r),0<De?M.Za(e):yt(e)};class t{constructor(r){this.Ua=r-24}Va(r,n){w()[this.Ua+16>>>2>>>0]=0,w()[this.Ua+4>>>2>>>0]=r,w()[this.Ua+8>>>2>>>0]=n}}var o=0,u=0;function m(e,r,n,l){return T?G(2,1,e,r,n,l):O(e,r,n,l)}function O(e,r,n,l){if(e>>>=0,r>>>=0,n>>>=0,l>>>=0,typeof SharedArrayBuffer>"u")return ne("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var y=[];return T&&y.length===0?m(e,r,n,l):(e={gb:n,Na:e,cb:l,mb:y},T?(e.ob="spawnThread",postMessage(e,y),0):nt(e))}var E=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,U=(e,r,n)=>{r>>>=0;var l=r+n;for(n=r;e[n]&&!(n>=l);)++n;if(16<n-r&&e.buffer&&E)return E.decode(e.buffer instanceof SharedArrayBuffer?e.slice(r,n):e.subarray(r,n));for(l="";r<n;){var y=e[r++];if(y&128){var b=e[r++]&63;if((y&224)==192)l+=String.fromCharCode((y&31)<<6|b);else{var v=e[r++]&63;y=(y&240)==224?(y&15)<<12|b<<6|v:(y&7)<<18|b<<12|v<<6|e[r++]&63,65536>y?l+=String.fromCharCode(y):(y-=65536,l+=String.fromCharCode(55296|y>>10,56320|y&1023))}}else l+=String.fromCharCode(y)}return l},ee=(e,r)=>(e>>>=0)?U(h(),e,r):"";function ye(e,r,n){return T?G(3,1,e,r,n):0}function oe(e,r){if(T)return G(4,1,e,r)}var se=e=>{for(var r=0,n=0;n<e.length;++n){var l=e.charCodeAt(n);127>=l?r++:2047>=l?r+=2:55296<=l&&57343>=l?(r+=4,++n):r+=3}return r},Qe=(e,r,n,l)=>{if(n>>>=0,!(0<l))return 0;var y=n;l=n+l-1;for(var b=0;b<e.length;++b){var v=e.charCodeAt(b);if(55296<=v&&57343>=v){var z=e.charCodeAt(++b);v=65536+((v&1023)<<10)|z&1023}if(127>=v){if(n>=l)break;r[n++>>>0]=v}else{if(2047>=v){if(n+1>=l)break;r[n++>>>0]=192|v>>6}else{if(65535>=v){if(n+2>=l)break;r[n++>>>0]=224|v>>12}else{if(n+3>=l)break;r[n++>>>0]=240|v>>18,r[n++>>>0]=128|v>>12&63}r[n++>>>0]=128|v>>6&63}r[n++>>>0]=128|v&63}}return r[n>>>0]=0,n-y},Re=(e,r,n)=>Qe(e,h(),r,n);function d(e,r){if(T)return G(5,1,e,r)}function k(e,r,n){if(T)return G(6,1,e,r,n)}function $(e,r,n){return T?G(7,1,e,r,n):0}function Me(e,r){if(T)return G(8,1,e,r)}function Ze(e,r,n){if(T)return G(9,1,e,r,n)}function Rt(e,r,n,l){if(T)return G(10,1,e,r,n,l)}function It(e,r,n,l){if(T)return G(11,1,e,r,n,l)}function Bt(e,r,n,l){if(T)return G(12,1,e,r,n,l)}function kt(e){if(T)return G(13,1,e)}function Wt(e,r){if(T)return G(14,1,e,r)}function Nt(e,r,n){if(T)return G(15,1,e,r,n)}function dt(e){e>>>=0,typeof Atomics.nb=="function"&&(Atomics.nb(f(),e>>>2,e).value.then(it),e+=128,Atomics.store(f(),e>>>2,1))}s.__emscripten_thread_mailbox_await=dt;var it=()=>{var e=ut();if(e&&(dt(e),e=nr,!me))try{if(e(),!(0<De))try{T?yt(F):Ve(F)}catch(r){r instanceof ke||r=="unwind"||V(1,r)}}catch(r){r instanceof ke||r=="unwind"||V(1,r)}};s.checkMailbox=it;var pt=[],$e=e=>e%4===0&&(e%100!==0||e%400===0),Ht=[0,31,60,91,121,152,182,213,244,274,305,335],Gt=[0,31,59,90,120,151,181,212,243,273,304,334];function $t(e,r,n,l,y,b,v,z){return T?G(16,1,e,r,n,l,y,b,v,z):-52}function Yt(e,r,n,l,y,b,v){if(T)return G(17,1,e,r,n,l,y,b,v)}var mt=[],gt={},jt=()=>{if(!ht){var e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:I||"./this.program"},r;for(r in gt)gt[r]===void 0?delete e[r]:e[r]=gt[r];var n=[];for(r in e)n.push(`${r}=${e[r]}`);ht=n}return ht},ht;function zt(e,r){if(T)return G(18,1,e,r);e>>>=0,r>>>=0;var n=0;return jt().forEach((l,y)=>{var b=r+n;for(y=w()[e+4*y>>>2>>>0]=b,b=0;b<l.length;++b)a()[y++>>>0]=l.charCodeAt(b);a()[y>>>0]=0,n+=l.length+1}),0}function qt(e,r){if(T)return G(19,1,e,r);e>>>=0,r>>>=0;var n=jt();w()[e>>>2>>>0]=n.length;var l=0;return n.forEach(y=>l+=y.length+1),w()[r>>>2>>>0]=l,0}function Vt(e){return T?G(20,1,e):52}function Jt(e,r,n,l){return T?G(21,1,e,r,n,l):52}function Xt(e,r,n,l,y){return T?G(22,1,e,r,n,l,y):70}var Hr=[null,[],[]];function Qt(e,r,n,l){if(T)return G(23,1,e,r,n,l);r>>>=0,n>>>=0,l>>>=0;for(var y=0,b=0;b<n;b++){var v=w()[r>>>2>>>0],z=w()[r+4>>>2>>>0];r+=8;for(var Ce=0;Ce<z;Ce++){var fe=h()[v+Ce>>>0],he=Hr[e];fe===0||fe===10?((e===1?Ie:ne)(U(he,0)),he.length=0):he.push(fe)}y+=z}return w()[l>>>2>>>0]=y,0}var Zt=[31,29,31,30,31,30,31,31,30,31,30,31],Kt=[31,28,31,30,31,30,31,31,30,31,30,31];function Gr(e){var r=Array(se(e)+1);return Qe(e,r,0,r.length),r}var $r=(e,r)=>{a().set(e,r>>>0)};function er(e,r,n,l){function y(p,N,q){for(p=typeof p=="number"?p.toString():p||"";p.length<N;)p=q[0]+p;return p}function b(p,N){return y(p,N,"0")}function v(p,N){function q(fr){return 0>fr?-1:0<fr?1:0}var He;return(He=q(p.getFullYear()-N.getFullYear()))===0&&(He=q(p.getMonth()-N.getMonth()))===0&&(He=q(p.getDate()-N.getDate())),He}function z(p){switch(p.getDay()){case 0:return new Date(p.getFullYear()-1,11,29);case 1:return p;case 2:return new Date(p.getFullYear(),0,3);case 3:return new Date(p.getFullYear(),0,2);case 4:return new Date(p.getFullYear(),0,1);case 5:return new Date(p.getFullYear()-1,11,31);case 6:return new Date(p.getFullYear()-1,11,30)}}function Ce(p){var N=p.Qa;for(p=new Date(new Date(p.Ra+1900,0,1).getTime());0<N;){var q=p.getMonth(),He=($e(p.getFullYear())?Zt:Kt)[q];if(N>He-p.getDate())N-=He-p.getDate()+1,p.setDate(1),11>q?p.setMonth(q+1):(p.setMonth(0),p.setFullYear(p.getFullYear()+1));else{p.setDate(p.getDate()+N);break}}return q=new Date(p.getFullYear()+1,0,4),N=z(new Date(p.getFullYear(),0,4)),q=z(q),0>=v(N,p)?0>=v(q,p)?p.getFullYear()+1:p.getFullYear():p.getFullYear()-1}e>>>=0,r>>>=0,n>>>=0,l>>>=0;var fe=w()[l+40>>>2>>>0];l={kb:f()[l>>>2>>>0],jb:f()[l+4>>>2>>>0],Sa:f()[l+8>>>2>>>0],Wa:f()[l+12>>>2>>>0],Ta:f()[l+16>>>2>>>0],Ra:f()[l+20>>>2>>>0],Ma:f()[l+24>>>2>>>0],Qa:f()[l+28>>>2>>>0],qb:f()[l+32>>>2>>>0],ib:f()[l+36>>>2>>>0],lb:fe?ee(fe):""},n=ee(n),fe={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var he in fe)n=n.replace(new RegExp(he,"g"),fe[he]);var ir="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),ur="January February March April May June July August September October November December".split(" ");fe={"%a":p=>ir[p.Ma].substring(0,3),"%A":p=>ir[p.Ma],"%b":p=>ur[p.Ta].substring(0,3),"%B":p=>ur[p.Ta],"%C":p=>b((p.Ra+1900)/100|0,2),"%d":p=>b(p.Wa,2),"%e":p=>y(p.Wa,2," "),"%g":p=>Ce(p).toString().substring(2),"%G":Ce,"%H":p=>b(p.Sa,2),"%I":p=>(p=p.Sa,p==0?p=12:12<p&&(p-=12),b(p,2)),"%j":p=>{for(var N=0,q=0;q<=p.Ta-1;N+=($e(p.Ra+1900)?Zt:Kt)[q++]);return b(p.Wa+N,3)},"%m":p=>b(p.Ta+1,2),"%M":p=>b(p.jb,2),"%n":()=>`\n`,"%p":p=>0<=p.Sa&&12>p.Sa?"AM":"PM","%S":p=>b(p.kb,2),"%t":()=>"	","%u":p=>p.Ma||7,"%U":p=>b(Math.floor((p.Qa+7-p.Ma)/7),2),"%V":p=>{var N=Math.floor((p.Qa+7-(p.Ma+6)%7)/7);if(2>=(p.Ma+371-p.Qa-2)%7&&N++,N)N==53&&(q=(p.Ma+371-p.Qa)%7,q==4||q==3&&$e(p.Ra)||(N=1));else{N=52;var q=(p.Ma+7-p.Qa-1)%7;(q==4||q==5&&$e(p.Ra%400-1))&&N++}return b(N,2)},"%w":p=>p.Ma,"%W":p=>b(Math.floor((p.Qa+7-(p.Ma+6)%7)/7),2),"%y":p=>(p.Ra+1900).toString().substring(2),"%Y":p=>p.Ra+1900,"%z":p=>{p=p.ib;var N=0<=p;return p=Math.abs(p)/60,(N?"+":"-")+("0000"+(p/60*100+p%60)).slice(-4)},"%Z":p=>p.lb,"%%":()=>"%"},n=n.replace(/%%/g,"\\0\\0");for(he in fe)n.includes(he)&&(n=n.replace(new RegExp(he,"g"),fe[he](l)));return n=n.replace(/\\0\\0/g,"%"),he=Gr(n),he.length>r?0:($r(he,e),he.length-1)}M.Va();var Yr=[qe,st,m,ye,oe,d,k,$,Me,Ze,Rt,It,Bt,kt,Wt,Nt,$t,Yt,zt,qt,Vt,Jt,Xt,Qt],jr={b:function(e,r,n){throw e>>>=0,new t(e).Va(r>>>0,n>>>0),o=e,u++,o},L:function(e){tr(e>>>0,!B,1,!R,131072,!1),M.$a()},j:function(e){e>>>=0,T?postMessage({cmd:"cleanupThread",thread:e}):M.Ya(M.La[e])},H:O,h:ye,S:oe,D:d,F:k,T:$,Q:Me,J:Ze,P:Rt,n:It,E:Bt,B:kt,R:Wt,C:Nt,p:()=>1,z:function(e,r){e>>>=0,e==r>>>0?setTimeout(it):T?postMessage({targetThread:e,cmd:"checkMailbox"}):(e=M.La[e])&&e.postMessage({cmd:"checkMailbox"})},I:function(e,r,n,l,y){r>>>=0,n>>>=0,pt.length=l,y=y>>>0>>>3;for(var b=0;b<l;b++)pt[b]=g()[y+b>>>0];return e=r?Ge[r]:Yr[e],M.eb=n,n=e(...pt),M.eb=0,n},K:dt,o:function(e){D&&M.La[e>>>0].ref()},s:function(e,r,n){e=r+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*r:NaN,n>>>=0,e=new Date(1e3*e),f()[n>>>2>>>0]=e.getUTCSeconds(),f()[n+4>>>2>>>0]=e.getUTCMinutes(),f()[n+8>>>2>>>0]=e.getUTCHours(),f()[n+12>>>2>>>0]=e.getUTCDate(),f()[n+16>>>2>>>0]=e.getUTCMonth(),f()[n+20>>>2>>>0]=e.getUTCFullYear()-1900,f()[n+24>>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,f()[n+28>>>2>>>0]=e},t:function(e,r,n){e=r+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*r:NaN,n>>>=0,e=new Date(1e3*e),f()[n>>>2>>>0]=e.getSeconds(),f()[n+4>>>2>>>0]=e.getMinutes(),f()[n+8>>>2>>>0]=e.getHours(),f()[n+12>>>2>>>0]=e.getDate(),f()[n+16>>>2>>>0]=e.getMonth(),f()[n+20>>>2>>>0]=e.getFullYear()-1900,f()[n+24>>>2>>>0]=e.getDay(),r=($e(e.getFullYear())?Ht:Gt)[e.getMonth()]+e.getDate()-1|0,f()[n+28>>>2>>>0]=r,f()[n+36>>>2>>>0]=-(60*e.getTimezoneOffset()),r=new Date(e.getFullYear(),6,1).getTimezoneOffset();var l=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=(r!=l&&e.getTimezoneOffset()==Math.min(l,r))|0,f()[n+32>>>2>>>0]=e},u:function(e){e>>>=0;var r=new Date(f()[e+20>>>2>>>0]+1900,f()[e+16>>>2>>>0],f()[e+12>>>2>>>0],f()[e+8>>>2>>>0],f()[e+4>>>2>>>0],f()[e>>>2>>>0],0),n=f()[e+32>>>2>>>0],l=r.getTimezoneOffset(),y=new Date(r.getFullYear(),6,1).getTimezoneOffset(),b=new Date(r.getFullYear(),0,1).getTimezoneOffset(),v=Math.min(b,y);return 0>n?f()[e+32>>>2>>>0]=+(y!=b&&v==l):0<n!=(v==l)&&(y=Math.max(b,y),r.setTime(r.getTime()+6e4*((0<n?v:y)-l))),f()[e+24>>>2>>>0]=r.getDay(),n=($e(r.getFullYear())?Ht:Gt)[r.getMonth()]+r.getDate()-1|0,f()[e+28>>>2>>>0]=n,f()[e>>>2>>>0]=r.getSeconds(),f()[e+4>>>2>>>0]=r.getMinutes(),f()[e+8>>>2>>>0]=r.getHours(),f()[e+12>>>2>>>0]=r.getDate(),f()[e+16>>>2>>>0]=r.getMonth(),f()[e+20>>>2>>>0]=r.getYear(),e=r.getTime(),e=isNaN(e)?-1:e/1e3,ar((Te=e,1<=+Math.abs(Te)?0<Te?+Math.floor(Te/4294967296)>>>0:~~+Math.ceil((Te-+(~~Te>>>0))/4294967296)>>>0:0)),e>>>0},q:$t,r:Yt,y:function(e,r,n,l){e>>>=0,r>>>=0,n>>>=0,l>>>=0;var y=new Date().getFullYear(),b=new Date(y,0,1),v=new Date(y,6,1);y=b.getTimezoneOffset();var z=v.getTimezoneOffset(),Ce=Math.max(y,z);w()[e>>>2>>>0]=60*Ce,f()[r>>>2>>>0]=+(y!=z),e=fe=>fe.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1],b=e(b),v=e(v),z<y?(Re(b,n,17),Re(v,l,17)):(Re(b,l,17),Re(v,n,17))},c:()=>{te("")},O:function(e,r,n){e>>>=0,r>>>=0,n>>>=0,mt.length=0;for(var l;l=h()[r++>>>0];){var y=l!=105;y&=l!=112,n+=y&&n%8?4:0,mt.push(l==112?w()[n>>>2>>>0]:l==105?f()[n>>>2>>>0]:g()[n>>>3>>>0]),n+=y?8:4}return Ge[e](...mt)},k:()=>{},i:()=>Date.now(),U:()=>{throw De+=1,"unwind"},A:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:()=>D?(br(),et(hr)).cpus().length:navigator.hardwareConcurrency,x:function(e){e>>>=0;var r=h().length;if(e<=r||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var l=r*(1+.2/n);l=Math.min(l,e+100663296);var y=Math;l=Math.max(e,l);e:{y=(y.min.call(y,4294901760,l+(65536-l%65536)%65536)-X.buffer.byteLength+65535)/65536;try{X.grow(y),K();var b=1;break e}catch{}b=void 0}if(b)return!0}return!1},M:zt,N:qt,G:Ve,g:Vt,m:Jt,v:Xt,l:Qt,a:X||s.wasmMemory,w:er,d:function(e,r,n,l){return er(e>>>0,r>>>0,n>>>0,l>>>0)}},C=function(){function e(n,l){return C=n.exports,C=zr(),M.ab.push(C.ya),Xe=C.za,Ue.unshift(C.V),we=l,Be(),C}var r={a:jr};if(Ae++,s.instantiateWasm)try{return s.instantiateWasm(r,e)}catch(n){ne(`Module.instantiateWasm callback failed with error: ${n}`),x(n)}return rt(r,function(n){e(n.instance,n.module)}).catch(x),{}}();s._OrtInit=(e,r)=>(s._OrtInit=C.W)(e,r),s._OrtGetLastError=(e,r)=>(s._OrtGetLastError=C.X)(e,r),s._OrtCreateSessionOptions=(e,r,n,l,y,b,v,z,Ce,fe)=>(s._OrtCreateSessionOptions=C.Y)(e,r,n,l,y,b,v,z,Ce,fe),s._OrtAppendExecutionProvider=(e,r)=>(s._OrtAppendExecutionProvider=C.Z)(e,r),s._OrtAddFreeDimensionOverride=(e,r,n)=>(s._OrtAddFreeDimensionOverride=C._)(e,r,n),s._OrtAddSessionConfigEntry=(e,r,n)=>(s._OrtAddSessionConfigEntry=C.$)(e,r,n),s._OrtReleaseSessionOptions=e=>(s._OrtReleaseSessionOptions=C.aa)(e),s._OrtCreateSession=(e,r,n)=>(s._OrtCreateSession=C.ba)(e,r,n),s._OrtReleaseSession=e=>(s._OrtReleaseSession=C.ca)(e),s._OrtGetInputOutputCount=(e,r,n)=>(s._OrtGetInputOutputCount=C.da)(e,r,n),s._OrtGetInputName=(e,r)=>(s._OrtGetInputName=C.ea)(e,r),s._OrtGetOutputName=(e,r)=>(s._OrtGetOutputName=C.fa)(e,r),s._OrtFree=e=>(s._OrtFree=C.ga)(e),s._OrtCreateTensor=(e,r,n,l,y,b)=>(s._OrtCreateTensor=C.ha)(e,r,n,l,y,b),s._OrtGetTensorData=(e,r,n,l,y)=>(s._OrtGetTensorData=C.ia)(e,r,n,l,y),s._OrtReleaseTensor=e=>(s._OrtReleaseTensor=C.ja)(e),s._OrtCreateRunOptions=(e,r,n,l)=>(s._OrtCreateRunOptions=C.ka)(e,r,n,l),s._OrtAddRunConfigEntry=(e,r,n)=>(s._OrtAddRunConfigEntry=C.la)(e,r,n),s._OrtReleaseRunOptions=e=>(s._OrtReleaseRunOptions=C.ma)(e),s._OrtCreateBinding=e=>(s._OrtCreateBinding=C.na)(e),s._OrtBindInput=(e,r,n)=>(s._OrtBindInput=C.oa)(e,r,n),s._OrtBindOutput=(e,r,n,l)=>(s._OrtBindOutput=C.pa)(e,r,n,l),s._OrtClearBoundOutputs=e=>(s._OrtClearBoundOutputs=C.qa)(e),s._OrtReleaseBinding=e=>(s._OrtReleaseBinding=C.ra)(e),s._OrtRunWithBinding=(e,r,n,l,y)=>(s._OrtRunWithBinding=C.sa)(e,r,n,l,y),s._OrtRun=(e,r,n,l,y,b,v,z)=>(s._OrtRun=C.ta)(e,r,n,l,y,b,v,z),s._OrtEndProfiling=e=>(s._OrtEndProfiling=C.ua)(e);var ut=s._pthread_self=()=>(ut=s._pthread_self=C.va)();s._malloc=e=>(s._malloc=C.wa)(e),s._free=e=>(s._free=C.xa)(e),s.__emscripten_tls_init=()=>(s.__emscripten_tls_init=C.ya)();var tr=s.__emscripten_thread_init=(e,r,n,l,y,b)=>(tr=s.__emscripten_thread_init=C.Aa)(e,r,n,l,y,b);s.__emscripten_thread_crashed=()=>(s.__emscripten_thread_crashed=C.Ba)();var rr=(e,r,n,l,y)=>(rr=C.Ca)(e,r,n,l,y),bt=e=>(bt=C.Da)(e),yt=s.__emscripten_thread_exit=e=>(yt=s.__emscripten_thread_exit=C.Ea)(e),nr=()=>(nr=C.Fa)(),ar=e=>(ar=C.Ga)(e),or=(e,r)=>(or=C.Ha)(e,r),ft=e=>(ft=C.Ia)(e),wt=e=>(wt=C.Ja)(e),Ot=()=>(Ot=C.Ka)();function zr(){var e=C;e=Object.assign({},e);var r=l=>()=>l()>>>0,n=l=>y=>l(y)>>>0;return e.va=r(e.va),e.wa=n(e.wa),e.emscripten_main_runtime_thread_id=r(e.emscripten_main_runtime_thread_id),e.Ja=n(e.Ja),e.Ka=r(e.Ka),e}s.wasmMemory=X,s.stackSave=()=>Ot(),s.stackRestore=e=>ft(e),s.stackAlloc=e=>wt(e),s.keepRuntimeAlive=()=>0<De,s.UTF8ToString=ee,s.stringToUTF8=Re,s.lengthBytesUTF8=se,s.ExitStatus=ke,s.PThread=M;var lt;ge=function e(){lt||sr(),lt||(ge=e)};function sr(){if(!(0<Ae))if(T)S(s),T||Ne(Ue),startWorker(s);else{if(s.preRun)for(typeof s.preRun=="function"&&(s.preRun=[s.preRun]);s.preRun.length;)Oe.unshift(s.preRun.shift());Ne(Oe),0<Ae||lt||(lt=!0,s.calledRun=!0,me||(T||Ne(Ue),S(s),T||Ne(ve)))}}return sr(),H}})();typeof wr=="object"&&typeof Dt=="object"?Dt.exports=yr:typeof define=="function"&&define.amd&&define([],()=>yr)});var vr=Ke((yn,tn)=>{tn.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs"),vm=require("vm");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>vm.runInThisContext(fs.readFileSync(e,"utf8"),{filename:e}),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(...e){var a=e.join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,a+`\\n`);return}console.error(a)}function threadAlert(...e){var a=e.join(" ");postMessage({cmd:"alert",text:a,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,a)=>{var r=Module.wasmModule;Module.wasmModule=null;var t=new WebAssembly.Instance(r,e);return a(t)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let r=[];self.onmessage=t=>r.push(t),self.startWorker=t=>{Module=t,postMessage({cmd:"loaded"});for(let s of r)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const t of e.data.handlers)Module[t]=(...s)=>{postMessage({cmd:"callHandler",handler:t,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var a=URL.createObjectURL(e.data.urlOrBlob);importScripts(a),URL.revokeObjectURL(a)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(r){if(r!="unwind")throw r}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(r){throw Module.__emscripten_thread_crashed?.(),r}}self.onmessage=handleMessage;\\n\'});var Er;Er=pr();var rn=Or(),Ft,Pt=!1,ct=!1,_r=!1,nn=i=>{if(i===1)return!1;if(typeof SharedArrayBuffer>"u")return typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+i+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),!1;typeof process<"u"&&process.versions&&process.versions.node&&console.warn("env.wasm.numThreads is set to "+i+", however, currently onnxruntime-web does not support multi-threads in Node.js. Please consider using onnxruntime-node for performance critical scenarios.");try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},an=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},on=(i,c)=>i?c?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":c?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Sr=async i=>{if(Pt)return Promise.resolve();if(ct)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(_r)throw new Error("previous call to \'initializeWebAssembly()\' failed.");ct=!0;let c=i.initTimeout,a=i.numThreads,h=i.simd,f=nn(a),w=h&&an(),g=i.wasmPaths,s=typeof g=="string"?g:void 0,S=on(w,f),x=typeof g=="object"?g[S]:void 0,H=!1,A=[];if(c>0&&A.push(new Promise(I=>{setTimeout(()=>{H=!0,I()},c)})),A.push(new Promise((I,V)=>{let R=f?rn:Er,B={locateFile:(D,T)=>f&&D.endsWith(".worker.js")&&typeof Blob<"u"?URL.createObjectURL(new Blob([vr()],{type:"text/javascript"})):D.endsWith(".wasm")?x||(s??T)+S:T+D};if(f)if(B.numThreads=a,typeof Blob>"u")B.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let D=`var ortWasmThreaded=${R.toString()};`;B.mainScriptUrlOrBlob=new Blob([D],{type:"text/javascript"})}R(B).then(D=>{ct=!1,Pt=!0,Ft=D,I()},D=>{ct=!1,_r=!0,V(D)})})),await Promise.race(A),H)throw new Error(`WebAssembly backend initializing failed due to timeout: ${c}ms`)},Q=()=>{if(Pt&&Ft)return Ft;throw new Error("WebAssembly is not initialized yet.")};var Y=(i,c)=>{let a=Q(),h=a.lengthBytesUTF8(i)+1,f=a._malloc(h);return a.stringToUTF8(i,f,h),c.push(f),f},tt=(i,c,a,h)=>{if(typeof i=="object"&&i!==null){if(a.has(i))throw new Error("Circular reference in options");a.add(i)}Object.entries(i).forEach(([f,w])=>{let g=c?c+f:f;if(typeof w=="object")tt(w,g+".",a,h);else if(typeof w=="string"||typeof w=="number")h(g,w.toString());else if(typeof w=="boolean")h(g,w?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof w}`)})},j=i=>{let c=Q(),a=c.stackSave();try{let h=c.stackAlloc(8);c._OrtGetLastError(h,h+4);let f=c.HEAP32[h/4],w=c.HEAPU32[h/4+1],g=w?c.UTF8ToString(w):"";throw new Error(`${i} ERROR_CODE: ${f}, ERROR_MESSAGE: ${g}`)}finally{c.stackRestore(a)}};var Ar=i=>{let c=Q(),a=0,h=[],f=i||{};try{if(i?.logSeverityLevel===void 0)f.logSeverityLevel=2;else if(typeof i.logSeverityLevel!="number"||!Number.isInteger(i.logSeverityLevel)||i.logSeverityLevel<0||i.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${i.logSeverityLevel}`);if(i?.logVerbosityLevel===void 0)f.logVerbosityLevel=0;else if(typeof i.logVerbosityLevel!="number"||!Number.isInteger(i.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${i.logVerbosityLevel}`);i?.terminate===void 0&&(f.terminate=!1);let w=0;return i?.tag!==void 0&&(w=Y(i.tag,h)),a=c._OrtCreateRunOptions(f.logSeverityLevel,f.logVerbosityLevel,!!f.terminate,w),a===0&&j("Can\'t create run options."),i?.extra!==void 0&&tt(i.extra,"",new WeakSet,(g,s)=>{let S=Y(g,h),x=Y(s,h);c._OrtAddRunConfigEntry(a,S,x)!==0&&j(`Can\'t set a run config entry: ${g} - ${s}.`)}),[a,h]}catch(w){throw a!==0&&c._OrtReleaseRunOptions(a),h.forEach(g=>c._free(g)),w}};var sn=i=>{switch(i){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${i}`)}},un=i=>{switch(i){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${i}`)}},fn=i=>{i.extra||(i.extra={}),i.extra.session||(i.extra.session={});let c=i.extra.session;c.use_ort_model_bytes_directly||(c.use_ort_model_bytes_directly="1"),i.executionProviders&&i.executionProviders.some(a=>(typeof a=="string"?a:a.name)==="webgpu")&&(i.enableMemPattern=!1)},ln=(i,c,a)=>{for(let h of c){let f=typeof h=="string"?h:h.name;switch(f){case"webnn":if(f="WEBNN",typeof h!="string"){let g=h;if(g?.deviceType){let s=Y("deviceType",a),S=Y(g.deviceType,a);Q()._OrtAddSessionConfigEntry(i,s,S)!==0&&j(`Can\'t set a session config entry: \'deviceType\' - ${g.deviceType}.`)}if(g?.numThreads){let s=g.numThreads;(typeof s!="number"||!Number.isInteger(s)||s<0)&&(s=0);let S=Y("numThreads",a),x=Y(s.toString(),a);Q()._OrtAddSessionConfigEntry(i,S,x)!==0&&j(`Can\'t set a session config entry: \'numThreads\' - ${g.numThreads}.`)}if(g?.powerPreference){let s=Y("powerPreference",a),S=Y(g.powerPreference,a);Q()._OrtAddSessionConfigEntry(i,s,S)!==0&&j(`Can\'t set a session config entry: \'powerPreference\' - ${g.powerPreference}.`)}}break;case"webgpu":if(f="JS",typeof h!="string"){let g=h;if(g?.preferredLayout){if(g.preferredLayout!=="NCHW"&&g.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${g.preferredLayout}`);let s=Y("preferredLayout",a),S=Y(g.preferredLayout,a);Q()._OrtAddSessionConfigEntry(i,s,S)!==0&&j(`Can\'t set a session config entry: \'preferredLayout\' - ${g.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${f}`)}let w=Y(f,a);Q()._OrtAppendExecutionProvider(i,w)!==0&&j(`Can\'t append execution provider: ${f}.`)}},Tr=i=>{let c=Q(),a=0,h=[],f=i||{};fn(f);try{let w=sn(f.graphOptimizationLevel??"all"),g=un(f.executionMode??"sequential"),s=typeof f.logId=="string"?Y(f.logId,h):0,S=f.logSeverityLevel??2;if(!Number.isInteger(S)||S<0||S>4)throw new Error(`log serverity level is not valid: ${S}`);let x=f.logVerbosityLevel??0;if(!Number.isInteger(x)||x<0||x>4)throw new Error(`log verbosity level is not valid: ${x}`);let H=typeof f.optimizedModelFilePath=="string"?Y(f.optimizedModelFilePath,h):0;if(a=c._OrtCreateSessionOptions(w,!!f.enableCpuMemArena,!!f.enableMemPattern,g,!!f.enableProfiling,0,s,S,x,H),a===0&&j("Can\'t create session options."),f.executionProviders&&ln(a,f.executionProviders,h),f.enableGraphCapture!==void 0){if(typeof f.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${f.enableGraphCapture}`);let A=Y("enableGraphCapture",h),I=Y(f.enableGraphCapture.toString(),h);c._OrtAddSessionConfigEntry(a,A,I)!==0&&j(`Can\'t set a session config entry: \'enableGraphCapture\' - ${f.enableGraphCapture}.`)}if(f.freeDimensionOverrides)for(let[A,I]of Object.entries(f.freeDimensionOverrides)){if(typeof A!="string")throw new Error(`free dimension override name must be a string: ${A}`);if(typeof I!="number"||!Number.isInteger(I)||I<0)throw new Error(`free dimension override value must be a non-negative integer: ${I}`);let V=Y(A,h);c._OrtAddFreeDimensionOverride(a,V,I)!==0&&j(`Can\'t set a free dimension override: ${A} - ${I}.`)}return f.extra!==void 0&&tt(f.extra,"",new WeakSet,(A,I)=>{let V=Y(A,h),R=Y(I,h);c._OrtAddSessionConfigEntry(a,V,R)!==0&&j(`Can\'t set a session config entry: ${A} - ${I}.`)}),[a,h]}catch(w){throw a!==0&&c._OrtReleaseSessionOptions(a),h.forEach(g=>c._free(g)),w}};var xt=i=>{switch(i){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${i}`)}},Mr=i=>{switch(i){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${i}`)}},Ut=i=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][i],Cr=i=>{switch(i){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${i}`)}},Dr=i=>{switch(i){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${i}`)}},Fr=i=>i==="float32"||i==="float16"||i==="int32"||i==="int64"||i==="uint32"||i==="uint8"||i==="bool",Pr=i=>{switch(i){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${i}`)}};var xr=async i=>{if(typeof i=="string")if(typeof process<"u"&&process.versions&&process.versions.node)try{return new Uint8Array(await(void 0)(i))}catch(c){if(c.code==="ERR_FS_FILE_TOO_LARGE"){let a=(void 0)(i),h=[];for await(let f of a)h.push(f);return new Uint8Array(Buffer.concat(h))}throw c}else{let c=await fetch(i);if(!c.ok)throw new Error(`failed to load external data file: ${i}`);let a=c.headers.get("Content-Length"),h=a?parseInt(a,10):0;if(h<1073741824)return new Uint8Array(await c.arrayBuffer());{if(!c.body)throw new Error(`failed to load external data file: ${i}, no response body.`);let f=c.body.getReader(),w;try{w=new ArrayBuffer(h)}catch(s){if(s instanceof RangeError){let S=Math.ceil(h/65536);w=new WebAssembly.Memory({initial:S,maximum:S}).buffer}else throw s}let g=0;for(;;){let{done:s,value:S}=await f.read();if(s)break;let x=S.byteLength;new Uint8Array(w,g,x).set(S),g+=x}return new Uint8Array(w,0,h)}}else return i instanceof Blob?new Uint8Array(await i.arrayBuffer()):i instanceof Uint8Array?i:new Uint8Array(i)};var cn=(i,c)=>{Q()._OrtInit(i,c)!==0&&j("Can\'t initialize onnxruntime.")},Lr=async i=>{cn(i.wasm.numThreads,Dr(i.logLevel))},Rr=async(i,c)=>{},Ye=new Map,dn=i=>{let c=Q(),a=c.stackSave();try{let h=c.stackAlloc(8);return c._OrtGetInputOutputCount(i,h,h+4)!==0&&j("Can\'t get session input/output count."),[c.HEAP32[h/4],c.HEAP32[h/4+1]]}finally{c.stackRestore(a)}},Lt=i=>{let c=Q(),a=c._malloc(i.byteLength);if(a===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${i.byteLength}.`);return c.HEAPU8.set(i,a),[a,i.byteLength]},Ir=async(i,c)=>{let a,h,f=Q();Array.isArray(i)?[a,h]=i:i.buffer===f.HEAPU8.buffer?[a,h]=[i.byteOffset,i.byteLength]:[a,h]=Lt(i);let w=0,g=0,s=0,S=[],x=[],H=[];try{if([g,S]=Tr(c),c?.externalData&&f.mountExternalData){let L=[];for(let W of c.externalData){let de=typeof W=="string"?W:W.path;L.push(xr(typeof W=="string"?W:W.data).then(pe=>{f.mountExternalData(de,pe)}))}await Promise.all(L)}w=await f._OrtCreateSession(a,h,g),w===0&&j("Can\'t create a session.");let[A,I]=dn(w),V=!!c?.enableGraphCapture,R=[],B=[],D=[];for(let L=0;L<A;L++){let W=f._OrtGetInputName(w,L);W===0&&j("Can\'t get an input name."),x.push(W),R.push(f.UTF8ToString(W))}for(let L=0;L<I;L++){let W=f._OrtGetOutputName(w,L);W===0&&j("Can\'t get an output name."),H.push(W);let de=f.UTF8ToString(W);B.push(de)}let T=null;return Ye.set(w,[w,x,H,T,V,!1]),[w,R,B]}catch(A){throw x.forEach(I=>f._OrtFree(I)),H.forEach(I=>f._OrtFree(I)),s!==0&&f._OrtReleaseBinding(s),w!==0&&f._OrtReleaseSession(w),A}finally{f._free(a),g!==0&&f._OrtReleaseSessionOptions(g),S.forEach(A=>f._free(A)),f.unmountExternalData?.()}},Br=i=>{let c=Q(),a=Ye.get(i);if(!a)throw new Error(`cannot release session. invalid session id: ${i}`);let[h,f,w,g,s]=a;g&&(s&&c._OrtClearBoundOutputs(g.handle),c._OrtReleaseBinding(g.handle)),c.jsepOnReleaseSession?.(i),f.forEach(S=>c._OrtFree(S)),w.forEach(S=>c._OrtFree(S)),c._OrtReleaseSession(h),Ye.delete(i)},Ur=(i,c,a,h,f,w=!1)=>{if(!i){c.push(0);return}let g=Q(),s=i[0],S=i[1],x=i[3],H,A;if(s==="string"&&x==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(w&&x!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${f} when enableGraphCapture is true.`);if(x==="gpu-buffer"){let R=i[2].gpuBuffer,B=Ut(xt(s));A=S.reduce((T,L)=>T*L,1)*B;let D=g.jsepRegisterBuffer;if(!D)throw new Error(\'Tensor location "gpu-buffer" is not supported without using WebGPU.\');H=D(h,f,R,A)}else{let R=i[2];if(Array.isArray(R)){A=4*R.length,H=g._malloc(A),a.push(H);let B=H/4;for(let D=0;D<R.length;D++){if(typeof R[D]!="string")throw new TypeError(`tensor data at index ${D} is not a string`);g.HEAPU32[B++]=Y(R[D],a)}}else A=R.byteLength,H=g._malloc(A),a.push(H),g.HEAPU8.set(new Uint8Array(R.buffer,R.byteOffset,A),H)}let I=g.stackSave(),V=g.stackAlloc(4*S.length);try{let R=V/4;S.forEach(D=>g.HEAP32[R++]=D);let B=g._OrtCreateTensor(xt(s),H,A,V,S.length,Pr(x));B===0&&j(`Can\'t create tensor for input/output. session=${h}, index=${f}.`),c.push(B)}finally{g.stackRestore(I)}},kr=async(i,c,a,h,f,w)=>{let g=Q(),s=Ye.get(i);if(!s)throw new Error(`cannot run inference. invalid session id: ${i}`);let S=s[0],x=s[1],H=s[2],A=s[3],I=s[4],V=s[5],R=c.length,B=h.length,D=0,T=[],L=[],W=[],de=[],pe=g.stackSave(),Z=g.stackAlloc(R*4),_=g.stackAlloc(R*4),J=g.stackAlloc(B*4),Pe=g.stackAlloc(B*4);try{[D,T]=Ar(w);for(let F=0;F<R;F++)Ur(a[F],L,de,i,c[F],I);for(let F=0;F<B;F++)Ur(f[F],W,de,i,R+h[F],I);let le=Z/4,Ie=_/4,ne=J/4,X=Pe/4;for(let F=0;F<R;F++)g.HEAPU32[le++]=L[F],g.HEAPU32[Ie++]=x[c[F]];for(let F=0;F<B;F++)g.HEAPU32[ne++]=W[F],g.HEAPU32[X++]=H[h[F]];g.jsepOnRunStart?.(S);let we;we=await g._OrtRun(S,_,Z,R,Pe,B,J,D),we!==0&&j("failed to call OrtRun().");let me=[];for(let F=0;F<B;F++){let ie=g.HEAPU32[J/4+F];if(ie===W[F]){me.push(f[F]);continue}let xe=g.stackSave(),ce=g.stackAlloc(4*4),be=!1,ae,K=0;try{g._OrtGetTensorData(ie,ce,ce+4,ce+8,ce+12)!==0&&j(`Can\'t access output tensor data on index ${F}.`);let Oe=ce/4,Ue=g.HEAPU32[Oe++];K=g.HEAPU32[Oe++];let ve=g.HEAPU32[Oe++],Ae=g.HEAPU32[Oe++],_e=[];for(let te=0;te<Ae;te++)_e.push(g.HEAPU32[ve/4+te]);g._OrtFree(ve);let ge=_e.reduce((te,re)=>te*re,1);ae=Mr(Ue);let Be=A?.outputPreferredLocations[h[F]];if(ae==="string"){if(Be==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let te=[],re=K/4;for(let ue=0;ue<ge;ue++){let Ee=g.HEAPU32[re++],Se=ue===ge-1?void 0:g.HEAPU32[re]-Ee;te.push(g.UTF8ToString(Ee,Se))}me.push([ae,_e,te,"cpu"])}else if(Be==="gpu-buffer"&&ge>0){let te=g.jsepGetBuffer;if(!te)throw new Error(\'preferredLocation "gpu-buffer" is not supported without using WebGPU.\');let re=te(K),ue=Ut(Ue);if(ue===void 0||!Fr(ae))throw new Error(`Unsupported data type: ${ae}`);be=!0,me.push([ae,_e,{gpuBuffer:re,download:g.jsepCreateDownloader(re,ge*ue,ae),dispose:()=>{g._OrtReleaseTensor(ie)}},"gpu-buffer"])}else{let te=Cr(ae),re=new te(ge);new Uint8Array(re.buffer,re.byteOffset,re.byteLength).set(g.HEAPU8.subarray(K,K+re.byteLength)),me.push([ae,_e,re,"cpu"])}}finally{g.stackRestore(xe),ae==="string"&&K&&g._free(K),be||g._OrtReleaseTensor(ie)}}return A&&!I&&(g._OrtClearBoundOutputs(A.handle),Ye.set(i,[S,x,H,A,I,!1])),me}finally{g.stackRestore(pe),L.forEach(le=>g._OrtReleaseTensor(le)),W.forEach(le=>g._OrtReleaseTensor(le)),de.forEach(le=>g._free(le)),D!==0&&g._OrtReleaseRunOptions(D),T.forEach(le=>g._free(le))}},Wr=i=>{let c=Q(),a=Ye.get(i);if(!a)throw new Error("invalid session id");let h=a[0],f=c._OrtEndProfiling(h);f===0&&j("Can\'t get an profile file name."),c._OrtFree(f)},Nr=i=>{let c=[];for(let a of i){let h=a[2];!Array.isArray(h)&&"buffer"in h&&c.push(h.buffer)}return c};self.onmessage=i=>{let{type:c,in:a}=i.data;try{switch(c){case"init-wasm":Sr(a.wasm).then(()=>{Lr(a).then(()=>{postMessage({type:c})},h=>{postMessage({type:c,err:h})})},h=>{postMessage({type:c,err:h})});break;case"init-ep":{let{epName:h,env:f}=a;Rr(f,h).then(()=>{postMessage({type:c})},w=>{postMessage({type:c,err:w})});break}case"copy-from":{let{buffer:h}=a,f=Lt(h);postMessage({type:c,out:f});break}case"create":{let{model:h,options:f}=a;Ir(h,f).then(w=>{postMessage({type:c,out:w})},w=>{postMessage({type:c,err:w})});break}case"release":Br(a),postMessage({type:c});break;case"run":{let{sessionId:h,inputIndices:f,inputs:w,outputIndices:g,options:s}=a;kr(h,f,w,g,new Array(g.length).fill(null),s).then(S=>{S.some(x=>x[3]!=="cpu")?postMessage({type:c,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:c,out:S},Nr([...w,...S]))},S=>{postMessage({type:c,err:S})});break}case"end-profiling":Wr(a),postMessage({type:c});break;default:}}catch(h){postMessage({type:c,err:h})}};})();\n'}),T3,n1,Q4,D4,_4,R6,U5,f3,l3,B2,P4,HH,ZH,jH,VH,XH,KH,UH,qH=E(()=>{z3(),vV(),s4(),T3=()=>!!i.wasm.proxy&&typeof document<"u",Q4=!1,D4=!1,_4=!1,U5=new Map,f3=(Q,H)=>{let j=U5.get(Q);j?j.push(H):U5.set(Q,[H])},l3=()=>{if(Q4||!D4||_4||!n1)throw new Error("worker not ready")},B2=(Q)=>{switch(Q.data.type){case"init-wasm":Q4=!1,Q.data.err?(_4=!0,R6[1](Q.data.err)):(D4=!0,R6[0]());break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let H=U5.get(Q.data.type);Q.data.err?H.shift()[1](Q.data.err):H.shift()[0](Q.data.out);break}default:}},P4=typeof document<"u"?document?.currentScript?.src:void 0,HH=async()=>{if(!D4){if(Q4)throw new Error("multiple calls to 'initWasm()' detected.");if(_4)throw new Error("previous call to 'initWasm()' failed.");if(Q4=!0,T3())return i.wasm.wasmPaths===void 0&&P4&&P4.indexOf("blob:")!==0&&(i.wasm.wasmPaths=P4.substr(0,+P4.lastIndexOf("/")+1)),new Promise((Q,H)=>{n1?.terminate();let j=URL.createObjectURL(new Blob([wV()],{type:"text/javascript"}));n1=new Worker(j,{name:"ort-wasm-proxy-worker"}),n1.onerror=(W)=>H(W),n1.onmessage=B2,URL.revokeObjectURL(j),R6=[Q,H];let K={type:"init-wasm",in:i};n1.postMessage(K)});try{await bJ(i.wasm),await aJ(i),D4=!0}catch(Q){throw _4=!0,Q}finally{Q4=!1}}},ZH=async(Q)=>{if(T3())return l3(),new Promise((H,j)=>{f3("init-ep",[H,j]);let K={type:"init-ep",in:{epName:Q,env:i}};n1.postMessage(K)});await nJ(i,Q)},jH=async(Q)=>T3()?(l3(),new Promise((H,j)=>{f3("copy-from",[H,j]);let K={type:"copy-from",in:{buffer:Q}};n1.postMessage(K,[Q.buffer])})):o6(Q),VH=async(Q,H)=>{if(T3()){if(H?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return l3(),new Promise((j,K)=>{f3("create",[j,K]);let W={type:"create",in:{model:Q,options:{...H}}},U=[];Q instanceof Uint8Array&&U.push(Q.buffer),n1.postMessage(W,U)})}else return rJ(Q,H)},XH=async(Q)=>{if(T3())return l3(),new Promise((H,j)=>{f3("release",[H,j]);let K={type:"release",in:Q};n1.postMessage(K)});tJ(Q)},KH=async(Q,H,j,K,W,U)=>{if(T3()){if(j.some((Z)=>Z[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(W.some((Z)=>Z))throw new Error("pre-allocated output tensor is not supported for proxy.");return l3(),new Promise((Z,q)=>{f3("run",[Z,q]);let G=j,J={type:"run",in:{sessionId:Q,inputIndices:H,inputs:G,outputIndices:K,options:U}};n1.postMessage(J,JH(G))})}else return eJ(Q,H,j,K,W,U)},UH=async(Q)=>{if(T3())return l3(),new Promise((H,j)=>{f3("end-profiling",[H,j]);let K={type:"end-profiling",in:Q};n1.postMessage(K)});QH(Q)}}),z6,F2,WH,TV=E(()=>{z3(),qH(),iJ(),oJ(),z6=(Q,H)=>{switch(Q.location){case"cpu":return[Q.type,Q.dims,Q.data,"cpu"];case"gpu-buffer":return[Q.type,Q.dims,{gpuBuffer:Q.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${Q.location} for ${H()}`)}},F2=(Q)=>{switch(Q[3]){case"cpu":return new d1(Q[0],Q[2],Q[1]);case"gpu-buffer":{let H=Q[0];if(!R7(H))throw new Error(`not supported data type: ${H} for deserializing GPU tensor`);let{gpuBuffer:j,download:K,dispose:W}=Q[2];return d1.fromGpuBuffer(j,{dataType:H,dims:Q[1],download:K,dispose:W})}default:throw new Error(`invalid data location: ${Q[3]}`)}},WH=class{async fetchModelAndCopyToWasmMemory(Q){return jH(await Y5(Q))}async loadModel(Q,H){j4();let j;typeof Q=="string"?typeof process<"u"&&process.versions&&process.versions.node?j=await Y5(Q):j=await this.fetchModelAndCopyToWasmMemory(Q):j=Q,[this.sessionId,this.inputNames,this.outputNames]=await VH(j,H),V4()}async dispose(){return XH(this.sessionId)}async run(Q,H,j){j4();let K=[],W=[];Object.entries(Q).forEach((V)=>{let R=V[0],z=V[1],Y=this.inputNames.indexOf(R);if(Y===-1)throw new Error(`invalid input '${R}'`);K.push(z),W.push(Y)});let U=[],Z=[];Object.entries(H).forEach((V)=>{let R=V[0],z=V[1],Y=this.outputNames.indexOf(R);if(Y===-1)throw new Error(`invalid output '${R}'`);U.push(z),Z.push(Y)});let q=K.map((V,R)=>z6(V,()=>`input "${this.inputNames[W[R]]}"`)),G=U.map((V,R)=>V?z6(V,()=>`output "${this.outputNames[Z[R]]}"`):null),J=await KH(this.sessionId,W,q,Z,G,j),X={};for(let V=0;V<J.length;V++)X[this.outputNames[Z[V]]]=U[V]??F2(J[V]);return V4(),X}startProfiling(){}endProfiling(){UH(this.sessionId)}}}),k2,GH,DV=E(()=>{z3(),qH(),TV(),k2=()=>{if((typeof i.wasm.initTimeout!="number"||i.wasm.initTimeout<0)&&(i.wasm.initTimeout=0),typeof i.wasm.simd!="boolean"&&(i.wasm.simd=!0),typeof i.wasm.proxy!="boolean"&&(i.wasm.proxy=!1),typeof i.wasm.trace!="boolean"&&(i.wasm.trace=!1),typeof i.wasm.numThreads!="number"||!Number.isInteger(i.wasm.numThreads)||i.wasm.numThreads<=0){(typeof self<"u"&&!self.crossOriginIsolated||typeof process<"u"&&process.versions&&process.versions.node)&&(i.wasm.numThreads=1);let Q=typeof navigator>"u"?(void 0)().length:navigator.hardwareConcurrency;i.wasm.numThreads=Math.min(4,Math.ceil((Q||1)/2))}},GH=class{async init(Q){k2(),await HH(),await ZH(Q)}async createInferenceSessionHandler(Q,H){let j=new WH;return await j.loadModel(Q,H),Promise.resolve(j)}}}),RH={};X4(RH,{wasmBackend:()=>zH});var zH,_V=E(()=>{DV(),zH=new GH});z3();z3();z3();var PV="1.18.0",EV=s2;{let Q=(YV(),a3(PJ)).onnxjsBackend;p4("webgl",Q,-10)}{let Q=(_V(),a3(RH)).wasmBackend;p4("cpu",Q,10),p4("wasm",Q,10)}Object.defineProperty(i.versions,"web",{value:PV,enumerable:!0});/*! Bundled license information:

long/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)
*/export{p4 as registerBackend,i as env,EV as default,u2 as TrainingSession,d1 as Tensor,V4 as TRACE_FUNC_END,j4 as TRACE_FUNC_BEGIN,Y6 as TRACE,f2 as InferenceSession};
